////////////////////////////////////////////////////////////////////////////////
// Подсистема "Файловые функции".
//
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

// Объявляет служебные события подсистемы ФайловыеФункции:
//
// Серверные события:
//   ПриДобавленииФайловВТомаПриРазмещении,
//   ПриУдаленииРегистрацииИзменений,
//   ПриОпределенииТекстаЗапросаДляИзвлеченияТекста,
//   ПриОпределенииКоличестваВерсийСНеизвлеченнымТекстом,
//   ПриЗаписиИзвлеченногоТекста,
//   ПриОпределенииКоличестваФайловВТомах,
//   ПриОпределенииНаличияХранимыхФайлов,
//   ПриПолученииХранимыхФайлов,
//   ПриОпределенииНавигационнойСсылкиФайла,
//   ПриОпределенииИмениФайлаСПутемКДвоичнымДанным.
//
// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииСлужебныхСобытий(КлиентскиеСобытия, СерверныеСобытия) Экспорт
	
	// СЕРВЕРНЫЕ СОБЫТИЯ.
	
	// Добавляет файл на том при "Разместить файлы начального образа".
	//
	// Синтаксис:
	// Процедура ПриДобавленииФайловВТомаПриРазмещении(СоответствиеПутейФайлов, ХранитьФайлыВТомахНаДиске, ПрисоединяемыеФайлы) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриДобавленииФайловВТомаПриРазмещении");
	
	// Удаляет регистрацию изменений после "Разместить файлы начального образа".
	//
	// Синтаксис:
	// Процедура ПриУдаленииРегистрацииИзменений(ПланОбменаСсылка, ПрисоединяемыеФайлы) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриУдаленииРегистрацииИзменений");
	
	// Заполняет текст запроса для получения файлов у которых не извлечен текст.
	// В качестве параметра может прийти другой запрос, с которым следует сделать объединение.
	//
	// Параметры:
	//  ТекстЗапроса - Строка (возвращаемое значение), варианты передаваемых значений:
	//                   Пустая строка   - будет возвращен требуемый текст запроса.
	//                   Непустая строка - будет возвращен требуемый текст запроса, добавленный
	//                                     к переданному тексту посредством "ОБЪЕДИНИТЬ ВСЕ".
	// 
	//  ПолучитьВсеФайлы - Булево - начальное значение Ложь. Позволяет отключить выборку
	//                     файлов по частям, если передать Истина.
	//
	// Синтаксис:
	// Процедура ПриОпределенииТекстаЗапросаДляИзвлеченияТекста(ТекстЗапроса, ПолучитьВсеФайлы = Ложь) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииТекстаЗапросаДляИзвлеченияТекста");
	
	// Возвращает число файлов с неизвлеченным текстом.
	//
	// Синтаксис:
	// Процедура ПриОпределенииКоличестваВерсийСНеизвлеченнымТекстом(ЧислоВерсий) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииКоличестваВерсийСНеизвлеченнымТекстом");
	
	// Записывает извлеченный текст.
	//
	// Синтаксис:
	// Процедура ПриЗаписиИзвлеченногоТекста(ФайлОбъект) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриЗаписиИзвлеченногоТекста");
	
	// Возвращает в параметре КоличествоФайловВТомах количество файлов в томах.
	//
	// Синтаксис:
	// Процедура ПриОпределенииКоличестваФайловВТомах(КоличествоФайловВТомах) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииКоличестваФайловВТомах");
	
	// Возвращает Истина в параметре ЕстьХранимыеФайлы, если есть хранимые файлы к объекту ВнешнийОбъект.
	//
	// Синтаксис:
	// Процедура ПриОпределенииНаличияХранимыхФайлов(ВнешнийОбъект, ЕстьХранимыеФайлы) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииНаличияХранимыхФайлов");
	
	// Возвращает в параметре ХранимыеФайлы массив хранимых файлов к объекту ВнешнийОбъект.
	//
	// Синтаксис:
	// Процедура ПриПолученииХранимыхФайлов(ВнешнийОбъект, ХранимыеФайлы) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриПолученииХранимыхФайлов");
	
	// Возвращает навигационную ссылку на файл (на реквизит или во временное хранилище).
	//
	// Синтаксис:
	// Процедура ПриОпределенииНавигационнойСсылкиФайла(ФайлСсылка, УникальныйИдентификатор, НавигационнаяСсылка) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииНавигационнойСсылкиФайла");
	
	// Получает полный путь к файлу на диске.
	//
	// Синтаксис:
	// Процедура ПриОпределенииИмениФайлаСПутемКДвоичнымДанным(ФайлСсылка, ПутьКФайлу, ПустойПутьДляПустыхДанных = Ложь) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииИмениФайлаСПутемКДвоичнымДанным");
	
КонецПроцедуры

// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииОбработчиковСлужебныхСобытий(КлиентскиеОбработчики, СерверныеОбработчики) Экспорт
	
	// СЕРВЕРНЫЕ ОБРАБОТЧИКИ.
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления"].Добавить(
			"ФайловыеФункцииСлужебный");
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииПараметровРаботыКлиента"].Добавить(
			"ФайловыеФункцииСлужебный");
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриЗаполненииРазрешенийНаДоступКВнешнимРесурсам"].Добавить(
			"ФайловыеФункцииСлужебный");
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.ВыгрузкаЗагрузкаДанных") Тогда
		СерверныеОбработчики[
			"ТехнологияСервиса.ВыгрузкаЗагрузкаДанных\ПриЗаполненииТиповОбщихДанныхНеТребующихСопоставлениеСсылокПриЗагрузке"].Добавить(
				"ФайловыеФункцииСлужебный");
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ВариантыОтчетов") Тогда
		СерверныеОбработчики["СтандартныеПодсистемы.ВариантыОтчетов\ПриНастройкеВариантовОтчетов"].Добавить(
			"ФайловыеФункцииСлужебный");
	КонецЕсли;
	
КонецПроцедуры

// Определить список справочников, доступных для загрузки с помощью подсистемы "Загрузка данных из файла".
//
// Параметры:
//  ЗагружаемыеСправочники - ТаблицаЗначений - список справочников, в которые возможна загрузка данных.
//      * ПолноеИмя          - Строка - полное имя справочника (как в метаданных).
//      * Представление      - Строка - представление справочника в списке выбора.
//      * ПрикладнаяЗагрузка - Булево - если Истина, значит справочник использует собственный алгоритм загрузки и
//                                      в модуле менеджера справочника определены функции.
//
Процедура ПриОпределенииСправочниковДляЗагрузкиДанных(ЗагружаемыеСправочники) Экспорт
	
	// Загрузка в справочник ТомаХраненияФайлов запрещена.
	СтрокаТаблицы = ЗагружаемыеСправочники.Найти(Метаданные.Справочники.ТомаХраненияФайлов.ПолноеИмя(), "ПолноеИмя");
	Если СтрокаТаблицы <> Неопределено Тогда 
		ЗагружаемыеСправочники.Удалить(СтрокаТаблицы);
	КонецЕсли;
	
КонецПроцедуры

// Определить объекты метаданных, в модулях менеджеров которых ограничивается возможность 
// редактирования реквизитов при групповом изменении.
//
// Параметры:
//   Объекты - Соответствие - в качестве ключа указать полное имя объекта метаданных,
//                            подключенного к подсистеме "Групповое изменение объектов". 
//                            Дополнительно в значении могут быть перечислены имена экспортных функций:
//                            "РеквизитыНеРедактируемыеВГрупповойОбработке",
//                            "РеквизитыРедактируемыеВГрупповойОбработке".
//                            Каждое имя должно начинаться с новой строки.
//                            Если указана пустая строка, значит в модуле менеджера определены обе функции.
//
Процедура ПриОпределенииОбъектовСРедактируемымиРеквизитами(Объекты) Экспорт
	Объекты.Вставить(Метаданные.Справочники.ТомаХраненияФайлов.ПолноеИмя(), "РеквизитыРедактируемыеВГрупповойОбработке");
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Поддержка обмена файлами

// Служебная функции. Используется для удаления файла на сервере.
// 
Процедура УдалитьФайлыНаСервере(ПрежнийПутьНаТоме) Экспорт
	
	// Удаляем файл.
	ФайлВременный = Новый Файл(ПрежнийПутьНаТоме);
	Если ФайлВременный.Существует() Тогда
		
		Попытка
			ФайлВременный.УстановитьТолькоЧтение(Ложь);
			УдалитьФайлы(ПрежнийПутьНаТоме);
		Исключение
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Файлы.Удаление файлов в томе при обмене'",
				     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,
				,
				,
				ИнформацияОбОшибке());
		КонецПопытки;
		
	КонецЕсли;
	
	// Удаляем каталог файла, если после удаления файла каталог стал пустым.
	Попытка
		МассивФайловВКаталоге = НайтиФайлы(ФайлВременный.Путь, "*.*");
		Если МассивФайловВКаталоге.Количество() = 0 Тогда
			УдалитьФайлы(ФайлВременный.Путь);
		КонецЕсли;
	Исключение
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Файлы.Удаление файлов в томе при обмене'",
			     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ИнформацияОбОшибке() );
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Работа с томами файлов

// Возвращает тип хранения файлов.
// 
// Возвращаемое значение:
//  Булево. Истина, если указано хранить файлы в томах на диске.
//
Функция ХранениеФайловВТомахНаДиске() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ХранитьФайлыВТомахНаДиске = Константы.ХранитьФайлыВТомахНаДиске.Получить();
	
	Возврат ХранитьФайлыВТомахНаДиске;
	
КонецФункции

// Возвращает тип хранения файлов с учетом наличия томов.
// Если томов хранения файлов нет, тогда хранение в ИБ.
//
// Возвращаемое значение:
//  ПеречисленияСсылка.ТипыХраненияФайлов.
//
Функция ТипХраненияФайлов() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ХранитьФайлыВТомахНаДиске = Константы.ХранитьФайлыВТомахНаДиске.Получить();
	
	Если ХранитьФайлыВТомахНаДиске Тогда
		
		Если ФайловыеФункции.ЕстьТомаХраненияФайлов() Тогда
			Возврат Перечисления.ТипыХраненияФайлов.ВТомахНаДиске;
		Иначе
			Возврат Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
		КонецЕсли;
		
	Иначе
		Возврат Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
	КонецЕсли;

КонецФункции

// Проверяет, что хотя бы в одном томе есть хотя бы один файл.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьФайлыВТомах() Экспорт
	
	Если КоличествоФайловВТомах() <> 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Возвращает полный путь тома - в зависимости от ОС.
Функция ПолныйПутьТома(СсылкаНаТом) Экспорт
	
	ТипПлатформыСервера = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера();
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86
	 ИЛИ ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		
		Возврат СсылкаНаТом.ПолныйПутьWindows;
	Иначе
		Возврат СсылкаНаТом.ПолныйПутьLinux;
	КонецЕсли;
	
КонецФункции

// Добавляет файл в один из томов (где есть свободное место).
//
// Параметры:
//   ДвоичныеДанныеИлиПуть  - ДвоичныеДанные, Строка - двоичные данные файла или полный путь к файлу на диске.
//   ВремяИзмененияУниверсальное - Дата - универсальное время, которое будет установлено файлу как время последнего
//                                        изменения.
//   ИмяБезРасширения       - Строка - имя файла без расширения. 
//   Расширение             - Строка - расширение файла без точки. 
//   НомерВерсии            - Строка - номер версии файла. Если указан, то имя файла для хранения на диске формируется
//                                     как:
//                                     ИмяБезРасширения + "." + НомерВерсии + "." + Расширение
//                                     в противном случае, ИмяБезРасширения + "." + Расширение.
//   Зашифрован             - Булево - если Истина, то к полному имени файла будет добавлено расширение ".p7m".
//   ДатаДляРазмещенияВТоме - Дата   - если не указано, то используется текущее время сеанса.
//  
//  Возвращаемое значение:
//    Структура - со свойствами:
//      * Том         - СправочникСсылка.ТомаХраненияФайлов - том, в котором был размещен файл.
//      * ПутьКФайлу  - Строка - путь, по которому был размещен файл в томе.
//
Функция ДобавитьФайлВТом(ДвоичныеДанныеИлиПуть, ВремяИзмененияУниверсальное, ИмяБезРасширения, Расширение,
	НомерВерсии = "", Зашифрован = Ложь, ДатаДляРазмещенияВТоме = Неопределено) Экспорт
	
	ОжидаемыеТипы = Новый Массив;
	ОжидаемыеТипы.Добавить(Тип("ДвоичныеДанные"));
	ОжидаемыеТипы.Добавить(Тип("Строка"));
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр("ФайловыеФункцииСлужебный.ДобавитьНаДиск", "ДвоичныеДанныеИлиПуть", ДвоичныеДанныеИлиПуть,	
		Новый ОписаниеТипов(ОжидаемыеТипы));
		
	УстановитьПривилегированныйРежим(Истина);
	
	СсылкаНаТом = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
	
	КраткоеОписаниеВсехОшибок   = ""; // Ошибки со всех томов.
	ПодробноеОписаниеВсехОшибок = ""; // Для журнала регистрации.
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ТомаХраненияФайлов.Ссылка
		|ИЗ
		|	Справочник.ТомаХраненияФайлов КАК ТомаХраненияФайлов
		|ГДЕ
		|	ТомаХраненияФайлов.ПометкаУдаления = ЛОЖЬ
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТомаХраненияФайлов.ПорядокЗаполнения";

	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Количество() = 0 Тогда
		ВызватьИсключение НСтр("ru = 'Нет ни одного тома для размещения файла.'");
	КонецЕсли;
	
	Пока Выборка.Следующий() Цикл
		
		СсылкаНаТом = Выборка.Ссылка;
		
		ПутьКТому = ПолныйПутьТома(СсылкаНаТом);
		// Добавляем слэш в конце, если его нет.
		ПутьКТому = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПутьКТому);
		
		// Имя файла для хранения на диске формировать следующим образом
		// - имя файла.номер версии.расширение файла.
		Если ПустаяСтрока(НомерВерсии) Тогда
			ИмяФайла = ИмяБезРасширения + "." + Расширение;
		Иначе
			ИмяФайла = ИмяБезРасширения + "." + НомерВерсии + "." + Расширение;
		КонецЕсли;
		
		Если Зашифрован Тогда
			ИмяФайла = ИмяФайла + "." + "p7m";
		КонецЕсли;
		
		Попытка
			
			Если ТипЗнч(ДвоичныеДанныеИлиПуть) = Тип("ДвоичныеДанные") Тогда
				РазмерФайла = ДвоичныеДанныеИлиПуть.Размер();
			Иначе // Считаем, что иначе это путь к файлу на диске.
				ФайлИсточник = Новый Файл(ДвоичныеДанныеИлиПуть);
				РазмерФайла = ФайлИсточник.Размер();
			КонецЕсли;
			
			// Если МаксимальныйРазмер = 0 - нет ограничения на размер файлов на томе.
			Если СсылкаНаТом.МаксимальныйРазмер <> 0 Тогда
				
				ТекущийРазмерВБайтах = 0;
				
				ПриОпределенииРазмераФайловНаТоме(СсылкаНаТом.Ссылка, ТекущийРазмерВБайтах);
				
				НовыйРазмерВБайтах = ТекущийРазмерВБайтах + РазмерФайла;
				НовыйРазмер = НовыйРазмерВБайтах / (1024 * 1024);
				
				Если НовыйРазмер > СсылкаНаТом.МаксимальныйРазмер Тогда
					
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Превышен максимальный размер тома (%1 Мб).'"),
						СсылкаНаТом.МаксимальныйРазмер);
				КонецЕсли;
			КонецЕсли;
			
			Дата = ТекущаяДатаСеанса();
			Если ДатаДляРазмещенияВТоме <> Неопределено Тогда
				Дата = ДатаДляРазмещенияВТоме;
			КонецЕсли;
			
			// Использование абсолютного формата даты "ДФ" в следующей строке
			// является правильным, так как дата используется не для просмотра пользователем.
			ПутьДня = Формат(Дата, "ДФ=ггггММдд") + ПолучитьРазделительПути();
			
			ПутьКТому = ПутьКТому + ПутьДня;
			
			ИмяФайлаСПутем = ФайловыеФункцииСлужебныйКлиентСервер.ПолучитьУникальноеИмяСПутем(ПутьКТому, ИмяФайла);
			ПолноеИмяФайлаСПутем = ПутьКТому + ИмяФайлаСПутем;
			
			Если ТипЗнч(ДвоичныеДанныеИлиПуть) = Тип("ДвоичныеДанные") Тогда
				ДвоичныеДанныеИлиПуть.Записать(ПолноеИмяФайлаСПутем);
			Иначе // Считаем, что иначе это путь к файлу на диске.
				КопироватьФайл(ДвоичныеДанныеИлиПуть, ПолноеИмяФайлаСПутем);
			КонецЕсли;
			
			// Установка времени изменения файла таким, как оно стоит в текущей версии.
			ФайлНаДиске = Новый Файл(ПолноеИмяФайлаСПутем);
			ФайлНаДиске.УстановитьУниверсальноеВремяИзменения(ВремяИзмененияУниверсальное);
			ФайлНаДиске.УстановитьТолькоЧтение(Истина);
			
			Возврат Новый Структура("Том,ПутьКФайлу", СсылкаНаТом, ПутьДня + ИмяФайлаСПутем); 
			
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			
			Если ПодробноеОписаниеВсехОшибок <> "" Тогда
				ПодробноеОписаниеВсехОшибок = ПодробноеОписаниеВсехОшибок + Символы.ПС + Символы.ПС;
				КраткоеОписаниеВсехОшибок   = КраткоеОписаниеВсехОшибок   + Символы.ПС + Символы.ПС;
			КонецЕсли;
			
			ШаблонОписанияОшибки =
				НСтр("ru = 'Ошибка при добавлении файла ""%1""
				           |в том ""%2"" (%3):
				           |""%4"".'");
			
			ПодробноеОписаниеВсехОшибок = ПодробноеОписаниеВсехОшибок
				+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					ШаблонОписанияОшибки,
					ИмяФайла,
					Строка(СсылкаНаТом),
					ПутьКТому,
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
			
			КраткоеОписаниеВсехОшибок = КраткоеОписаниеВсехОшибок
				+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					ШаблонОписанияОшибки,
					ИмяФайла,
					Строка(СсылкаНаТом),
					ПутьКТому,
					КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
			
			// Надо переходить к следующему тому.
			Продолжить;
		КонецПопытки;
		
	КонецЦикла;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	// Запись в журнал регистрации для администратора
	// здесь выдадим ошибки со всех томов.
	ШаблонСообщенияОбОшибке = НСтр("ru = 'Не удалось добавить файл ни в один из томов.
		|Список ошибок:
		|
		|%1'");
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Файлы.Добавление файла'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Ошибка,,,
		СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщенияОбОшибке, ПодробноеОписаниеВсехОшибок));
	
	Если Пользователи.ЭтоПолноправныйПользователь() Тогда
		СтрокаИсключения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщенияОбОшибке, КраткоеОписаниеВсехОшибок);
	Иначе
		// Сообщение обычному пользователю.
		СтрокаИсключения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось добавить файл:
			           |""%1.%2"".
			           |
			           |Обратитесь к администратору.'"),
			ИмяБезРасширения, Расширение);
	КонецЕсли;
	
	ВызватьИсключение СтрокаИсключения;

КонецФункции

// Возвращает количество файлов, хранящихся в томах.
Функция КоличествоФайловВТомах()
	
	КоличествоФайловВТомах = 0;
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииКоличестваФайловВТомах");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриОпределенииКоличестваФайловВТомах(КоличествоФайловВТомах);
	КонецЦикла;
	
	Возврат КоличествоФайловВТомах;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Электронная подпись и шифрование для файлов.

// Управляет видимостью элементов и команд в зависимости от наличия и
// использования электронной подписи и шифрования.
//
Процедура КриптографияПриСозданииФормыНаСервере(Форма, ЭтоФормаСписка = Истина, ТолькоКартинкаСтрок = Ложь) Экспорт
	
	Элементы = Форма.Элементы;
	
	ЭлектронноеПодписание = Ложь;
	Шифрование = Ложь;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяПодпись")
	   И Пользователи.РолиДоступны("ИспользованиеЭлектроннойПодписиИШифрования")
	   И Не ОбщегоНазначенияКлиентСервер.ЭтоВебКлиентПодMacOS() Тогда
		
		МодульЭлектроннаяПодпись = ОбщегоНазначения.ОбщийМодуль("ЭлектроннаяПодпись");
		
		ЭлектронноеПодписание = МодульЭлектроннаяПодпись.ИспользоватьЭлектронныеПодписи();
		Шифрование            = МодульЭлектроннаяПодпись.ИспользоватьШифрование();
	КонецЕсли;
	
	Используется = ЭлектронноеПодписание Или Шифрование;
	
	Если ЭтоФормаСписка Тогда
		Элементы.СписокНомерКартинкиПодписанЗашифрован.Видимость = Используется;
	КонецЕсли;
	
	Если Не ТолькоКартинкаСтрок Тогда
		Элементы.ФормаГруппаКомандЭлектроннаяПодписьИШифрование.Видимость = Используется;
		
		Если ЭтоФормаСписка Тогда
			Элементы.СписокКонтекстноеМенюГруппаКомандЭлектроннаяПодписьИШифрование.Видимость = Используется;
		Иначе
			Элементы.ГруппаЭлектронныеПодписи.Видимость = ЭлектронноеПодписание;
			Элементы.ГруппаСертификатыШифрования.Видимость = Шифрование;
			Элементы.ГруппаДополнительныеДанныеСтраницы.ОтображениеСтраниц =
				?(Используется, ОтображениеСтраницФормы.ЗакладкиСверху, ОтображениеСтраницФормы.Нет);
		КонецЕсли;
	КонецЕсли;
	
	Если Не Используется Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ТолькоКартинкаСтрок Тогда
		Элементы.ФормаГруппаКомандЭлектроннаяПодпись.Видимость = ЭлектронноеПодписание;
		Элементы.ФормаГруппаКомандШифрование.Видимость = Шифрование;
		
		Если ЭтоФормаСписка Тогда
			Элементы.СписокКонтекстноеМенюГруппаКомандЭлектроннаяПодпись.Видимость = ЭлектронноеПодписание;
			Элементы.СписокКонтекстноеМенюГруппаКомандШифрование.Видимость = Шифрование;
		КонецЕсли;
	КонецЕсли;
	
	Если ЭлектронноеПодписание И Шифрование Тогда
		Заголовок = НСтр("ru = 'Электронная подпись и шифрование'");
		Подсказка = НСтр("ru = 'Наличие электронной подписи или шифрования'");
		Картинка  = БиблиотекаКартинок["ПодписанЗашифрованЗаголовок"];
	ИначеЕсли ЭлектронноеПодписание Тогда
		Заголовок = НСтр("ru = 'Электронная подпись'");
		Подсказка = НСтр("ru = 'Наличие электронной подписи'");
		Картинка  = БиблиотекаКартинок["ПодписанЭП"];
	Иначе // Шифрование
		Заголовок = НСтр("ru = 'Шифрование'");
		Подсказка = НСтр("ru = 'Наличие шифрования'");
		Картинка  = БиблиотекаКартинок["Зашифрован"];
	КонецЕсли;
	
	Если ЭтоФормаСписка Тогда
		Элементы.СписокНомерКартинкиПодписанЗашифрован.КартинкаШапки = Картинка;
		Элементы.СписокНомерКартинкиПодписанЗашифрован.Подсказка = Подсказка;
	КонецЕсли;
	
	Если Не ТолькоКартинкаСтрок Тогда
		Элементы.ФормаГруппаКомандЭлектроннаяПодписьИШифрование.Заголовок = Заголовок;
		Элементы.ФормаГруппаКомандЭлектроннаяПодписьИШифрование.Подсказка = Заголовок;
		Элементы.ФормаГруппаКомандЭлектроннаяПодписьИШифрование.Картинка  = Картинка;
		
		Если ЭтоФормаСписка Тогда
			Элементы.СписокКонтекстноеМенюГруппаКомандЭлектроннаяПодписьИШифрование.Заголовок = Заголовок;
			Элементы.СписокКонтекстноеМенюГруппаКомандЭлектроннаяПодписьИШифрование.Подсказка = Заголовок;
			Элементы.СписокКонтекстноеМенюГруппаКомандЭлектроннаяПодписьИШифрование.Картинка  = Картинка;
		КонецЕсли;
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяПодпись") Тогда
		МодульЭлектроннаяПодписьСлужебный = ОбщегоНазначения.ОбщийМодуль("ЭлектроннаяПодписьСлужебный");
		МодульЭлектроннаяПодписьСлужебный.ОформитьСписокПодписей(Форма, "ЭлектронныеПодписи");
	КонецЕсли;
	
КонецПроцедуры

// Только для внутреннего использования.
Процедура ПеренестиРезультатыПроверкиПодписей(ПодписиВФорме, ПодписиВОбъекте) Экспорт
	
	Если ПодписиВФорме.Количество() <> ПодписиВОбъекте.Количество() Тогда
		Возврат; // Если объект был изменен, результаты проверки не переносятся.
	КонецЕсли;
	
	Если ПодписиВФорме.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Свойства = Новый Структура("ДатаПроверкиПодписи, ПодписьВерна", Null, Null);
	ЗаполнитьЗначенияСвойств(Свойства, ПодписиВОбъекте[0]);
	Если Свойства.ДатаПроверкиПодписи = Null
	 Или Свойства.ПодписьВерна = Null Тогда
		Возврат; // Если в объекте нет реквизитов проверки, результаты проверки не переносятся.
	КонецЕсли;
	
	Для Каждого Строка Из ПодписиВФорме Цикл
		СтрокаВОбъекте = ПодписиВОбъекте.Получить(ПодписиВФорме.Индекс(Строка));
		Если Строка.ДатаПодписи         <> СтрокаВОбъекте.ДатаПодписи
		 Или Строка.Комментарий         <> СтрокаВОбъекте.Комментарий
		 Или Строка.КомуВыданСертификат <> СтрокаВОбъекте.КомуВыданСертификат
		 Или Строка.Отпечаток           <> СтрокаВОбъекте.Отпечаток
		 Или Строка.УстановившийПодпись <> СтрокаВОбъекте.УстановившийПодпись Тогда
			Возврат; // Если объект был изменен, результаты проверки не переносятся.
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Строка Из ПодписиВФорме Цикл
		СтрокаВОбъекте = ПодписиВОбъекте.Получить(ПодписиВФорме.Индекс(Строка));
		ЗаполнитьЗначенияСвойств(Свойства, СтрокаВОбъекте);
		Если Строка.ДатаПроверкиПодписи = Свойства.ДатаПроверкиПодписи
		   И Строка.ПодписьВерна        = Свойства.ПодписьВерна Тогда
			Продолжить; // Не нужно устанавливать модифицированность, если результаты проверки совпадают.
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(Свойства, Строка);
		ЗаполнитьЗначенияСвойств(СтрокаВОбъекте, Свойства);
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Прочие функции

// Возвращает Истина, если текст из файлов извлекается на сервере, а не на клиенте.
//
// Возвращаемое значение:
//  Булево. Ложь - если текст не извлекается на сервере,
//                 т.е. может и должен быть извлечен на клиенте.
//
Функция ИзвлекатьТекстыФайловНаСервере() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат Константы.ИзвлекатьТекстыФайловНаСервере.Получить();
	
КонецФункции

// Возвращает Истина, если сервер работает под Windows.
Функция ЭтоПлатформаWindows() Экспорт
	
	ТипПлатформыСервера = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера();
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86
	 ИЛИ ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

// Получает строку из временного хранилища (передача с клиента на сервер,
// делается через временное хранилище).
//
Функция ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста) Экспорт
	
	Если ПустаяСтрока(АдресВременногоХранилищаТекста) Тогда
		Возврат "";
	КонецЕсли;
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
	ПолучитьИзВременногоХранилища(АдресВременногоХранилищаТекста).Записать(ИмяВременногоФайла);
	
	ТекстовыйФайл = Новый ЧтениеТекста(ИмяВременногоФайла, КодировкаТекста.UTF8);
	Текст = ТекстовыйФайл.Прочитать();
	ТекстовыйФайл.Закрыть();
	УдалитьФайлы(ИмяВременногоФайла);
	
	Возврат Текст;
	
КонецФункции

// Служебная функция используется для помещения двоичных данных файла в томе
// в хранилище значения.
//
Функция ПоместитьДвоичныеДанныеВХранилище(Том, ПутьКФайлу, УникальныйИдентификатор) Экспорт
	
	ПолныйПуть = ПолныйПутьТома(Том) + ПутьКФайлу;
	УникальныйИдентификатор = УникальныйИдентификатор;
	
	ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПуть);
	Возврат Новый ХранилищеЗначения(ДвоичныеДанные);
	
КонецФункции

// Служебная функция используется при создании начального образа.
// Выполняется всегда на сервере.
//
Процедура СкопироватьФайлПриСозданииНачальногоОбраза(ПолныйПуть, НовыйПутьФайла) Экспорт
	
	Попытка
		// Если файл в томе - скопируем его во временный каталог (при создании начального образа).
		КопироватьФайл(ПолныйПуть, НовыйПутьФайла);
		ФайлВременный = Новый Файл(НовыйПутьФайла);
		ФайлВременный.УстановитьТолькоЧтение(Ложь);
	Исключение
		// Не регистрируется, возможно файл не найден.
	КонецПопытки;
	
КонецПроцедуры

// Записывает на сервер результат извлечения текста - извлеченный текст и СтатусИзвлеченияТекста.
Процедура ЗаписатьРезультатИзвлеченияТекста(ФайлИлиВерсияСсылка,
                                            РезультатИзвлечения,
                                            АдресВременногоХранилищаТекста) Экспорт
	
	ФайлИлиВерсияОбъект = ФайлИлиВерсияСсылка.ПолучитьОбъект();
	ФайлИлиВерсияОбъект.Заблокировать();
	
	Если ПустаяСтрока(АдресВременногоХранилищаТекста) Тогда
		Текст = "";
	Иначе
		Текст = ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста);
		ФайлИлиВерсияОбъект.ТекстХранилище = Новый ХранилищеЗначения(Текст);
		УдалитьИзВременногоХранилища(АдресВременногоХранилищаТекста);
	КонецЕсли;
	
	Если РезультатИзвлечения = "НеИзвлечен" Тогда
		ФайлИлиВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен;
	ИначеЕсли РезультатИзвлечения = "Извлечен" Тогда
		ФайлИлиВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
	ИначеЕсли РезультатИзвлечения = "ИзвлечьНеУдалось" Тогда
		ФайлИлиВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.ИзвлечьНеУдалось;
	КонецЕсли;
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.ФайловыеФункции\ПриЗаписиИзвлеченногоТекста");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриЗаписиИзвлеченногоТекста(ФайлИлиВерсияОбъект);
	КонецЦикла;
	
КонецПроцедуры

// Получает кодировку текстового файла, указанную пользователем (если есть).
//
// Параметры:
//  ВерсияФайла - ссылка на версию файла.
//
// Возвращаемое значение:
//  Строка - идентификатор кодировки текста или пустая строка.
//
Функция ПолучитьКодировкуВерсииФайла(ВерсияФайла) Экспорт
	
	Кодировка = "";
	ПриОпределенииКодировкиВерсииФайла(ВерсияФайла, Кодировка);
	
	Возврат Кодировка;
	
КонецФункции

Функция СписокРасширенийДляПредпросмотра() Экспорт
	
	// См. также перечисление ФорматКартинки
	РасширенияДляПредпросмотра = Новый СписокЗначений;
	РасширенияДляПредпросмотра.Добавить("bmp");
	РасширенияДляПредпросмотра.Добавить("emf");
	РасширенияДляПредпросмотра.Добавить("gif");
	РасширенияДляПредпросмотра.Добавить("ico");
	РасширенияДляПредпросмотра.Добавить("icon");
	РасширенияДляПредпросмотра.Добавить("jpg");
	РасширенияДляПредпросмотра.Добавить("jpeg");
	РасширенияДляПредпросмотра.Добавить("png");
	РасширенияДляПредпросмотра.Добавить("tiff");
	РасширенияДляПредпросмотра.Добавить("tif");
	РасширенияДляПредпросмотра.Добавить("wmf");
	
	Возврат РасширенияДляПредпросмотра;
	
КонецФункции

Функция СписокЗапрещенныхРасширений() Экспорт
	
	СписокЗапрещенныхРасширений = Новый СписокЗначений;
	СписокЗапрещенныхРасширений.Добавить("ade");
	СписокЗапрещенныхРасширений.Добавить("adp");
	СписокЗапрещенныхРасширений.Добавить("app");
	СписокЗапрещенныхРасширений.Добавить("bas");
	СписокЗапрещенныхРасширений.Добавить("bat");
	СписокЗапрещенныхРасширений.Добавить("chm");
	СписокЗапрещенныхРасширений.Добавить("class");
	СписокЗапрещенныхРасширений.Добавить("cmd");
	СписокЗапрещенныхРасширений.Добавить("com");
	СписокЗапрещенныхРасширений.Добавить("cpl");
	СписокЗапрещенныхРасширений.Добавить("crt");
	СписокЗапрещенныхРасширений.Добавить("dll");
	СписокЗапрещенныхРасширений.Добавить("exe");
	СписокЗапрещенныхРасширений.Добавить("fxp");
	СписокЗапрещенныхРасширений.Добавить("hlp");
	СписокЗапрещенныхРасширений.Добавить("hta");
	СписокЗапрещенныхРасширений.Добавить("ins");
	СписокЗапрещенныхРасширений.Добавить("isp");
	СписокЗапрещенныхРасширений.Добавить("jse");
	СписокЗапрещенныхРасширений.Добавить("js");
	СписокЗапрещенныхРасширений.Добавить("lnk");
	СписокЗапрещенныхРасширений.Добавить("mda");
	СписокЗапрещенныхРасширений.Добавить("mdb");
	СписокЗапрещенныхРасширений.Добавить("mde");
	СписокЗапрещенныхРасширений.Добавить("mdt");
	СписокЗапрещенныхРасширений.Добавить("mdw");
	СписокЗапрещенныхРасширений.Добавить("mdz");
	СписокЗапрещенныхРасширений.Добавить("msc");
	СписокЗапрещенныхРасширений.Добавить("msi");
	СписокЗапрещенныхРасширений.Добавить("msp");
	СписокЗапрещенныхРасширений.Добавить("mst");
	СписокЗапрещенныхРасширений.Добавить("ops");
	СписокЗапрещенныхРасширений.Добавить("pcd");
	СписокЗапрещенныхРасширений.Добавить("pif");
	СписокЗапрещенныхРасширений.Добавить("prf");
	СписокЗапрещенныхРасширений.Добавить("prg");
	СписокЗапрещенныхРасширений.Добавить("reg");
	СписокЗапрещенныхРасширений.Добавить("scf");
	СписокЗапрещенныхРасширений.Добавить("scr");
	СписокЗапрещенныхРасширений.Добавить("sct");
	СписокЗапрещенныхРасширений.Добавить("shb");
	СписокЗапрещенныхРасширений.Добавить("shs");
	СписокЗапрещенныхРасширений.Добавить("url");
	СписокЗапрещенныхРасширений.Добавить("vb");
	СписокЗапрещенныхРасширений.Добавить("vbe");
	СписокЗапрещенныхРасширений.Добавить("vbs");
	СписокЗапрещенныхРасширений.Добавить("wsc");
	СписокЗапрещенныхРасширений.Добавить("wsf");
	СписокЗапрещенныхРасширений.Добавить("wsh");
	
	Возврат СписокЗапрещенныхРасширений;
	
КонецФункции

Функция ПодготовитьСтруктуруПараметровОтправки() Экспорт
	
	Возврат Новый Структура("Получатель,Тема,Текст", Неопределено, "", "");
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Синхронизация файлов

Функция ФайлРедактируетсяВОблаке(Файл) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.Файл
		|ИЗ
		|	РегистрСведений.СтатусыСинхронизацииФайловСОблачнымСервисом КАК СтатусыСинхронизацииФайловСОблачнымСервисом
		|ГДЕ
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.Файл = &Файл";
	
	Запрос.УстановитьПараметр("Файл", Файл);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		Возврат Истина;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в эту подсистему.

// См. описание одноименной процедуры в общем модуле РегламентныеЗаданияПереопределяемый.
//
Процедура ПриОпределенииНастроекРегламентныхЗаданий(Зависимости) Экспорт
	Зависимость = Зависимости.Добавить();
	Зависимость.РегламентноеЗадание = Метаданные.РегламентныеЗадания.ИзвлечениеТекста;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПолнотекстовыйПоиск") Тогда
		МодульПолнотекстовыйПоискСервер = ОбщегоНазначения.ОбщийМодуль("ПолнотекстовыйПоискСервер");
		Зависимость.ФункциональнаяОпция = МодульПолнотекстовыйПоискСервер.ИспользоватьПолнотекстовыйПоиск();
	КонецЕсли;
	Зависимость.ДоступноВМоделиСервиса = Ложь;
	
	Зависимость = Зависимости.Добавить();
	Зависимость.РегламентноеЗадание = Метаданные.РегламентныеЗадания.ОчисткаНенужныхФайлов;
	Зависимость.РаботаетСВнешнимиРесурсами = Истина;
	
	Зависимость = Зависимости.Добавить();
	Зависимость.РегламентноеЗадание = Метаданные.РегламентныеЗадания.СинхронизацияФайлов;
	Зависимость.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.ИспользоватьСинхронизациюФайлов;
	Зависимость.РаботаетСВнешнимиРесурсами = Истина;
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Синхронизация файлов с облачным сервисом
Процедура ДобавитьДоступныеПоляОтбора(ТекстЗапроса, ТипОбъекта) Экспорт
	
	ВсеСправочники = Справочники.ТипВсеСсылки();
	ВсеДокументы = Документы.ТипВсеСсылки();
	
	Если ВсеСправочники.СодержитТип(ТипЗнч(ТипОбъекта.ЗначениеПустойСсылки)) Тогда
		Справочник = Метаданные.Справочники[ТипОбъекта.Имя];
		Для Каждого Реквизит Из Справочник.Реквизиты Цикл
			ТекстЗапроса = ТекстЗапроса + Символы.ПС + "СправочникПапок." + Реквизит.Имя + " КАК " + Реквизит.Имя +",";
		КонецЦикла;
	ИначеЕсли ВсеДокументы.СодержитТип(ТипЗнч(ТипОбъекта.ЗначениеПустойСсылки)) Тогда
		Документ = Метаданные.Документы[ТипОбъекта.Имя];
		Для Каждого Реквизит Из Документ.Реквизиты Цикл
			Если Реквизит.Тип = Новый ОписаниеТипов("Дата") Тогда
				ТекстЗапроса = ТекстЗапроса + Символы.ПС + "РАЗНОСТЬДАТ(" + Реквизит.Имя + ", &ТекущаяДата, ДЕНЬ) Как ДнейДоУдаленияОт" + Реквизит.Имя + ",";
			КонецЕсли;
			ТекстЗапроса = ТекстЗапроса + Символы.ПС + "СправочникПапок." + Реквизит.Имя + ",";
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры
#КонецОбласти

#Область СлужебныеПроцедурыИФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики служебных событий подсистем БСП.

// Добавляет процедуры-обработчики обновления, необходимые данной подсистеме.
//
// Параметры:
//  Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
//                                  общего модуля ОбновлениеИнформационнойБазы.
// 
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.1.6";
	Обработчик.Процедура = "ФайловыеФункцииСлужебный.ПеренестиКонстантыРасширений";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.3.2.70";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.НачальноеЗаполнение = Истина;
	Обработчик.Процедура = "ФайловыеФункцииСлужебный.ОбновитьСписокЗапрещенныхРасширений";
	Обработчик.РежимВыполнения = "Оперативно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.3.2.70";
	Обработчик.НачальноеЗаполнение = Истина;
	Обработчик.Процедура = "ФайловыеФункцииСлужебный.ОбновитьСписокЗапрещенныхРасширенийВОбластиДанных";
	Обработчик.РежимВыполнения = "Оперативно";

КонецПроцедуры

// Заполняет структуру параметров, необходимых для работы клиентского кода
// конфигурации.
//
// Параметры:
//   Параметры   - Структура - структура параметров.
//
Процедура ПриДобавленииПараметровРаботыКлиента(Параметры) Экспорт
	
	Если Не ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	НастройкиРаботыСФайлами = ФайловыеФункцииСлужебныйПовтИсп.НастройкиРаботыСФайлами();
	
	Параметры.Вставить("ПерсональныеНастройкиРаботыСФайлами", Новый ФиксированнаяСтруктура(
		НастройкиРаботыСФайлами.ПерсональныеНастройки));
	
	Параметры.Вставить("ОбщиеНастройкиРаботыСФайлами", Новый ФиксированнаяСтруктура(
		НастройкиРаботыСФайлами.ОбщиеНастройки));
	
КонецПроцедуры

// Заполняет перечень запросов внешних разрешений, которые обязательно должны быть предоставлены
// при создании информационной базы или обновлении программы.
//
// Параметры:
//  ЗапросыРазрешений - Массив - список значений, возвращенных функцией.
//                      РаботаВБезопасномРежиме.ЗапросНаИспользованиеВнешнихРесурсов().
//
Процедура ПриЗаполненииРазрешенийНаДоступКВнешнимРесурсам(ЗапросыРазрешений) Экспорт
	
	Если ПолучитьФункциональнуюОпцию("ХранитьФайлыВТомахНаДиске") Тогда
		Справочники.ТомаХраненияФайлов.ДобавитьЗапросыНаИспользованиеВнешнихРесурсовВсехТомов(ЗапросыРазрешений);
	КонецЕсли;
	
КонецПроцедуры

// Заполняет массив типов неразделенных данных, для которых не требуется сопоставление ссылок
// при загрузке данных в другую информационную базу, т.к. корректное сопоставление ссылок
// гарантируется с помощью других механизмов.
//
// Параметры:
//  Типы - Массив(ОбъектМетаданных).
//
Процедура ПриЗаполненииТиповОбщихДанныхНеТребующихСопоставлениеСсылокПриЗагрузке(Типы) Экспорт
	
	// В процессе выгрузки данных ссылки на справочник ТомаХраненияФайлов очищаются,
	// а при загрузке загрузка производится относительно настройки томов в ИБ, в которую
	// производится загрузка, а не относительно настройки томов в ИБ, из которой были
	// выгружены данные.
	Типы.Добавить(Метаданные.Справочники.ТомаХраненияФайлов);
	
КонецПроцедуры

// Содержит настройки размещения вариантов отчетов в панели отчетов.
//
// Параметры:
//   Настройки - Коллекция - Содержит настройки всех отчетов и вариантов конфигурации.
//       Используется для передачи в параметрах вспомогательных методов.
//
// Описание:
//   См. ВариантыОтчетовПереопределяемый.НастроитьВариантыОтчетов().
//
// Вспомогательные методы:
//   1. Функции ОписаниеОтчета и ОписаниеВарианта формируют описание настроек отчета и варианта для последующего изменения:
//       НастройкиОтчета   = ВариантыОтчетов.ОписаниеОтчета(Настройки, Метаданные.Отчеты.<ИмяОтчета>);
//       НастройкиВарианта = ВариантыОтчетов.ОписаниеВарианта(Настройки, НастройкиОтчета, "<ИмяВарианта>");
//       Возвращаемые коллекции содержат одинаковый набор свойств.
//       НастройкиОтчета используются как умолчания для вариантов, описания которых еще не получены.
//       Подробнее - см. "свойства для изменения" в комментарии к ВариантыОтчетовПереопределяемый.НастроитьВариантыОтчетов().
//   2. Процедура УстановитьРежимВыводаВПанеляхОтчетов позволяет настроить режим группировки вариантов в панелях отчетов:
//       ВариантыОтчетов.УстановитьРежимВыводаВПанеляхОтчетов(Настройки, НастройкиОтчета, Истина/Ложь);
//       ВариантыОтчетов.УстановитьРежимВыводаВПанеляхОтчетов(Настройки, Метаданные.Отчеты.<ИмяОтчета>, Истина/Ложь);
//       ВариантыОтчетов.УстановитьРежимВыводаВПанеляхОтчетов(Настройки, Метаданные.Подсистемы.<ИмяПодсистемы>, Истина/Ложь);
//   3. Процедура НастроитьОтчетВМодулеМенеджера позволяет переопределять настройки отчета в его модуле менеджера:
//       ВариантыОтчетов.НастроитьОтчетВМодулеМенеджера(Настройки, Метаданные.Отчеты.<ИмяОтчета>);
//
Процедура ПриНастройкеВариантовОтчетов(Настройки) Экспорт
	МодульВариантыОтчетов = ОбщегоНазначения.ОбщийМодуль("ВариантыОтчетов");
	МодульВариантыОтчетов.НастроитьОтчетВМодулеМенеджера(Настройки, Метаданные.Отчеты.ОбъемНенужныхФайлов);
	МодульВариантыОтчетов.НастроитьОтчетВМодулеМенеджера(Настройки, Метаданные.Отчеты.ПроверкаЦелостностиТома);
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обмен файлами

// Подготовка параметров и предварительные проверки перед созданием файлового начального образа.
//
Функция ПодготовитьДанныеДляСозданияФайловогоНачальногоОбраза(СтруктураПараметров) Экспорт
	
	Результат = Новый Структура("ДанныеПодготовлены, ТребуетсяПодтверждение, ТекстВопроса", Истина, Ложь, "");
	
	Узел 							= СтруктураПараметров.Узел;
	УникальныйИдентификаторФормы 	= СтруктураПараметров.УникальныйИдентификаторФормы;
	Язык 							= СтруктураПараметров.Язык;
	ПолноеИмяФайловойБазыWindows 	= СтруктураПараметров.ПолноеИмяФайловойБазыWindows;
	ПолноеИмяФайловойБазыLinux 		= СтруктураПараметров.ПолноеИмяФайловойБазыLinux;
	ПутьКАрхивуСФайламиТомовWindows = СтруктураПараметров.ПутьКАрхивуСФайламиТомовWindows;
	ПутьКАрхивуСФайламиТомовLinux 	= СтруктураПараметров.ПутьКАрхивуСФайламиТомовLinux;
	
	ПутьКАрхивуСФайламиТомов = "";
	ПолноеИмяФайловойБазы = "";
	
	ЕстьФайлыВТомах = Ложь;
	
	Если ФайловыеФункции.ЕстьТомаХраненияФайлов() Тогда
		ЕстьФайлыВТомах = ЕстьФайлыВТомах();
	КонецЕсли;
	
	ТипПлатформыСервера = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера();
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86 ИЛИ ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		
		ПутьКАрхивуСФайламиТомов = ПутьКАрхивуСФайламиТомовWindows;
		ПолноеИмяФайловойБазы = ПолноеИмяФайловойБазыWindows;
		
		ПараметрыРаботыКлиента = СтандартныеПодсистемыВызовСервера.ПараметрыРаботыКлиента();
		Если НЕ ПараметрыРаботыКлиента.ИнформационнаяБазаФайловая Тогда
			Если ЕстьФайлыВТомах И Не ПустаяСтрока(ПутьКАрхивуСФайламиТомов) И (Лев(ПутьКАрхивуСФайламиТомов, 2) <> "\\"
				ИЛИ СтрНайти(ПутьКАрхивуСФайламиТомов, ":") <> 0) Тогда
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					НСтр("ru = 'Путь к архиву с файлами томов должен быть
					           |в формате UNC (\\servername\resource)'"),
					,
					"ПутьКАрхивуСФайламиТомовWindows");
				Результат.ДанныеПодготовлены = Ложь;
			КонецЕсли;
			Если Не ПустаяСтрока(ПолноеИмяФайловойБазы) И (Лев(ПолноеИмяФайловойБазы, 2) <> "\\" ИЛИ СтрНайти(ПолноеИмяФайловойБазы, ":") <> 0) Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					НСтр("ru = 'Путь к файловой базе должен быть
					           |в формате UNC (\\servername\resource)'"),
					,
					"ПолноеИмяФайловойБазыWindows");
				Результат.ДанныеПодготовлены = Ложь;
			КонецЕсли;
		КонецЕсли;
	Иначе
		ПутьКАрхивуСФайламиТомов = ПутьКАрхивуСФайламиТомовLinux;
		ПолноеИмяФайловойБазы = ПолноеИмяФайловойБазыLinux;
	КонецЕсли;
	
	Если ПустаяСтрока(ПолноеИмяФайловойБазы) Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
			НСтр("ru = 'Укажите полное имя файловой базы (файл 1cv8.1cd)'"),,
			"ПолноеИмяФайловойБазыWindows");
		Результат.ДанныеПодготовлены = Ложь;
	ИначеЕсли Результат.ДанныеПодготовлены Тогда
		ФайлБазы = Новый Файл(ПолноеИмяФайловойБазы);
		
		Если ЕстьФайлыВТомах Тогда
			Если ПустаяСтрока(ПутьКАрхивуСФайламиТомов) Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					НСтр("ru = 'Укажите полное имя архива с файлами томов (файл *.zip)'"),, 
					"ПутьКАрхивуСФайламиТомовWindows");
				Результат.ДанныеПодготовлены = Ложь;
			Иначе
				Файл = Новый Файл(ПутьКАрхивуСФайламиТомов);
				
				Если Файл.Существует() И ФайлБазы.Существует() Тогда
					Результат.ТекстВопроса = СтрШаблон(НСтр("ru = 'Файлы ""%1"" и ""%2"" уже существуют.
							           |Заменить существующие файлы?'"), ПутьКАрхивуСФайламиТомов, ПолноеИмяФайловойБазы);
					Результат.ТребуетсяПодтверждение = Истина;
				ИначеЕсли Файл.Существует() Тогда
					Результат.ТекстВопроса = СтрШаблон(НСтр("ru = 'Файл ""%1"" уже существует.
							           |Заменить существующий файл?'"), ПутьКАрхивуСФайламиТомов);
					Результат.ТребуетсяПодтверждение = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Если Результат.ДанныеПодготовлены Тогда
			Если ФайлБазы.Существует() И НЕ Результат.ТребуетсяПодтверждение Тогда
				Результат.ТекстВопроса = СтрШаблон(НСтр("ru = 'Файл ""%1"" уже существует.
						           |Заменить существующий файл?'"), ПолноеИмяФайловойБазы);
				Результат.ТребуетсяПодтверждение = Истина;
			КонецЕсли;
			
			// Создать временный каталог.
			ИмяКаталога = ПолучитьИмяВременногоФайла();
			СоздатьКаталог(ИмяКаталога);
			
			// Создать временный каталог для файлов.
			ИмяКаталогаФайлов = ПолучитьИмяВременногоФайла();
			СоздатьКаталог(ИмяКаталогаФайлов);
			
			// Для передачи пути каталога файлов в обработчик ПриОтправкеДанныхФайла.
			СохранитьНастройку("ОбменФайлами", "ВременныйКаталог", ИмяКаталогаФайлов);
			
			// Добавляем в параметры переменные, которые потребуются для создания начального образа.
			СтруктураПараметров.Вставить("ИмяКаталога", ИмяКаталога);
			СтруктураПараметров.Вставить("ИмяКаталогаФайлов", ИмяКаталогаФайлов);
			СтруктураПараметров.Вставить("ЕстьФайлыВТомах", ЕстьФайлыВТомах);
			СтруктураПараметров.Вставить("ПутьКАрхивуСФайламиТомов", ПутьКАрхивуСФайламиТомов);
			СтруктураПараметров.Вставить("ПолноеИмяФайловойБазы", ПолноеИмяФайловойБазы);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Создать файловый начальный образ на сервере. . Запускается регламентным заданием.
//
Процедура СоздатьФайловыйНачальныйОбразНаСервере(СтруктураПараметров, АдресХранилища) Экспорт
	
	Узел 						= СтруктураПараметров.Узел;
	Язык 						= СтруктураПараметров.Язык;
	ИмяКаталога 				= СтруктураПараметров.ИмяКаталога;
	ИмяКаталогаФайлов 			= СтруктураПараметров.ИмяКаталогаФайлов;
	ЕстьФайлыВТомах 			= СтруктураПараметров.ЕстьФайлыВТомах;
	ПутьКАрхивуСФайламиТомов 	= СтруктураПараметров.ПутьКАрхивуСФайламиТомов;
	ПолноеИмяФайловойБазы 		= СтруктураПараметров.ПолноеИмяФайловойБазы;
	ПоместитьВоВременноеХранилище(СтруктураПараметров, АдресХранилища);
	
	ZIP = Неопределено;
	Запись = Неопределено;
	
	Попытка
		
		СтрокаСоединения = "File=""" + ИмяКаталога + """;"
						 + "Locale=""" + Язык + """;";
		ПланыОбмена.СоздатьНачальныйОбраз(Узел, СтрокаСоединения);  // Собственно создание начального образа.
		
		Если ЕстьФайлыВТомах Тогда
			ZIP = Новый ЗаписьZipФайла;
			ZIP.Открыть(ПутьКАрхивуСФайламиТомов);
			
			ВременныеФайлы = Новый Массив;
			ВременныеФайлы = НайтиФайлы(ИмяКаталогаФайлов, "*.*");
			
			Для Каждого ВременныйФайл Из ВременныеФайлы Цикл
				Если ВременныйФайл.ЭтоФайл() Тогда
					ПутьВременногоФайла = ВременныйФайл.ПолноеИмя;
					ZIP.Добавить(ПутьВременногоФайла);
				КонецЕсли;
			КонецЦикла;
			
			ZIP.Записать();
			
			УдалитьФайлы(ИмяКаталогаФайлов); // Удаляем вместе с файлами внутри.
		КонецЕсли;
		
	Исключение
		
		УдалитьФайлы(ИмяКаталога);
		ВызватьИсключение;
		
	КонецПопытки;
	
	ПутьВременногоФайлаБазы = ИмяКаталога + "\1Cv8.1CD";
	ПереместитьФайл(ПутьВременногоФайлаБазы, ПолноеИмяФайловойБазы);
	
	// очистка
	УдалитьФайлы(ИмяКаталога);
	
КонецПроцедуры

// Подготовка параметров и предварительные проверки перед созданием серверного начального образа.
//
Функция ПодготовитьДанныеДляСозданияСерверногоНачальногоОбраза(СтруктураПараметров) Экспорт
	
	Результат = Новый Структура("ДанныеПодготовлены, ТребуетсяПодтверждение, ТекстВопроса", Истина, Ложь, "");
	
	Узел 							= СтруктураПараметров.Узел;
	СтрокаСоединения 				= СтруктураПараметров.СтрокаСоединения;
	ПутьКАрхивуСФайламиТомовWindows = СтруктураПараметров.ПутьКАрхивуСФайламиТомовWindows;
	ПутьКАрхивуСФайламиТомовLinux 	= СтруктураПараметров.ПутьКАрхивуСФайламиТомовLinux;
	
	ПутьКАрхивуСФайламиТомов = "";
	ПолноеИмяФайловойБазы = "";
	
	ЕстьФайлыВТомах = Ложь;
	
	Если ФайловыеФункции.ЕстьТомаХраненияФайлов() Тогда
		ЕстьФайлыВТомах = ЕстьФайлыВТомах();
	КонецЕсли;
	
	ТипПлатформыСервера = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера();
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86 ИЛИ ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		
		ПутьКАрхивуСФайламиТомов = ПутьКАрхивуСФайламиТомовWindows;
		
		Если ЕстьФайлыВТомах Тогда
			Если Не ПустаяСтрока(ПутьКАрхивуСФайламиТомов)
			   И (Лев(ПутьКАрхивуСФайламиТомов, 2) <> "\\"
			 ИЛИ СтрНайти(ПутьКАрхивуСФайламиТомов, ":") <> 0) Тогда
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					НСтр("ru = 'Путь к архиву с файлами томов должен быть
					           |в формате UNC (\\servername\resource).'"),
					,
					"ПутьКАрхивуСФайламиТомовWindows");
				Результат.ДанныеПодготовлены = Ложь;
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		ПутьКАрхивуСФайламиТомов = ПутьКАрхивуСФайламиТомовLinux;
	КонецЕсли;
	
	Если Результат.ДанныеПодготовлены Тогда
		Если ЕстьФайлыВТомах И ПустаяСтрока(ПутьКАрхивуСФайламиТомов) Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					НСтр("ru = 'Укажите полное имя архива с файлами томов (файл *.zip)'"),
					,
					"ПутьКАрхивуСФайламиТомовWindows");
				Результат.ДанныеПодготовлены = Ложь;
		Иначе
			Если ЕстьФайлыВТомах Тогда
				Файл = Новый Файл(ПутьКАрхивуСФайламиТомов);
				Если Файл.Существует() Тогда
					Результат.ТекстВопроса = СтрШаблон(НСтр("ru = 'Файл ""%1"" уже существует.
							           |Заменить существующий файл?'"), ПутьКАрхивуСФайламиТомов);
					Результат.ТребуетсяПодтверждение = Истина;
				КонецЕсли;
			КонецЕсли;
			
			// Создать временный каталог.
			ИмяКаталога = ПолучитьИмяВременногоФайла();
			СоздатьКаталог(ИмяКаталога);
			
			// Создать временный каталог для файлов.
			ИмяКаталогаФайлов = ПолучитьИмяВременногоФайла();
			СоздатьКаталог(ИмяКаталогаФайлов);
			
			// Для передачи пути каталога файлов в обработчик ПриОтправкеДанныхФайла.
			СохранитьНастройку("ОбменФайлами", "ВременныйКаталог", ИмяКаталогаФайлов);
			
			// Добавляем в параметры переменные, которые потребуются для создания начального образа.
			СтруктураПараметров.Вставить("ЕстьФайлыВТомах", ЕстьФайлыВТомах);
			СтруктураПараметров.Вставить("ПутьФайла", ПутьКАрхивуСФайламиТомов);
			СтруктураПараметров.Вставить("ИмяКаталога", ИмяКаталога);
			СтруктураПараметров.Вставить("ИмяКаталогаФайлов", ИмяКаталогаФайлов);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Создать серверный начальный образ на сервере. Запускается регламентным заданием.
//
Процедура СоздатьСерверныйНачальныйОбразНаСервере(СтруктураПараметров, АдресХранилища) Экспорт
	Узел 				= СтруктураПараметров.Узел;
	СтрокаСоединения 	= СтруктураПараметров.СтрокаСоединения;
	ЕстьФайлыВТомах 	= СтруктураПараметров.ЕстьФайлыВТомах;
	ПутьФайла 			= СтруктураПараметров.ПутьФайла;
	ИмяКаталога 		= СтруктураПараметров.ИмяКаталога;
	ИмяКаталогаФайлов 	= СтруктураПараметров.ИмяКаталогаФайлов;
	ПоместитьВоВременноеХранилище(СтруктураПараметров, АдресХранилища);
	
	ZIP = Неопределено;
	Запись = Неопределено;
	
	Попытка
		
		ПланыОбмена.СоздатьНачальныйОбраз(Узел, СтрокаСоединения);
		
		Если ЕстьФайлыВТомах Тогда
			ZIP = Новый ЗаписьZipФайла;
			ПутьZIP = ПутьФайла;
			ZIP.Открыть(ПутьZIP);
			
			ВременныеФайлы = Новый Массив;
			ВременныеФайлы = НайтиФайлы(ИмяКаталогаФайлов, "*.*");
			
			Для Каждого ВременныйФайл Из ВременныеФайлы Цикл
				Если ВременныйФайл.ЭтоФайл() Тогда
					ПутьВременногоФайла = ВременныйФайл.ПолноеИмя;
					ZIP.Добавить(ПутьВременногоФайла);
				КонецЕсли;
			КонецЦикла;
			
			ZIP.Записать();
			УдалитьФайлы(ИмяКаталогаФайлов); // Удаляем вместе с файлами внутри.
		КонецЕсли;
		
	Исключение
		
		УдалитьФайлы(ИмяКаталога);
		ВызватьИсключение;
		
	КонецПопытки;
	
	// очистка
	УдалитьФайлы(ИмяКаталога);
	
КонецПроцедуры

// Размещает файлы в томах, устанавливая ссылки в ВерсииФайла.
//
Функция ДобавитьФайлыВТома(ПутьКАрхивуWindows, ПутьКАрхивуLinux) Экспорт
	
	ПолноеИмяФайлаZip = "";
	ТипПлатформыСервера = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера();
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86 ИЛИ ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		ПолноеИмяФайлаZip = ПутьКАрхивуWindows;
	Иначе
		ПолноеИмяФайлаZip = ПутьКАрхивуLinux;
	КонецЕсли;
	
	ИмяКаталога = ПолучитьИмяВременногоФайла();
	СоздатьКаталог(ИмяКаталога);
	
	ZIP = Новый ЧтениеZipФайла(ПолноеИмяФайлаZip);
	ZIP.ИзвлечьВсе(ИмяКаталога, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	
	СоответствиеПутейФайлов = Новый Соответствие;
	
	Для Каждого ZIPЭлемент Из ZIP.Элементы Цикл
		ПолныйПутьФайла = ИмяКаталога + "\" + ZIPЭлемент.Имя;
		УникальныйИдентификатор = ZIPЭлемент.ИмяБезРасширения;
		
		СоответствиеПутейФайлов.Вставить(УникальныйИдентификатор, ПолныйПутьФайла);
	КонецЦикла;
	
	ТипХраненияФайлов = ТипХраненияФайлов();
	ПрисоединяемыеФайлы = Новый Массив;
	НачатьТранзакцию();
	Попытка
		
		ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
			"СтандартныеПодсистемы.ФайловыеФункции\ПриДобавленииФайловВТомаПриРазмещении");
		
		Для каждого Обработчик Из ОбработчикиСобытия Цикл
			Обработчик.Модуль.ПриДобавленииФайловВТомаПриРазмещении(
				СоответствиеПутейФайлов, ТипХраненияФайлов, ПрисоединяемыеФайлы);
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
		
	// Очистим регистрацию изменений, которые мы только что сделали.
	Для Каждого ПланОбмена Из Метаданные.ПланыОбмена Цикл
		ИмяПланаОбмена      = ПланОбмена.Имя;
		МенеджерПланаОбмена = ПланыОбмена[ИмяПланаОбмена];
		
		ЭтотУзел = МенеджерПланаОбмена.ЭтотУзел();
		Выборка = МенеджерПланаОбмена.Выбрать();
		
		Пока Выборка.Следующий() Цикл
			
			ПланОбменаОбъект = Выборка.ПолучитьОбъект();
			Если ПланОбменаОбъект.Ссылка <> ЭтотУзел Тогда
				
				ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
					"СтандартныеПодсистемы.ФайловыеФункции\ПриУдаленииРегистрацииИзменений");
				
				Для каждого Обработчик Из ОбработчикиСобытия Цикл
					Обработчик.Модуль.ПриУдаленииРегистрацииИзменений(
						ПланОбменаОбъект.Ссылка, ПрисоединяемыеФайлы);
				КонецЦикла;
				
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
КонецФункции

// Для передачи пути каталога файлов в обработчик ПриОтправкеДанныхФайла.
//
Процедура СохранитьНастройку(КлючОбъекта, КлючНастроек, Настройки) 
		
	УстановитьПривилегированныйРежим(Истина);
	ХранилищеОбщихНастроек.Сохранить(КлючОбъекта, КлючНастроек, Настройки);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики регламентных заданий.

// Обработчик регламентного задания ИзвлечениеТекста.
// Извлекает текст из файлов на диске.
//
Процедура ИзвлечьТекстИзФайловНаСервере() Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.ИзвлечениеТекста);
	
	ИзвлечьТекстИзФайлов();
	
КонецПроцедуры

Процедура ИзвлечьТекстИзФайлов() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТипПлатформыСервера = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера();
	
	Если НЕ ЭтоПлатформаWindows() Тогда
		Возврат; // Извлечение текста работает только под Windows.
	КонецЕсли;
	
	ИмяСРасширениемФайла = "";
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Файлы.Извлечение текста'",
		     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Информация,
		,
		,
		НСтр("ru = 'Начато регламентное извлечения текста'"));
		
	ИтоговыйТекстЗапроса = "";
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииТекстаЗапросаДляИзвлеченияТекста");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		ТекущийТекстЗапроса = "";
		Обработчик.Модуль.ПриОпределенииТекстаЗапросаДляИзвлеченияТекста(ТекущийТекстЗапроса);
		Если НЕ ПустаяСтрока(ТекущийТекстЗапроса) Тогда
			Если ПустаяСтрока(ИтоговыйТекстЗапроса) Тогда
				ИтоговыйТекстЗапроса = ТекущийТекстЗапроса;
			Иначе
				ИтоговыйТекстЗапроса = ИтоговыйТекстЗапроса + "
					|
					|ОБЪЕДИНИТЬ ВСЕ
					|
					|" + ТекущийТекстЗапроса;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ПустаяСтрока(ИтоговыйТекстЗапроса) Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос(ИтоговыйТекстЗапроса);
	Результат = Запрос.Выполнить();
	
	ТаблицаВыгрузки = Результат.Выгрузить();
	
	Для Каждого Строка Из ТаблицаВыгрузки Цикл
		
		ФайлОбъект = Строка.Ссылка.ПолучитьОбъект();
		Попытка
			ФайлОбъект.Заблокировать();
		Исключение
			// Заблокированные файлы будут обработаны в следующий раз.
			Продолжить;
		КонецПопытки;
		
		ИмяСРасширениемФайла = ФайлОбъект.Наименование + "." + ФайлОбъект.Расширение;
		ИмяФайлаСПутем = "";
		
		ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
			"СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииИмениФайлаСПутемКДвоичнымДанным");
		
		Для каждого Обработчик Из ОбработчикиСобытия Цикл
			Обработчик.Модуль.ПриОпределенииИмениФайлаСПутемКДвоичнымДанным(
				ФайлОбъект.Ссылка, ИмяФайлаСПутем, Истина);
		КонецЦикла;
		
		Кодировка = ПолучитьКодировкуВерсииФайла(Строка.Ссылка);
		
		Отказ = Ложь;
		Если ПустаяСтрока(ИмяФайлаСПутем) Тогда
			Отказ = Истина;
			Текст = "";
		Иначе
			Текст = ФайловыеФункцииСлужебныйКлиентСервер.ИзвлечьТекст(ИмяФайлаСПутем, Отказ, Кодировка);
		КонецЕсли;
		
		Если Отказ = Ложь Тогда
			ФайлОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
		Иначе
			// Если текст некому извлечь это не ошибка, а нормальный случай.
			ФайлОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.ИзвлечьНеУдалось;
		КонецЕсли;
			
		Если Строка.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе
		   И Не ПустаяСтрока(ИмяФайлаСПутем) Тогда
			
			УдалитьФайлы(ИмяФайлаСПутем);
		КонецЕсли;
		
		ФайлОбъект.ТекстХранилище = Новый ХранилищеЗначения(Текст, Новый СжатиеДанных);
		
		Попытка
			ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
				"СтандартныеПодсистемы.ФайловыеФункции\ПриЗаписиИзвлеченногоТекста");
			
			Для каждого Обработчик Из ОбработчикиСобытия Цикл
				Обработчик.Модуль.ПриЗаписиИзвлеченногоТекста(ФайлОбъект);
			КонецЦикла;
		Исключение
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Файлы.Извлечение текста'",
				     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,
				,
				,
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Во время регламентного извлечения текста из файла
					           |""%1""
					           |произошла ошибка:
					           |""%2"".'"),
					ИмяСРасширениемФайла,
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()) ));
		КонецПопытки;
		
	КонецЦикла;
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Файлы.Извлечение текста'",
		     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Информация,
		,
		,
		НСтр("ru = 'Закончено регламентное извлечение текста'"));
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обновление информационной базы.

// Перенести константы СписокЗапрещенныхРасширений и СписокРасширенийФайловOpenDocument.
Процедура ПеренестиКонстантыРасширений() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		
		СписокЗапрещенныхРасширений = Константы.СписокЗапрещенныхРасширений.Получить();
		Константы.СписокЗапрещенныхРасширенийОбластиДанных.Установить(СписокЗапрещенныхРасширений);
		
		СписокРасширенийФайловOpenDocument = Константы.СписокРасширенийФайловOpenDocument.Получить();
		Константы.СписокРасширенийФайловOpenDocumentОбластиДанных.Установить(СписокРасширенийФайловOpenDocument);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбновитьСписокЗапрещенныхРасширений() Экспорт
	
	СписокЗапрещенныхРасширенийДляЗагрузки = СписокЗапрещенныхРасширений();
	
	СписокЗапрещенныхРасширенийВБазе = Константы.СписокЗапрещенныхРасширений.Получить();
	МассивЗапрещенныхРасширений = СтрРазделить(СписокЗапрещенныхРасширенийВБазе, " ");
	ОбновитьСписокЗапрещенныхРасширений = Ложь;
	Для Каждого Расширение Из СписокЗапрещенныхРасширенийДляЗагрузки Цикл
		Если МассивЗапрещенныхРасширений.Найти(ВРег(Расширение)) = Неопределено Тогда
			ОбновитьСписокЗапрещенныхРасширений = Истина;
			МассивЗапрещенныхРасширений.Добавить(ВРег(Расширение));
		КонецЕсли;
	КонецЦикла;
	СписокЗапрещенныхРасширенийВБазе = СтрСоединить(МассивЗапрещенныхРасширений, " ");
	Если ОбновитьСписокЗапрещенныхРасширений Тогда
		Константы.СписокЗапрещенныхРасширений.Установить(СписокЗапрещенныхРасширенийВБазе);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбновитьСписокЗапрещенныхРасширенийВОбластиДанных() Экспорт
	
	СписокЗапрещенныхРасширенийДляЗагрузки = СписокЗапрещенныхРасширений();
	
	ОбновитьСписокЗапрещенныхРасширенийОбластиДанных = Ложь;
	СписокЗапрещенныхРасширенийОбластиДанных = Константы.СписокЗапрещенныхРасширенийОбластиДанных.Получить();
	МассивЗапрещенныхРасширенийОбластиДанных = СтрРазделить(СписокЗапрещенныхРасширенийОбластиДанных, " ");
	Для Каждого Расширение Из СписокЗапрещенныхРасширенийДляЗагрузки Цикл
		Если МассивЗапрещенныхРасширенийОбластиДанных.Найти(ВРег(Расширение)) = Неопределено Тогда
			МассивЗапрещенныхРасширенийОбластиДанных.Добавить(ВРег(Расширение));
			ОбновитьСписокЗапрещенныхРасширенийОбластиДанных = Истина;
		КонецЕсли;
	КонецЦикла;
	СписокЗапрещенныхРасширенийОбластиДанных = СтрСоединить(МассивЗапрещенныхРасширенийОбластиДанных, " ");
	Если ОбновитьСписокЗапрещенныхРасширенийОбластиДанных Тогда
		Константы.СписокЗапрещенныхРасширенийОбластиДанных.Установить(СписокЗапрещенныхРасширенийОбластиДанных);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в другие подсистемы.

// Дополняет структуру, содержащую общие и персональные настройки по работе с файлами.
Процедура ПриДобавленииНастроекРаботыСФайлами(ОбщиеНастройки, ПерсональныеНастройки) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		МодульРаботаСФайламиСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
		МодульРаботаСФайламиСлужебныйВызовСервера.ДобавитьНастройкиРаботыСФайлами(ОбщиеНастройки, ПерсональныеНастройки);
	КонецЕсли;
	
КонецПроцедуры

// Вычисляет объем файлов тома в байтах, результат возвращается в параметр РазмерФайлов.
Процедура ПриОпределенииРазмераФайловНаТоме(СсылкаТома, РазмерФайлов) Экспорт
	
	РазмерФайлов = 0;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		МодульРаботаСФайламиСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
		РазмерФайлов = РазмерФайлов + МодульРаботаСФайламиСлужебныйВызовСервера.ПодсчитатьРазмерФайловНаТоме(СсылкаТома);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПрисоединенныеФайлы") Тогда
		МодульПрисоединенныеФайлыСлужебный = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлыСлужебный");
		РазмерФайлов = РазмерФайлов + МодульПрисоединенныеФайлыСлужебный.ПодсчитатьРазмерФайловНаТоме(СсылкаТома);
	КонецЕсли;
	
КонецПроцедуры

// Читает кодировку версии файла.
//
// Параметры:
// ВерсияСсылка - ссылка на версию файла.
//
// Возвращаемое значение:
//   Строка кодировки
Процедура ПриОпределенииКодировкиВерсииФайла(ВерсияСсылка, Кодировка)
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		МодульРаботаСФайламиСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
		Кодировка = МодульРаботаСФайламиСлужебныйВызовСервера.ПолучитьКодировкуВерсииФайла(ВерсияСсылка);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Сканирование

Функция ПараметрыСканераВПеречисления(РазрешениеЧисло, ЦветностьЧисло, ПоворотЧисло, РазмерБумагиЧисло) Экспорт 
	
	Если РазрешениеЧисло = 200 Тогда
		Разрешение = Перечисления.РазрешенияСканированногоИзображения.dpi200;
	ИначеЕсли РазрешениеЧисло = 300 Тогда
		Разрешение = Перечисления.РазрешенияСканированногоИзображения.dpi300;
	ИначеЕсли РазрешениеЧисло = 600 Тогда
		Разрешение = Перечисления.РазрешенияСканированногоИзображения.dpi600;
	ИначеЕсли РазрешениеЧисло = 1200 Тогда
		Разрешение = Перечисления.РазрешенияСканированногоИзображения.dpi1200;
	КонецЕсли;
	
	Если ЦветностьЧисло = 0 Тогда
		Цветность = Перечисления.ЦветностиИзображения.Монохромное;
	ИначеЕсли ЦветностьЧисло = 1 Тогда
		Цветность = Перечисления.ЦветностиИзображения.ГрадацииСерого;
	ИначеЕсли ЦветностьЧисло = 2 Тогда
		Цветность = Перечисления.ЦветностиИзображения.Цветное;
	КонецЕсли;
	
	Если ПоворотЧисло = 0 Тогда
		Поворот = Перечисления.СпособыПоворотаИзображения.НетПоворота;
	ИначеЕсли ПоворотЧисло = 90 Тогда
		Поворот = Перечисления.СпособыПоворотаИзображения.ВправоНа90;
	ИначеЕсли ПоворотЧисло = 180 Тогда
		Поворот = Перечисления.СпособыПоворотаИзображения.ВправоНа180;
	ИначеЕсли ПоворотЧисло = 270 Тогда
		Поворот = Перечисления.СпособыПоворотаИзображения.ВлевоНа90;
	КонецЕсли;
	
	Если РазмерБумагиЧисло = 0 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.НеЗадано;
	ИначеЕсли РазмерБумагиЧисло = 11 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.A3;
	ИначеЕсли РазмерБумагиЧисло = 1 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.A4;
	ИначеЕсли РазмерБумагиЧисло = 5 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.A5;
	ИначеЕсли РазмерБумагиЧисло = 6 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.B4;
	ИначеЕсли РазмерБумагиЧисло = 2 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.B5;
	ИначеЕсли РазмерБумагиЧисло = 7 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.B6;
	ИначеЕсли РазмерБумагиЧисло = 14 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.C4;
	ИначеЕсли РазмерБумагиЧисло = 15 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.C5;
	ИначеЕсли РазмерБумагиЧисло = 16 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.C6;
	ИначеЕсли РазмерБумагиЧисло = 3 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.USLetter;
	ИначеЕсли РазмерБумагиЧисло = 4 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.USLegal;
	ИначеЕсли РазмерБумагиЧисло = 10 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.USExecutive;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Разрешение", Разрешение);
	Результат.Вставить("Цветность", Цветность);
	Результат.Вставить("Поворот", Поворот);
	Результат.Вставить("РазмерБумаги", РазмерБумаги);
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Очистка ненужных файлов

Процедура ОчиститьНенужныеФайлы() Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.ОчисткаНенужныхФайлов);
	
	УстановитьПривилегированныйРежим(Истина);
	
	НастройкиОчистки = РегистрыСведений.НастройкиОчисткиФайлов.ТекущиеНастройкиОчистки();
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		
		НастройкиОчисткиСВерсиями  = НастройкиОчистки.НайтиСтроки(Новый Структура("ЭтоФайл, ЭтоНастройкаДляЭлементаСправочника",
		                                                                           Истина,
		                                                                           Ложь));
		
		Для Каждого Настройка Из НастройкиОчисткиСВерсиями Цикл
			
			МассивИсключений = Новый Массив;
				ДетализированныеНастройки = НастройкиОчистки.НайтиСтроки(Новый Структура(
					"ИдентификаторВладельца, ЭтоФайл, ЭтоНастройкаДляЭлементаСправочника",
					Настройка.ВладелецФайла,
					Истина,
					Истина));
				Если ДетализированныеНастройки.Количество() > 0 Тогда
					Для Каждого ЭлементИсключение Из ДетализированныеНастройки Цикл
						МассивИсключений.Добавить(ЭлементИсключение.ВладелецФайла);
						ОчиститьДанныеНенужныхФайлов(ЭлементИсключение);
					КонецЦикла;
				КонецЕсли;
			
			ОчиститьДанныеНенужныхФайлов(Настройка, МассивИсключений);
		КонецЦикла;
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПрисоединенныеФайлы") Тогда
		
		НастройкиОчисткиБезВерсий = НастройкиОчистки.НайтиСтроки(Новый Структура("ЭтоФайл, ЭтоНастройкаДляЭлементаСправочника",
		                                                                         Ложь,
		                                                                         Ложь));
		Для Каждого Настройка Из НастройкиОчисткиБезВерсий Цикл
			МассивИсключений = Новый Массив;
			ДетализированныеНастройки = НастройкиОчистки.НайтиСтроки(Новый Структура(
						"ИдентификаторВладельца, ЭтоФайл, ЭтоНастройкаДляЭлементаСправочника",
						Настройка.ВладелецФайла,
						Ложь,
						Истина));
				Если ДетализированныеНастройки.Количество() > 0 Тогда
					Для Каждого ЭлементИсключение Из ДетализированныеНастройки Цикл
						МассивИсключений.Добавить(ЭлементИсключение.ВладелецФайла);
						ОчиститьДанныеНенужныхФайлов(ЭлементИсключение);
					КонецЦикла;
				КонецЕсли;
				
			ОчиститьДанныеНенужныхФайлов(Настройка, МассивИсключений);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ОчиститьДанныеНенужныхФайлов(НастройкаОчистки, МассивИсключений = Неопределено)
	
	Если НастройкаОчистки.Действие = Перечисления.ВариантыОчисткиФайлов.НеОчищать Тогда
		Возврат;
	КонецЕсли;
	
	Если МассивИсключений = Неопределено Тогда
		МассивИсключений = Новый Массив;
	КонецЕсли;
	
	ДеревоВладельцев = ВыбратьДанныеПоПравилу(НастройкаОчистки, МассивИсключений);
	
	Если ДеревоВладельцев.Строки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Файл Из ДеревоВладельцев.Строки Цикл
		
		Если НастройкаОчистки.ЭтоФайл Тогда
			
			Если НастройкаОчистки.Действие = Перечисления.ВариантыОчисткиФайлов.ОчиститьФайлыИВерсии Тогда
				ФайлДляПометки = Файл.ФайлСсылка.ПолучитьОбъект();
				// Пропускаем удаление, если файл занят для редактирования
				Если ЗначениеЗаполнено(ФайлДляПометки.Редактирует) Тогда
					Продолжить;
				КонецЕсли;
				ФайлДляПометки.УстановитьПометкуУдаления(Истина);
			КонецЕсли;
			
			Для Каждого Версия Из Файл.Строки Цикл
				ВыполнитьОчисткуДанныхОФайле(Версия.ВерсияСсылка, Истина);
			КонецЦикла;
			
		Иначе
			ВыполнитьОчисткуДанныхОФайле(Файл.ФайлСсылка, Ложь);
		КонецЕсли;
		
	КонецЦикла;

КонецПроцедуры

Функция ВыбратьДанныеПоПравилу(НастройкаОчистки, МассивИсключений)
	
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	
	ОчищатьПоПравилу = НастройкаОчистки.ПериодОчистки = Перечисления.ПериодОчисткиФайлов.ПоПравилу;
	Если ОчищатьПоПравилу Тогда
		НастройкиКомпоновщика = НастройкаОчистки.ПравилоОтбора.Получить();
		Если НастройкиКомпоновщика <> Неопределено Тогда
			КомпоновщикНастроек.ЗагрузитьНастройки(НастройкаОчистки.ПравилоОтбора.Получить());
		КонецЕсли;
	КонецЕсли;
	
	СхемаКомпоновкиДанных = Новый СхемаКомпоновкиДанных;
	ИсточникДанных = СхемаКомпоновкиДанных.ИсточникиДанных.Добавить();
	ИсточникДанных.Имя = "ИсточникДанных1";
	ИсточникДанных.ТипИсточникаДанных = "Local";
	
	НаборДанных = СхемаКомпоновкиДанных.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	НаборДанных.Имя = "НаборДанных1";
	НаборДанных.ИсточникДанных = ИсточникДанных.Имя;
	
	СхемаКомпоновкиДанных.ПоляИтога.Очистить();
	
	Если НастройкаОчистки.ЭтоНастройкаДляЭлементаСправочника Тогда
		ВладелецФайла = НастройкаОчистки.ИдентификаторВладельца;
		ЭлементИсключение = НастройкаОчистки.ВладелецФайла;
	Иначе
		ВладелецФайла = НастройкаОчистки.ВладелецФайла;
		ЭлементИсключение = Неопределено;
	КонецЕсли;
	
	СхемаКомпоновкиДанных.НаборыДанных[0].Запрос = ТекстЗапросаДляОчисткиФайлов(
		ВладелецФайла,
		НастройкаОчистки,
		МассивИсключений,
		ЭлементИсключение);
	
	Структура = КомпоновщикНастроек.Настройки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("ФайлСсылка");
	
	Если НастройкаОчистки.ЭтоФайл Тогда
	
		СтруктураВерсий = Структура.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	
		ВыбранноеПоле = СтруктураВерсий.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
		ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("ВерсияСсылка");
	
	КонецЕсли;
	
	КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновкиДанных));
	
	Настройки = КомпоновщикНастроек.ПолучитьНастройки();
	
	Параметр = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("ТипВладельца");
	Параметр.Значение = ТипЗнч(ВладелецФайла.ЗначениеПустойСсылки);
	Параметр.Использование = Истина;
	
	Параметр = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("ПериодОчистки");
	Если Параметр <> Неопределено Тогда
		Если НастройкаОчистки.ПериодОчистки = Перечисления.ПериодОчисткиФайлов.СтаршеМесяца Тогда
			ЗначениеПериодаОчистки = ДобавитьМесяц(НачалоДня(ТекущаяДатаСеанса()), -1);
		ИначеЕсли НастройкаОчистки.ПериодОчистки = Перечисления.ПериодОчисткиФайлов.СтаршеГода Тогда
			ЗначениеПериодаОчистки = ДобавитьМесяц(НачалоДня(ТекущаяДатаСеанса()), -12);
		ИначеЕсли НастройкаОчистки.ПериодОчистки = Перечисления.ПериодОчисткиФайлов.СтаршеШестиМесяцев Тогда
			ЗначениеПериодаОчистки = ДобавитьМесяц(НачалоДня(ТекущаяДатаСеанса()), -6);
		КонецЕсли;
		Параметр.Значение = ЗначениеПериодаОчистки;
		Параметр.Использование = Истина;
	КонецЕсли;
	
	ПараметрТекущаяДата = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("ТекущаяДата");
	Если ПараметрТекущаяДата <> Неопределено Тогда
		ПараметрТекущаяДата.Значение = ТекущаяДатаСеанса();
		ПараметрТекущаяДата.Использование = Истина;
	КонецЕсли;
	
	Если МассивИсключений.Количество() > 0 Тогда
		Параметр = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("МассивИсключений");
		Параметр.Значение = МассивИсключений;
		Параметр.Использование = Истина;
	КонецЕсли;
	
	Если НастройкаОчистки.ЭтоНастройкаДляЭлементаСправочника Тогда
		Параметр = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("ЭлементИсключение");
		Параметр.Значение = ЭлементИсключение;
		Параметр.Использование = Истина;
	КонецЕсли;
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ДеревоЗначений = Новый ДеревоЗначений;
	
	МакетКомпоновкиДанных = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, КомпоновщикНастроек.Настройки, , , Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновкиДанных);
	ПроцессорВывода.УстановитьОбъект(ДеревоЗначений);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
	
	Возврат ДеревоЗначений;
	
КонецФункции

Функция ТекстЗапросаДляОчисткиФайлов(ВладелецФайла, Настройка, МассивИсключений, ЭлементИсключение)
	
	Если Настройка.ЭтоФайл И ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		
		МодульРаботаСФайламиСлужебный = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебный");
		Возврат МодульРаботаСФайламиСлужебный.ТекстЗапросаДляОчисткиФайлов(ВладелецФайла, Настройка, МассивИсключений, ЭлементИсключение);
		
	КонецЕсли;
	
	Если Не Настройка.ЭтоФайл И ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПрисоединенныеФайлы") Тогда
		
		МодульПрисоединенныеФайлыСлужебный = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлыСлужебный");
		Возврат МодульПрисоединенныеФайлыСлужебный.ТекстЗапросаДляОчисткиФайлов(ВладелецФайла, Настройка, МассивИсключений, ЭлементИсключение);
		
	КонецЕсли;
	
КонецФункции

Функция ТекстЗапросаПолногоОбъемаФайлов() Экспорт
	
	ТекстЗапроса = "";
	
	ДобавитьПсевдонимПоля = Истина;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		
		МодульРаботаСФайламиСлужебный = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебный");
		МодульРаботаСФайламиСлужебный.СформироватьТекстЗапросаПолногоОбъемаФайлов(ТекстЗапроса);
		ДобавитьПсевдонимПоля = Ложь;
		
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПрисоединенныеФайлы") Тогда
		
		МодульПрисоединенныеФайлыСлужебный = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлыСлужебный");
		МодульПрисоединенныеФайлыСлужебный.СформироватьТекстЗапросаПолногоОбъемаФайлов(ТекстЗапроса, ДобавитьПсевдонимПоля);
		
	КонецЕсли;
	
	Возврат ТекстЗапроса;
	
КонецФункции

Процедура ВыполнитьОчисткуДанныхОФайле(ФайлСсылка, ЭтоФайл)
	
	Если ЭтоФайл Тогда
		МодульРаботаСФайламиСлужебный = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебный");
		МодульРаботаСФайламиСлужебный.ВыполнитьОчисткуДанныхОФайле(ФайлСсылка);
	Иначе
		МодульПрисоединенныеФайлыСлужебный = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлыСлужебный");
		МодульПрисоединенныеФайлыСлужебный.ВыполнитьОчисткуДанныхОФайле(ФайлСсылка);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПроверитьЦелостностьФайлов(ТаблицаФайлов, Том) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		
		МодульРаботаСФайламиСлужебный = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебный");
		МодульРаботаСФайламиСлужебный.ПроверитьЦелостностьФайлов(ТаблицаФайлов, Том);
		ДобавитьПсевдонимПоля = Ложь;
		
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПрисоединенныеФайлы") Тогда
		
		МодульПрисоединенныеФайлыСлужебный = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлыСлужебный");
		МодульПрисоединенныеФайлыСлужебный.ПроверитьЦелостностьФайлов(ТаблицаФайлов, Том);
		
	КонецЕсли
	
КонецПроцедуры

Функция ОбъектыИсключенияПриОчисткеФайлов() Экспорт
	
	Массив = Новый Массив;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		
		МодульРаботаСФайламиПереопределяемый = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиПереопределяемый");
		МассивОбъектов = МодульРаботаСФайламиПереопределяемый.ОбъектыИсключенияПриОчисткеФайлов();
		МодульРаботаСФайламиПереопределяемый.ПриОпределенииОбъектовИсключенияОчисткиФайлов(МассивОбъектов);
		Для Каждого ОбъектМетаданных Из МассивОбъектов Цикл
			Массив.Добавить(ОбъектМетаданных);
		КонецЦикла;
		
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПрисоединенныеФайлы") Тогда
		
		МодульПрисоединенныеПереопределяемый = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлыПереопределяемый");
		МассивОбъектов = МодульПрисоединенныеПереопределяемый.ОбъектыИсключенияПриОчисткеФайлов();
		МодульПрисоединенныеПереопределяемый.ПриОпределенииОбъектовИсключенияОчисткиФайлов(МассивОбъектов);
		Для Каждого ОбъектМетаданных Из МассивОбъектов Цикл
			Массив.Добавить(ОбъектМетаданных);
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Синхронизация файлов

Функция ПриОпределенииОбъектовИсключенияСинхронизацииФайлов() Экспорт
	
	Массив = Новый Массив;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		
		МодульРаботаСФайламиПереопределяемый = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиПереопределяемый");
		МодульРаботаСФайламиПереопределяемый.ПриОпределенииОбъектовИсключенияСинхронизацииФайлов(Массив);
		
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПрисоединенныеФайлы") Тогда
		
		МодульПрисоединенныеПереопределяемый = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлыПереопределяемый");
		МодульПрисоединенныеПереопределяемый.ПриОпределенииОбъектовИсключенияСинхронизацииФайлов(Массив);
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

// Проверяет, была ли ошибка при выполнении HTTP запроса, и вызывает соответствующее исключение.
Процедура ПроверитьИсключениеHTTP1С(Ответ, АдресСервера)
	Если (Ответ.КодСостояния >= 400) И (Ответ.КодСостояния <= 599) Тогда
		ШаблонОшибки = НСтр("ru = 'Ошибка HTTP 1С : %1 в %2'");
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки, Ответ.КодСостояния, РаскодироватьСтроку(АдресСервера, СпособКодированияСтроки.URLВКодировкеURL));
	КонецЕсли;
КонецПроцедуры

// Выполняет метод протокола webdav
Процедура ВыполнитьМетодWebdav(ИмяМетода, Href, СоответствиеЗаголовков, СтруктураОбмена, XMLЗапрос="", ТекстПротокола = Неопределено)

	СтруктураHref = СтруктураURIРаскодированная(Href);
	
	HTTP = СоздатьHTTPСоединениеWebdav(СтруктураHref, СтруктураОбмена);
	
	HTTPЗапросWebdav = Новый HTTPЗапрос(КодироватьСтроку(СтруктураHref.ПутьНаСервере, СпособКодированияСтроки.URLВКодировкеURL), СоответствиеЗаголовков);
	
	Если ЗначениеЗаполнено(XMLЗапрос) Тогда
		HTTPЗапросWebdav.УстановитьТелоИзСтроки(XMLЗапрос);
	КонецЕсли; 
	
	Если ТекстПротокола<>Неопределено Тогда
		ТекстПротокола = ТекстПротокола + ?(ПустаяСтрока(ТекстПротокола), "", Символы.ПС)
			+ ИмяМетода + " " + Href + Символы.ПС + Символы.ПС + XMLЗапрос + Символы.ПС;
	КонецЕсли; 
	
	СтруктураОбмена.Ответ = HTTP.ВызватьHTTPМетод(ИмяМетода,HTTPЗапросWebdav);
	
	Если ТекстПротокола<>Неопределено Тогда
		ТекстПротокола = ТекстПротокола + ?(ПустаяСтрока(ТекстПротокола), "", Символы.ПС) + "HTTP RESPONSE "
			+ СтруктураОбмена.Ответ.КодСостояния + Символы.ПС + Символы.ПС;
		Для каждого ЗаголовокОтвета Из СтруктураОбмена.Ответ.Заголовки Цикл
			ТекстПротокола = ТекстПротокола+ЗаголовокОтвета.Ключ+": " + ЗаголовокОтвета.Значение + Символы.ПС;
		КонецЦикла; 
		ТекстПротокола = ТекстПротокола+Символы.ПС+СтруктураОбмена.Ответ.ПолучитьТелоКакСтроку() + Символы.ПС;
	КонецЕсли; 
	
	ПроверитьИсключениеHTTP1С(СтруктураОбмена.Ответ,Href);
	
КонецПроцедуры

// Обновляет уникальный служебный реквизит файла на сервере webdav
Процедура ОбновитьUID1CФайла(Href, UID1C, ПараметрыСинхронизации)

	ЗаголовкиHTTP = Новый Соответствие;
	ЗаголовкиHTTP["User-Agent"] = "1C Enterprise 8.3";
	ЗаголовкиHTTP["Content-type"] = "text/xml";
	ЗаголовкиHTTP["Accept"] = "text/xml";
	
	ВыполнитьМетодWebdav("PROPPATCH",Href,ЗаголовкиHTTP,ПараметрыСинхронизации,
					"<?xml version=""1.0"" encoding=""utf-8""?>
					|<D:propertyupdate xmlns:D=""DAV:"" xmlns:U=""tsov.pro"">
					|  <D:set><D:prop>
					|    <U:UID1C>"+UID1C+"</U:UID1C>
					|  </D:prop></D:set>
					|</D:propertyupdate>");
	
КонецПроцедуры

// Считывает уникальный служебный реквизит файла на сервере webdav
Функция ПолучитьUID1C(Href,ПараметрыСинхронизации)

	ЗаголовкиHTTP = Новый Соответствие;
	ЗаголовкиHTTP["User-Agent"] = "1C Enterprise 8.3";
	ЗаголовкиHTTP["Content-type"] = "text/xml";
	ЗаголовкиHTTP["Accept"] = "text/xml";
	ЗаголовкиHTTP["Depth"] = "0";
	
	ВыполнитьМетодWebdav("PROPFIND",Href,ЗаголовкиHTTP,ПараметрыСинхронизации,
					"<?xml version=""1.0"" encoding=""utf-8""?>
					|<D:propfind xmlns:D=""DAV:"" xmlns:U=""tsov.pro""><D:prop>
					|<U:UID1C />
					|</D:prop></D:propfind>");
					
	КонтекстXml = ОпределитьКонтекстXML(ПараметрыСинхронизации.Ответ.ПолучитьТелоКакСтроку());
	
	НайденныеEtag = ВычислитьXPath("//*[local-name()='propstat'][contains(./*[local-name()='status'],'200 OK')]/*[local-name()='prop']/*[local-name()='UID1C']",КонтекстXml).ПолучитьСледующий();
	Если НайденныеEtag<>Неопределено Тогда
		Возврат НайденныеEtag.ТекстовоеСодержимое;
	КонецЕсли;
	
	Возврат "";

КонецФункции

// Проверяет, поддерживает ли сервер webdav пользовательские свойства для файла
Функция ПроверитьВозможностьUID1C(Href, UID1C, ПараметрыСинхронизации)

	Попытка
		
		ОбновитьUID1CФайла(Href, UID1C, ПараметрыСинхронизации);
		Возврат ЗначениеЗаполнено(ПолучитьUID1C(Href, ПараметрыСинхронизации));
		
	Исключение
		
		ЗаписатьВЖурналСобытийСинхронизацииФайлов(ОписаниеОшибки(), ПараметрыСинхронизации);
		
	КонецПопытки;
	
	Возврат Ложь;

КонецФункции

// Выполняет MCKOL на сервере webdav
Процедура ВызватьМетодMKCOL(Href, ПараметрыСинхронизации)

	ЗаголовкиHTTP = Новый Соответствие;
	ЗаголовкиHTTP["User-Agent"] = "1C Enterprise 8.3";
	ВыполнитьМетодWebdav("MKCOL",Href,ЗаголовкиHTTP,ПараметрыСинхронизации);

КонецПроцедуры // ВызватьМетодMKCOL()

// Выполняет DELETE на сервере webdav
Процедура ВызватьМетодDELETE(Href, ПараметрыСинхронизации)
	
	HrefБезСлеша = ЗакончитьБезСлеша(Href);
	ЗаголовкиHTTP = Новый Соответствие;
	ЗаголовкиHTTP["User-Agent"] = "1C Enterprise 8.3";
	ВыполнитьМетодWebdav("DELETE", HrefБезСлеша, ЗаголовкиHTTP, ПараметрыСинхронизации);
	
КонецПроцедуры

// Получает Etag файла на сервере
Функция ПолучитьEtag(Href,ПараметрыСинхронизации)
	
	ЗаголовкиHTTP = Новый Соответствие;
	ЗаголовкиHTTP["User-Agent"] = "1C Enterprise 8.3";
	ЗаголовкиHTTP["Content-type"] = "text/xml";
	ЗаголовкиHTTP["Accept"] = "text/xml";
	ЗаголовкиHTTP["Depth"] = "0";
	
	ВыполнитьМетодWebdav("PROPFIND",Href,ЗаголовкиHTTP,ПараметрыСинхронизации,
					"<?xml version=""1.0"" encoding=""utf-8""?>
					|<D:propfind xmlns:D=""DAV:""><D:prop>
					|<D:getetag />
					|</D:prop></D:propfind>");
					
	КонтекстXml = ОпределитьКонтекстXML(ПараметрыСинхронизации.Ответ.ПолучитьТелоКакСтроку());
	
	НайденныеEtag = ВычислитьXPath("//*[local-name()='propstat'][contains(./*[local-name()='status'],'200 OK')]/*[local-name()='prop']/*[local-name()='getetag']",КонтекстXml).ПолучитьСледующий();
	Если НайденныеEtag<>Неопределено Тогда
		Возврат НайденныеEtag.ТекстовоеСодержимое;
	КонецЕсли;
	
	Возврат "";
КонецФункции

// Инициализирует объект HTTPСоединение
Функция СоздатьHTTPСоединениеWebdav(СтруктураHref,ПараметрыСинхронизации)

	Если НЕ ЗначениеЗаполнено(СтруктураHref.Порт) Тогда
		HTTP = Новый HTTPСоединение(
						СтруктураHref.Хост,
						,
						ПараметрыСинхронизации.Логин,
						ПараметрыСинхронизации.Пароль,
						,
						,
						?(СтруктураHref.Схема="https",Новый(Тип("ЗащищенноеСоединениеOpenSSL")),Неопределено));
	Иначе
		HTTP = Новый HTTPСоединение(
						СтруктураHref.Хост,
						СтруктураHref.Порт,
						ПараметрыСинхронизации.Логин,
						ПараметрыСинхронизации.Пароль,
						,
						,
						?(СтруктураHref.Схема="https",Новый(Тип("ЗащищенноеСоединениеOpenSSL")),Неопределено));
	КонецЕсли;
	
	Возврат HTTP;
	
КонецФункции //

// Вызывает метод GET на сервере webdav и возвращает адрес загруженного файла во временном хранилище.
Функция ВызватьМетодGET(Href, Etag, ПараметрыСинхронизации, ДатаМодификацииФайла = Неопределено, ДлинаФайла = Неопределено)

	СтруктураHref = СтруктураURIРаскодированная(Href);
	
	HTTP = СоздатьHTTPСоединениеWebdav(СтруктураHref,ПараметрыСинхронизации);
	
	ЗаголовкиHTTP = Новый Соответствие;
	ЗаголовкиHTTP["User-Agent"]="1C Enterprise 8.3";
	ЗаголовкиHTTP["Accept"]="application/octet-stream";
	
	HTTPЗапросWebdav = Новый HTTPЗапрос(КодироватьСтроку(СтруктураHref.ПутьНаСервере,СпособКодированияСтроки.URLВКодировкеURL),ЗаголовкиHTTP);
	
	ПараметрыСинхронизации.Ответ = HTTP.Получить(HTTPЗапросWebdav);
	
	ПроверитьИсключениеHTTP1С(ПараметрыСинхронизации.Ответ, Href);
	
	ФайлСДвоичнымиДанными = ПараметрыСинхронизации.Ответ.ПолучитьТелоКакДвоичныеДанные();
	
	Etag = ?(ПараметрыСинхронизации.Ответ.Заголовки["ETag"] = Неопределено, "", ПараметрыСинхронизации.Ответ.Заголовки["ETag"]);
	ДатаМодификацииФайла = ?(ПараметрыСинхронизации.Ответ.Заголовки["Last-Modified"] = Неопределено,ТекущаяУниверсальнаяДата(),ДатаRFC1123(ПараметрыСинхронизации.Ответ.Заголовки["Last-Modified"]));
	ДлинаФайла = ФайлСДвоичнымиДанными.Размер();
	
	АдресВременныхДанных = ПоместитьВоВременноеХранилище(ФайлСДвоичнымиДанными);
	
	Возврат АдресВременныхДанных;

КонецФункции

// Помещает файл на сервер webdav с помощью метода PUT и возвращает присвоенный etag в переменную.
Функция ВызватьМетодPUT(Href, ФайлСсылка, ПараметрыСинхронизации, ЭтоФайл)
	
	Если ЭтоФайл Тогда
		МодульРаботаСФайламиСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
		ФайлСДвоичнымиДанными = МодульРаботаСФайламиСлужебныйВызовСервера.ДанныеФайлаИДвоичныеДанные(ФайлСсылка).ДвоичныеДанные;
	Иначе
		МодульПрисоединенныеФайлы = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлы");
		ФайлСДвоичнымиДанными = МодульПрисоединенныеФайлы.ПолучитьДвоичныеДанныеФайла(ФайлСсылка);
	КонецЕсли;
	
	СтруктураHref = СтруктураURIРаскодированная(Href);
	
	HTTP = СоздатьHTTPСоединениеWebdav(СтруктураHref,ПараметрыСинхронизации);
	
	ЗаголовкиHTTP = Новый Соответствие;
	ЗаголовкиHTTP["User-Agent"]="1C Enterprise 8.3";
	ЗаголовкиHTTP["Content-Type"]="application/octet-stream";
	
	HTTPЗапросWebdav = Новый HTTPЗапрос(КодироватьСтроку(СтруктураHref.ПутьНаСервере,СпособКодированияСтроки.URLВКодировкеURL),ЗаголовкиHTTP);
	
	HTTPЗапросWebdav.УстановитьТелоИзДвоичныхДанных(ФайлСДвоичнымиДанными);
	
	ПараметрыСинхронизации.Ответ = HTTP.Записать(HTTPЗапросWebdav);
	
	ПроверитьИсключениеHTTP1С(ПараметрыСинхронизации.Ответ,Href);
	
	Возврат ПолучитьEtag(Href,ПараметрыСинхронизации);
	
КонецФункции

// Загружает файл с сервера с созданием новой версии.
Процедура ЗагрузитьФайлССервера(ПараметрыФайла, ЭтоФайл = Неопределено)
	
	Перем АдресЗагруженногоФайла, НовыйФайл, СтруктураИмениФайла, ФайлUID1C;
	
	ИмяФайла = ПараметрыФайла.ИмяФайла;
	Href = ПараметрыФайла.Href;
	Etag = ПараметрыФайла.Etag;
	ДатаМодификацииФайла = ПараметрыФайла.ДатаМодификацииФайла;
	ДлинаФайла = ПараметрыФайла.ДлинаФайла;
	ДляПользователя = ПараметрыФайла.ДляПользователя;
	ОбъектВладелец = ПараметрыФайла.ОбъектВладелец;
	СсылкаСуществующегоФайла = ПараметрыФайла.СсылкаСуществующегоФайла;
	ПараметрыСинхронизации = ПараметрыФайла.ПараметрыСинхронизации;
	ТекстСобытия = НСтр("ru = 'Загрузка файла с сервера: %1'");
	ЗаписатьВЖурналСобытийСинхронизацииФайлов(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСобытия, ИмяФайла), ПараметрыСинхронизации);
	АдресЗагруженногоФайла = ВызватьМетодGET(Href, Etag, ПараметрыСинхронизации, ДатаМодификацииФайла, ДлинаФайла);
	
	Если ЭтоФайл = Неопределено Тогда
		ЭтоФайл = ОбъектЯвляетсяФайлом(ПараметрыФайла.ОбъектВладелец);
	КонецЕсли;
	
	Если АдресЗагруженногоФайла <> Неопределено Тогда
		
		СтруктураИмениФайла = Новый Файл(ИмяФайла);
		
		Если СсылкаСуществующегоФайла = Неопределено Тогда
			
			Если ЭтоФайл Тогда
				
				МодульРаботаСФайламиКлиентСервер = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиКлиентСервер");
				ОписаниеФайла = МодульРаботаСФайламиКлиентСервер.СведенияОФайле("ФайлСВерсией");
				
				ОписаниеФайла.ИмяБезРасширения = СтруктураИмениФайла.ИмяБезРасширения;
				ОписаниеФайла.РасширениеБезТочки = ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(СтруктураИмениФайла.Расширение);
				ОписаниеФайла.ВремяИзменения = МестноеВремя(ДатаМодификацииФайла,ЧасовойПоясСеанса());
				ОписаниеФайла.ВремяИзмененияУниверсальное = ДатаМодификацииФайла;
				ОписаниеФайла.Размер = ДлинаФайла;
				ОписаниеФайла.АдресВременногоХранилищаФайла = АдресЗагруженногоФайла;
				ОписаниеФайла.Автор = ПараметрыСинхронизации.АвторФайлов;
				ОписаниеФайла.НоваяВерсияАвтор = ДляПользователя;
				
				МодульРаботаСФайламиСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
				НовыйФайл = МодульРаботаСФайламиСлужебныйВызовСервера.СоздатьФайлСВерсией(ОбъектВладелец, ОписаниеФайла);
				ДанныеФайла = МодульРаботаСФайламиСлужебныйВызовСервера.ДанныеФайла(НовыйФайл);
				МодульРаботаСФайламиСлужебныйВызовСервера.ЗанятьФайл(ДанныеФайла, , , ПараметрыФайла.ДляПользователя);
			Иначе
				МодульПрисоединенныеФайлы = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлы");
				ПараметрыФайла = Новый Структура;
				ПараметрыФайла.Вставить("ВладелецФайлов", ОбъектВладелец);
				ПараметрыФайла.Вставить("Автор", ПараметрыСинхронизации.АвторФайлов);
				ПараметрыФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.ИмяБезРасширения);
				ПараметрыФайла.Вставить("РасширениеБезТочки", ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(СтруктураИмениФайла.Расширение));
				ПараметрыФайла.Вставить("ВремяИзменения", МестноеВремя(ДатаМодификацииФайла,ЧасовойПоясСеанса()));
				ПараметрыФайла.Вставить("ВремяИзмененияУниверсальное", ДатаМодификацииФайла);
				
				НовыйФайл = МодульПрисоединенныеФайлы.ДобавитьПрисоединенныйФайл(ПараметрыФайла, АдресЗагруженногоФайла);
				
				МодульПрисоединенныеФайлыСлужебный = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлыСлужебный");
				МодульПрисоединенныеФайлыСлужебный.ЗанятьФайлДляРедактированияСервер(НовыйФайл, ПараметрыСинхронизации.АвторФайлов);
			КонецЕсли;
			
		Иначе
			
			Если ЭтоФайл Тогда
				
				МодульРаботаСФайламиКлиентСервер = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиКлиентСервер");
				ОписаниеФайла = МодульРаботаСФайламиКлиентСервер.СведенияОФайле("ФайлСВерсией");
			
				ОписаниеФайла.ИмяБезРасширения = СтруктураИмениФайла.ИмяБезРасширения;
				ОписаниеФайла.РасширениеБезТочки = ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(СтруктураИмениФайла.Расширение);
				ОписаниеФайла.ВремяИзменения = МестноеВремя(ДатаМодификацииФайла,ЧасовойПоясСеанса());
				ОписаниеФайла.ВремяИзмененияУниверсальное = ДатаМодификацииФайла;
				ОписаниеФайла.Размер = ДлинаФайла;
				ОписаниеФайла.АдресВременногоХранилищаФайла = АдресЗагруженногоФайла;
				ОписаниеФайла.Автор = ПараметрыСинхронизации.АвторФайлов;
				ОписаниеФайла.НоваяВерсияАвтор = ПараметрыСинхронизации.АвторФайлов;
				
				МодульРаботаСФайламиСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
				ВерсияФайла = МодульРаботаСФайламиСлужебныйВызовСервера.ОбновитьВерсиюФайла(СсылкаСуществующегоФайла, ОписаниеФайла, , , ПараметрыСинхронизации.АвторФайлов);
				МодульРаботаСФайламиСлужебныйВызовСервера.ОбновитьВерсиюВФайле(СсылкаСуществующегоФайла, ВерсияФайла, Неопределено);
				ДанныеФайла = МодульРаботаСФайламиСлужебныйВызовСервера.ДанныеФайла(СсылкаСуществующегоФайла);
				МодульРаботаСФайламиСлужебныйВызовСервера.ЗанятьФайл(ДанныеФайла, , , ПараметрыФайла.ДляПользователя);
				
				НовыйФайл = СсылкаСуществующегоФайла;
			Иначе
				ИнформацияОФайле = Новый Структура;
				ИнформацияОФайле.Вставить("АдресФайлаВоВременномХранилище", АдресЗагруженногоФайла);
				ИнформацияОФайле.Вставить("АдресВременногоХранилищаТекста", Неопределено);
				ИнформацияОФайле.Вставить("ИмяБезРасширения", СтруктураИмениФайла.ИмяБезРасширения);
				ИнформацияОФайле.Вставить("ДатаМодификацииУниверсальная", ДатаМодификацииФайла);
				ИнформацияОФайле.Вставить("Расширение", ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(СтруктураИмениФайла.Расширение));
				ИнформацияОФайле.Вставить("Редактирует", ПараметрыСинхронизации.АвторФайлов);
				
				МодульПрисоединенныеФайлы = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлы");
				МодульПрисоединенныеФайлы.ОбновитьПрисоединенныйФайл(СсылкаСуществующегоФайла, ИнформацияОФайле);
				НовыйФайл = СсылкаСуществующегоФайла;
			КонецЕсли;
			
		КонецЕсли; 
		
		ФайлUID1C = Строка(НовыйФайл.Ссылка.УникальныйИдентификатор());
		ОбновитьUID1CФайла(Href, ФайлUID1C, ПараметрыСинхронизации);
		
		ЗапомнитьСерверныеДанныеСсылки(
			НовыйФайл.Ссылка,
			Href,
			Etag,
			ЭтоФайл,
			ОбъектВладелец,
			Ложь,
			ПараметрыСинхронизации.УчетнаяЗапись);
		
		ТекстСообщения = НСтр("ru = 'Загружен файл с сервера: %1'");
	Иначе
		ТекстСообщения = НСтр("ru = 'Не удалось загрузить файл с сервера:  %1'");
	КонецЕсли;
	
	ЗаписатьВЖурналСобытийСинхронизацииФайлов(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСообщения, ИмяФайла), ПараметрыСинхронизации);

КонецПроцедуры

// Записывает событие в журнал регистрации
Процедура ЗаписатьВЖурналСобытийСинхронизацииФайлов(ТекстСообщения, ПараметрыСинхронизации)

	ЗаписьЖурналаРегистрации(НСтр("ru = 'Синхронизация файлов с облачным сервисом:'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					УровеньЖурналаРегистрации.Информация,
					,
					ПараметрыСинхронизации.УчетнаяЗапись,
					ТекстСообщения);
	
КонецПроцедуры

// Возвращает дату, преобразованную из формата RFC 1123 в тип Дата
Функция ДатаRFC1123(ДатаСтрокойHTTP)

	ИменаМесяцев = "janfebmaraprmayjunjulaugsepoctnovdec";
	// rfc1123-date = wkday "," SP date1 SP time SP "GMT"
	ПозицияПервогоПробела = СтрНайти(ДатаСтрокойHTTP, " ");//с первого пробела до второго пробела идет дата
	ПодстрокаДата = Сред(ДатаСтрокойHTTP,ПозицияПервогоПробела+1);
	ПодстрокаВремя = Сред(ПодстрокаДата,13);
	ПодстрокаДата = Лев(ПодстрокаДата,11);
	ПозицияПервогоПробела = СтрНайти(ПодстрокаВремя, " ");
	ПодстрокаВремя = Лев(ПодстрокаВремя,ПозицияПервогоПробела-1);
	// date1 = 2DIGIT SP month SP 4DIGIT
	ПодстрокаДень = Лев(ПодстрокаДата,2);
	ПодстрокаМесяц = Формат(Цел(СтрНайти(ИменаМесяцев,НРег(Сред(ПодстрокаДата,4,3))) / 3)+1,"ЧЦ=2; ЧН=00; ЧВН=");
	ПодстрокаГод = Сред(ПодстрокаДата,8);
	// time = 2DIGIT ":" 2DIGIT ":" 2DIGIT
	ПодстрокаЧас = Лев(ПодстрокаВремя,2);
	ПодстрокаМинута = Сред(ПодстрокаВремя,4,2);
	ПодстрокаСекунда = Прав(ПодстрокаВремя,2);
	
	Возврат Дата(ПодстрокаГод+ПодстрокаМесяц+ПодстрокаДень+ПодстрокаЧас+ПодстрокаМинута+ПодстрокаСекунда);

КонецФункции

// Считывает основные данные о состоянии каталога на сервере. Используется для проверки подключения.
Процедура ПрочитатьПараметрыКаталога(РезультатПроверки, HttpАдрес, СтруктураОбмена)

	СтруктураАдресаHTTP = СтруктураURIРаскодированная(HttpАдрес);
	АдресСервера = КодироватьURIПоСтруктуре(СтруктураАдресаHTTP);
	
	Попытка
		// получаем каталог
		ЗаголовкиHTTP = Новый Соответствие;
		ЗаголовкиHTTP["User-Agent"] = "1C Enterprise 8.3";
		ЗаголовкиHTTP["Content-type"] = "text/xml";
		ЗаголовкиHTTP["Accept"] = "text/xml";
		ЗаголовкиHTTP["Depth"] = "0";
		
		ВыполнитьМетодWebdav("PROPFIND", АдресСервера, ЗаголовкиHTTP, СтруктураОбмена,
						"<?xml version=""1.0"" encoding=""utf-8""?>
						|<D:propfind xmlns:D=""DAV:"" xmlns:U=""tsov.pro""><D:prop>
						|<D:quota-used-bytes /><D:quota-available-bytes />
						|</D:prop></D:propfind>"
						,РезультатПроверки.РезультатПротокол);
						
		КонтекстДокументаXML = ОпределитьКонтекстXML(СтруктураОбмена.Ответ.ПолучитьТелоКакСтроку());
		
		РезультатXPath = ВычислитьXPath("//*[local-name()='response']",КонтекстДокументаXML);
		
		НайденныйResponse = РезультатXPath.ПолучитьСледующий();
		
		Пока НайденныйResponse <> Неопределено Цикл
			
			НайденныйPropstat = ВычислитьXPath("./*[local-name()='propstat'][contains(./*[local-name()='status'],'200 OK')]/*[local-name()='prop']", КонтекстДокументаXML, НайденныйResponse).ПолучитьСледующий();
			
			Если НайденныйPropstat<>Неопределено Тогда
				Для каждого ДочернийУзелPropstat Из НайденныйPropstat.ДочерниеУзлы Цикл
					Если ДочернийУзелPropstat.ЛокальноеИмя = "quota-available-bytes" Тогда
						Попытка
							РазмерВМегабайтах = Окр(Число(ДочернийУзелPropstat.ТекстовоеСодержимое)/1024/1024, 1);
						Исключение
							РазмерВМегабайтах = 0;
						КонецПопытки;
						
						ИнформацияОСвободномМесте = НСтр("ru = 'Свободное место (байт): %1(%2 Мб)'");
						
						РезультатПроверки.РезультатТекст = РезультатПроверки.РезультатТекст + ?(ПустаяСтрока(РезультатПроверки.РезультатТекст), "", Символы.ПС)
							+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ИнформацияОСвободномМесте, ДочернийУзелPropstat.ТекстовоеСодержимое, РазмерВМегабайтах);
					ИначеЕсли ДочернийУзелPropstat.ЛокальноеИмя = "quota-used-bytes" Тогда
						Попытка
							РазмерВМегабайтах = Окр(Число(ДочернийУзелPropstat.ТекстовоеСодержимое)/1024/1024, 1);
						Исключение
							РазмерВМегабайтах = 0;
						КонецПопытки;
						
						ИнформацияОЗанятомМесте = НСтр("ru = 'Занято (байт): %1(%2 Мб)'");
						
						РезультатПроверки.РезультатТекст = РезультатПроверки.РезультатТекст + ?(ПустаяСтрока(РезультатПроверки.РезультатТекст), "", Символы.ПС)
							+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ИнформацияОЗанятомМесте, ДочернийУзелPropstat.ТекстовоеСодержимое, РазмерВМегабайтах);
					КонецЕсли; 
				КонецЦикла; 
			КонецЕсли; 
			
			НайденныйResponse = РезультатXPath.ПолучитьСледующий();
			
		КонецЦикла;
	
	Исключение
		ОписаниеОшибки = ОписаниеОшибки();
		РезультатПроверки.РезультатТекст = РезультатПроверки.РезультатТекст + ?(ПустаяСтрока(РезультатПроверки.РезультатТекст), "", Символы.ПС) + ОписаниеОшибки;
		ЗаписатьВЖурналСобытийСинхронизацииФайлов(ОписаниеОшибки,СтруктураОбмена);
		Отказ = Истина;
		РезультатПроверки.Отказ = Истина;
	КонецПопытки; 
	
КонецПроцедуры

// Возвращает структуру URI
Функция СтруктураURIРаскодированная(Знач СтрокаURI)
	
	СтрокаURI = СокрЛП(СтрокаURI);
	
	// Схема
	Схема = "";
	Позиция = СтрНайти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;

	// Строка соединения и путь на сервере
	СтрокаСоединения = СтрокаURI;
	ПутьНаСервере = "";
	Позиция = СтрНайти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		// Включая первый слэш
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
		
	// Информация пользователя и имя сервера
	СтрокаАвторизации = "";
	ИмяСервера = СтрокаСоединения;
	Позиция = СтрНайти(СтрокаСоединения, "@");
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// Логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = "";
	Позиция = СтрНайти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// Хост и порт
	Хост = ИмяСервера;
	Порт = "";
	Позиция = СтрНайти(ИмяСервера, ":");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", НРег(Схема));
	Результат.Вставить("Логин", Логин);
	Результат.Вставить("Пароль", Пароль);
	Результат.Вставить("ИмяСервера", НРег(ИмяСервера));
	Результат.Вставить("Хост", НРег(Хост));
	Результат.Вставить("Порт", ?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
	Результат.Вставить("ПутьНаСервере", РаскодироватьСтроку(ЗакончитьБезСлеша(ПутьНаСервере),СпособКодированияСтроки.URLВКодировкеURL)); 
	
	// Путь на сервере всегда будет с начальным, но без конечного слэша, универсально для файлов и папок.
	Возврат Результат; 
	
КонецФункции

// Возвращает URI, составленный из структуры
Функция КодироватьURIПоСтруктуре(Знач СтруктураURI, ВключаяПутьНаСервере = Истина)
	Результат = "";
	
	// Протокол
	Если Не ПустаяСтрока(СтруктураURI.Схема) Тогда
		Результат = Результат + СтруктураURI.Схема + "://";
	КонецЕсли;
	
	// Авторизация
	Если Не ПустаяСтрока(СтруктураURI.Логин) Тогда
		Результат = Результат + СтруктураURI.Логин + ":" + СтруктураURI.Пароль + "@";
	КонецЕсли;
		
	// Все остальное
	Результат = Результат + СтруктураURI.Хост;
	Если ЗначениеЗаполнено(СтруктураURI.Порт) Тогда
		Результат = Результат + ":" + ?(ТипЗнч(СтруктураURI.Порт) = Тип("Число"), Формат(СтруктураURI.Порт, "ЧГ=0"), СтруктураURI.Порт);
	КонецЕсли;
	
	Результат = Результат + ?(ВключаяПутьНаСервере, КодироватьСтроку(ЗакончитьБезСлеша(СтруктураURI.ПутьНаСервере), СпособКодированияСтроки.URLВКодировкеURL),"");
	
	// Всегда без конечного слеша
	Возврат Результат; 
	
КонецФункции

// Возвращает строку, гарантированно начинающуюся прямым слешем
Функция НачатьСлешем(Знач ИсходнаяСтрока)
	Возврат ?(Лев(ИсходнаяСтрока,1)="/",ИсходнаяСтрока,"/"+ИсходнаяСтрока);
КонецФункции 

// Возвращает строку, гарантированно заканчивающуюся без прямого слэша
Функция ЗакончитьБезСлеша(Знач ИсходнаяСтрока)
	Возврат ?(Прав(ИсходнаяСтрока,1)="/",Лев(ИсходнаяСтрока,СтрДлина(ИсходнаяСтрока)-1),ИсходнаяСтрока);
КонецФункции

// Возвращает результат сравнения путей двух URI, вне зависимости от наличия начального и конечного прямого слеша,
// кодирования спецсимволов, а так же адреса сервера.
Функция ЭтоОдинаковыеПутиURI(URI1,URI2,ЧувствительноКРегистру = Истина)
	
	// Гарантирует идентичность вне зависимости от слэшей и кодирования
	СтруктураURI1 = СтруктураURIРаскодированная(URI1); 
	СтруктураURI2 = СтруктураURIРаскодированная(URI2);
	Если НЕ ЧувствительноКРегистру Тогда
		СтруктураURI1.ПутьНаСервере = НРег(СтруктураURI1.ПутьНаСервере);
		СтруктураURI2.ПутьНаСервере = НРег(СтруктураURI2.ПутьНаСервере);
	КонецЕсли; 
	
	Возврат КодироватьURIПоСтруктуре(СтруктураURI1,Истина) = КодироватьURIПоСтруктуре(СтруктураURI2,Истина);
	
КонецФункции

// Возвращает имя файла по Href
Функция ИмяФайлаПоHref(Href)

	URI = ЗакончитьБезСлеша(Href);
	ДлинаURI = СтрДлина(URI);
	
	// Находим последний слэш, после него будет имя файла
	
	Для Сч = 1 По ДлинаURI Цикл
		СимволURI = Сред(URI,ДлинаURI - Сч + 1, 1);
		Если СимволURI = "/" Тогда
			Возврат РаскодироватьСтроку(Сред(URI,ДлинаURI - Сч + 2), СпособКодированияСтроки.КодировкаURL);
		КонецЕсли;
	КонецЦикла;
	
	Возврат РаскодироватьСтроку(URI,СпособКодированияСтроки.КодировкаURL);

КонецФункции

// Сохраняет данные о Href и Etag файла или папки в базе данных
Процедура ЗапомнитьСерверныеДанныеСсылки(
		Ссылка,
		Href,
		Etag,
		ЭтоФайл,
		ВладелецФайла,
		ЭтоПапка,
		УчетнаяЗапись = Неопределено)

	ЗаписьРегистра = РегистрыСведений.СтатусыСинхронизацииФайловСОблачнымСервисом.СоздатьМенеджерЗаписи();
	ЗаписьРегистра.Файл = Ссылка;
	ЗаписьРегистра.Href = Href;
	ЗаписьРегистра.Etag = Etag;
	ЗаписьРегистра.УникальныйИдентификатор1С = Ссылка.УникальныйИдентификатор();
	ЗаписьРегистра.ЭтоФайл = ЭтоФайл;
	ЗаписьРегистра.ЭтоВладелецФайла = ЭтоПапка;
	ЗаписьРегистра.ВладелецФайла = ВладелецФайла;
	ЗаписьРегистра.УчетнаяЗапись = УчетнаяЗапись;
	ЗаписьРегистра.Записать(Истина);

КонецПроцедуры

// Удаляет данные о Href и Etag файла или папки в базе данных
Процедура УдалитьСерверныеДанныеСсылки(Ссылка, УчетнаяЗапись)

	НаборРегистра = РегистрыСведений.СтатусыСинхронизацииФайловСОблачнымСервисом.СоздатьНаборЗаписей();
	НаборРегистра.Отбор.Файл.Установить(Ссылка);
	НаборРегистра.Отбор.УчетнаяЗапись.Установить(УчетнаяЗапись);
	НаборРегистра.Записать(Истина);

КонецПроцедуры

// Определяет контекст xml
Функция ОпределитьКонтекстXML(ТекстXML)
	
	ЧтениеXMLТекста = Новый ЧтениеXML;
	ЧтениеXMLТекста.УстановитьСтроку(ТекстXML);
	ПостроительDOMДляXML = Новый ПостроительDOM;
	ДокументDOMДляXML = ПостроительDOMДляXML.Прочитать(ЧтениеXMLТекста);
	РазыменовательИменДляXML = Новый РазыменовательПространствИменDOM(ДокументDOMДляXML);
	Возврат Новый Структура("ДокументDOM,РазыменовательDOM", ДокументDOMДляXML, РазыменовательИменДляXML); 
	
КонецФункции

// Вычисляет выражение xpath для контекста xml
Функция ВычислитьXPath(Выражение, Контекст, УзелКонтекста = Неопределено)
	
	Возврат Контекст.ДокументDOM.ВычислитьВыражениеXPath(Выражение,?(УзелКонтекста=Неопределено,Контекст.ДокументDOM,УзелКонтекста),Контекст.РазыменовательDOM);
	
КонецФункции

// Возвращает Href, рассчитанный для строки из таблицы файлов, методом поиска всех родителей.
Функция РассчитатьHref(СтрокаФайлов,ТаблицаФайлов)
	// Рекурсивно собираем наименования
	НайденыСтрокиФайлов = ТаблицаФайлов.Найти(СтрокаФайлов.Родитель,"ФайлСсылка");
	Если НайденыСтрокиФайлов = Неопределено Тогда
		Возврат ?(ЗначениеЗаполнено(СтрокаФайлов.Наименование), КодироватьСтроку(СтрокаФайлов.Наименование,СпособКодированияСтроки.КодировкаURL)+"/","");
	Иначе
		Возврат РассчитатьHref(НайденыСтрокиФайлов,ТаблицаФайлов) + КодироватьСтроку(СтрокаФайлов.Наименование,СпособКодированияСтроки.КодировкаURL)+"/";
	КонецЕсли; 
КонецФункции

// Возвращает строку таблицы файлов по URI, при этом, учитывается возможное различное написание URI 
// (например, закодированное, относительное или абсолютное и т.п.).
Функция НайтиСтрокуПоURI(ИскомоеURI, ТаблицаСURI, КолонкаURI)

	Для каждого СтрокаТаблицы Из ТаблицаСURI Цикл
		Если ЭтоОдинаковыеПутиURI(ИскомоеURI,СтрокаТаблицы[КолонкаURI]) Тогда
			Возврат СтрокаТаблицы;
		КонецЕсли; 
	КонецЦикла; 
	
	Возврат Неопределено;
	
КонецФункции

// Вычисляется уровень строки файлов, рекурсивным алгоритмом
Функция РекурсивноУровень(СтрокаФайлов,ТаблицаФайлов) 
	
	// Равен уровню в базе или на сервере, в зависимости от того, где он меньше
	НайденыСтрокиФайлов = ТаблицаФайлов.НайтиСтроки(Новый Структура("ФайлСсылка", СтрокаФайлов.Родитель));
	КоличествоПрибавления = ?(НайденыСтрокиФайлов.Количество()=0,0,1);
	Для каждого НайденнаяСтрокаФайлов Из НайденыСтрокиФайлов Цикл
		КоличествоПрибавления = КоличествоПрибавления + РекурсивноУровень(НайденнаяСтрокаФайлов,ТаблицаФайлов);
	КонецЦикла;
	
	Возврат КоличествоПрибавления;
	
КонецФункции

// Вычисляется уровень файла на сервере webdav, рекурсивным алгоритмом
Функция РекурсивноУровеньНаСервере(СтрокаФайлов,ТаблицаФайлов) 
	
	НайденыСтрокиФайлов = ТаблицаФайлов.НайтиСтроки(Новый Структура("ФайлСсылка", СтрокаФайлов.РодительСервер));
	КоличествоПрибавления = ?(НайденыСтрокиФайлов.Количество() =0, 0, 1);
	Для каждого НайденнаяСтрокаФайлов Из НайденыСтрокиФайлов Цикл
		КоличествоПрибавления = КоличествоПрибавления + РекурсивноУровеньНаСервере(НайденнаяСтрокаФайлов, ТаблицаФайлов);
	КонецЦикла;
	
	Возврат КоличествоПрибавления;
	
КонецФункции

// Вычисляет уровни всех строк таблицы файлов
Процедура ВычислитьУровеньРекурсивно(ТаблицаФайлов)
	
	Для каждого СтрокаФайлов Из ТаблицаФайлов Цикл
		// Равен уровню в базе или на сервере, в зависимости от того, где он меньше
		УровеньВБазе = РекурсивноУровень(СтрокаФайлов, ТаблицаФайлов);
		УровеньНаСервере = РекурсивноУровеньНаСервере(СтрокаФайлов, ТаблицаФайлов);
		Если УровеньНаСервере = 0 Тогда
			СтрокаФайлов.Уровень = УровеньВБазе;
			СтрокаФайлов.РодительСортировка = СтрокаФайлов.Родитель;
		Иначе
			Если УровеньВБазе <= УровеньНаСервере Тогда
				СтрокаФайлов.Уровень = УровеньВБазе;
				СтрокаФайлов.РодительСортировка = СтрокаФайлов.Родитель;
			Иначе
				СтрокаФайлов.Уровень = УровеньНаСервере;
				СтрокаФайлов.РодительСортировка = СтрокаФайлов.РодительСервер;
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры

// При изменении серверного пути к папке необходимо заменить пути к подчиненным файлам, что и делает эта процедура.
Процедура РекурсивноОбновитьСсылкиПодчиненных(СтрокаФайлов,знач ToHref,знач ToHref2,ТаблицаФайлов)

	// Меняем корневую ссылку, всегда должна быть закодирована
	СтрокаФайлов.ToHref = КодироватьСтроку(
						СтрЗаменить(
							РаскодироватьСтроку(ЗакончитьБезСлеша(СтрокаФайлов.ToHref), СпособКодированияСтроки.URLВКодировкеURL),
							РаскодироватьСтроку(ЗакончитьБезСлеша(ToHref), СпособКодированияСтроки.URLВКодировкеURL),
							РаскодироватьСтроку(ЗакончитьБезСлеша(ToHref2), СпособКодированияСтроки.URLВКодировкеURL))
						,СпособКодированияСтроки.URLВКодировкеURL);
	
	НайденныеПодчиненныеСтроки = ТаблицаФайлов.НайтиСтроки(Новый Структура("РодительСервер", СтрокаФайлов.Ссылка));
	Для каждого ПодчиненнаяСтрока Из НайденныеПодчиненныеСтроки Цикл
		РекурсивноОбновитьСсылкиПодчиненных(ПодчиненнаяСтрока,ToHref,ToHref2,ТаблицаФайлов);
	КонецЦикла; 

КонецПроцедуры

// Рекурсивно загружает перечень файлов с сервера в таблицу файлов
Процедура СкачатьДеревоФайловРекурсивно(ТекущиеСтрокиДереваФайлов, HttpАдрес, ПараметрыСинхронизации, Отказ=Ложь)

	СтруктураАдресаHTTP = СтруктураURIРаскодированная(HttpАдрес);
	АдресОблачногоСервиса = КодироватьURIПоСтруктуре(СтруктураАдресаHTTP, Ложь);
	АдресСервера = КодироватьURIПоСтруктуре(СтруктураАдресаHTTP);
	
	Попытка
		// Получаем каталог
		ЗаголовкиHTTP = Новый Соответствие;
		ЗаголовкиHTTP["User-Agent"] = "1C Enterprise 8.3";
		ЗаголовкиHTTP["Content-type"] = "text/xml";
		ЗаголовкиHTTP["Accept"] = "text/xml";
		ЗаголовкиHTTP["Depth"] = "1";
		
		ВыполнитьМетодWebdav("PROPFIND",АдресСервера,ЗаголовкиHTTP,ПараметрыСинхронизации,
						"<?xml version=""1.0"" encoding=""utf-8""?>
						|<D:propfind xmlns:D=""DAV:"" xmlns:U=""tsov.pro""><D:prop>
						|<D:getetag /><U:UID1C /><D:resourcetype />
						|<D:getlastmodified /><D:getcontentlength />
						|</D:prop></D:propfind>");
						
		КонтекстДокументаXML = ОпределитьКонтекстXML(ПараметрыСинхронизации.Ответ.ПолучитьТелоКакСтроку());
		
		РезультатXPath = ВычислитьXPath("//*[local-name()='response']", КонтекстДокументаXML);
		
		НайденныйResponse = РезультатXPath.ПолучитьСледующий();
		
		Пока НайденныйResponse <> Неопределено Цикл
			
			// Href есть всегда, иначе это критическая ошибка
			НайденныйHref = ВычислитьXPath("./*[local-name()='href']", КонтекстДокументаXML, НайденныйResponse).ПолучитьСледующий();
			Если НайденныйHref = Неопределено Тогда
				ТекстОшибки = НСтр("ru = 'Ошибка ответа от сервера: не найден HREF в %1'");
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстОшибки, АдресСервера);
			КонецЕсли; 
			
			ТекстHref = ЗакончитьБезСлеша(НачатьСлешем(НайденныйHref.ТекстовоеСодержимое));
			
			Если ЭтоОдинаковыеПутиURI(АдресОблачногоСервиса + ТекстHref, АдресСервера) Тогда
				НайденныйResponse = РезультатXPath.ПолучитьСледующий();
				Продолжить;
			КонецЕсли; 
			
			НоваяСтрокаДереваФайлов = ТекущиеСтрокиДереваФайлов.Добавить();
			// Всегда закодирована
			НоваяСтрокаДереваФайлов.Href = КодироватьСтроку(АдресОблачногоСервиса + ТекстHref, СпособКодированияСтроки.URLВКодировкеURL);
			НоваяСтрокаДереваФайлов.ИмяФайла = ИмяФайлаПоHref(НоваяСтрокаДереваФайлов.Href);
			НоваяСтрокаДереваФайлов.Etag = "";
			НоваяСтрокаДереваФайлов.UID1C = "";
			НоваяСтрокаДереваФайлов.ЭтоПапка = Неопределено;
			
			НайденныйPropstat = ВычислитьXPath("./*[local-name()='propstat'][contains(./*[local-name()='status'],'200 OK')]/*[local-name()='prop']", КонтекстДокументаXML, НайденныйResponse).ПолучитьСледующий();
			
			Если НайденныйPropstat <> Неопределено Тогда
				Для каждого ДочернийУзелPropstat Из НайденныйPropstat.ДочерниеУзлы Цикл
					Если ДочернийУзелPropstat.ЛокальноеИмя = "resourcetype" Тогда
						НоваяСтрокаДереваФайлов.ЭтоПапка = ВычислитьXPath("./*[local-name()='collection']", КонтекстДокументаXML, ДочернийУзелPropstat).ПолучитьСледующий() <> Неопределено;
					ИначеЕсли ДочернийУзелPropstat.ЛокальноеИмя = "UID1C" Тогда
						НоваяСтрокаДереваФайлов.UID1C = ДочернийУзелPropstat.ТекстовоеСодержимое;
					ИначеЕсли ДочернийУзелPropstat.ЛокальноеИмя = "getetag" Тогда
						НоваяСтрокаДереваФайлов.Etag = ДочернийУзелPropstat.ТекстовоеСодержимое;
					ИначеЕсли ДочернийУзелPropstat.ЛокальноеИмя = "getlastmodified" Тогда
						НоваяСтрокаДереваФайлов.ДатаМодификации = ДатаRFC1123(ДочернийУзелPropstat.ТекстовоеСодержимое);//UTC
					ИначеЕсли ДочернийУзелPropstat.ЛокальноеИмя = "getcontentlength" Тогда
						НоваяСтрокаДереваФайлов.Длина = Число(СтрЗаменить(ДочернийУзелPropstat.ТекстовоеСодержимое," ",""));
					КонецЕсли; 
				КонецЦикла; 
			КонецЕсли; 
			
			// Если не было UID, пробуем получить его отдельно, это нужно, например, для owncloud.
			Если НЕ ЗначениеЗаполнено(НоваяСтрокаДереваФайлов.UID1C) Тогда
				НоваяСтрокаДереваФайлов.UID1C = ПолучитьUID1C(НоваяСтрокаДереваФайлов.Href, ПараметрыСинхронизации);
			КонецЕсли;
			
			НайденныйResponse = РезультатXPath.ПолучитьСледующий();
			
		КонецЦикла;
	
	Исключение
		ЗаписатьВЖурналСобытийСинхронизацииФайлов(ОписаниеОшибки(),ПараметрыСинхронизации);
		Отказ = Истина;
	КонецПопытки; 
	
	Для каждого СтрокаДереваФайлов Из ТекущиеСтрокиДереваФайлов Цикл
		Если СтрокаДереваФайлов.ЭтоПапка = Истина Тогда
			СкачатьДеревоФайловРекурсивно(СтрокаДереваФайлов.Строки, СтрокаДереваФайлов.Href, ПараметрыСинхронизации, Отказ);
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры

// Загружает с сервера webdav новые папки и файлы, которых еще нет в базе, и отражает их в таблице файлов.
Процедура ЗагрузитьНовыеПрисоединенныеФайлы(СтрокиДереваФайлов, ТаблицаФайлов, ПараметрыСинхронизации, ОбъектВладелец = Неопределено)
	
	ПодсистемаРаботаСФайламиСуществует = ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами");
	
	Для каждого СтрокаДереваФайлов Из СтрокиДереваФайлов Цикл
		
		Если СтрокаДереваФайлов.ЭтоПапка Тогда
			// Папка определяется сначала по UID1C, если не найдена, то по старому Href, т.к. UID может теряться при редактировании, а новый Href еще не может быть найден в базе,
			// если UID потерялся при редактировали и папку переместили в другую папку (Href поменялся), то она будет загружена в новую карточку папки
			// поиск по Href оправдан, т.к. он уникален на файловом сервере для каждой папки.
			ТекущаяПапкаФайлов = Неопределено;
			// Теоретически еще можно искать файлы по Etag, но встанет вопрос дублей, поэтому дальше не ищем.
			
			Если Не ПустаяСтрока(СтрокаДереваФайлов.UID1C) Тогда
			
				Запрос = Новый Запрос;
				Запрос.Текст = 
					"ВЫБРАТЬ ПЕРВЫЕ 1
					|	СтатусыСинхронизацииФайловСОблачнымСервисом.Файл КАК Ссылка
					|ИЗ
					|	РегистрСведений.СтатусыСинхронизацииФайловСОблачнымСервисом КАК СтатусыСинхронизацииФайловСОблачнымСервисом
					|ГДЕ
					|	СтатусыСинхронизацииФайловСОблачнымСервисом.УникальныйИдентификатор1С = &УникальныйИдентификатор1С";
					
				Запрос.УстановитьПараметр("УникальныйИдентификатор1С", Новый УникальныйИдентификатор(СтрокаДереваФайлов.UID1C));
				РезультатЗапроса = Запрос.Выполнить();
				
				ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
				
				Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
					ТекущаяПапкаФайлов = ВыборкаДетальныеЗаписи;
				КонецЦикла;
				
			КонецЕсли;
			
			Если (ТекущаяПапкаФайлов = Неопределено) И (ТаблицаФайлов.Найти(СтрокаДереваФайлов.Href, "Href") = Неопределено) Тогда
				// Это новая папка на сервере - грузим ее,
				// но сначала проверим возможность хранения UID1C, и если нельзя - то папка не грузится.
				
				Если ПодсистемаРаботаСФайламиСуществует Тогда
					
					МодульРаботаСФайламиСлужебный = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебный");
					ВозможностьСозданияПапки = МодульРаботаСФайламиСлужебный.ВозможностьСозданияПапки(ОбъектВладелец);
					
					Если Не ВозможностьСозданияПапки Тогда
						Продолжить;
					КонецЕсли;
					
					Если НЕ ПроверитьВозможностьUID1C(СтрокаДереваФайлов.Href,Строка(Новый УникальныйИдентификатор), ПараметрыСинхронизации) Тогда
						ТекстСобытия = НСтр("ru = 'Невозможно сохранение дополнительных свойств файла, он не будет загружен: %1'");
						ЗаписатьВЖурналСобытийСинхронизацииФайлов(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСобытия, СтрокаДереваФайлов.ИмяФайла), ПараметрыСинхронизации);
						Продолжить;
					КонецЕсли; 
					
					Попытка
						
						МодульРаботаСФайламиСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
						ТекущаяПапкаФайлов = МодульРаботаСФайламиСлужебныйВызовСервера.СправочникиПапкиСоздатьЭлемент(СтрокаДереваФайлов.ИмяФайла, ОбъектВладелец, ПараметрыСинхронизации.АвторФайлов);
						
						СтрокаДереваФайлов.UID1C = Строка(ТекущаяПапкаФайлов.УникальныйИдентификатор());
						ОбновитьUID1CФайла(СтрокаДереваФайлов.Href,СтрокаДереваФайлов.UID1C,ПараметрыСинхронизации);
						
						НоваяСтрокаТаблицыФайлов = ТаблицаФайлов.Добавить();
						НоваяСтрокаТаблицыФайлов.ФайлСсылка = ТекущаяПапкаФайлов;
						НоваяСтрокаТаблицыФайлов.ПометкаУдаления = Ложь;
						НоваяСтрокаТаблицыФайлов.Родитель = ОбъектВладелец;
						НоваяСтрокаТаблицыФайлов.ЭтоПапка = Истина;
						НоваяСтрокаТаблицыФайлов.UID1C = СтрокаДереваФайлов.UID1C;
						НоваяСтрокаТаблицыФайлов.ЕстьВБазе = Истина;
						НоваяСтрокаТаблицыФайлов.ЕстьНаСервере = Истина;
						НоваяСтрокаТаблицыФайлов.ИзмененНаСервере = Ложь;
						НоваяСтрокаТаблицыФайлов.Изменения = ТекущаяПапкаФайлов;
						НоваяСтрокаТаблицыФайлов.Href = "";
						НоваяСтрокаТаблицыФайлов.Etag = "";
						НоваяСтрокаТаблицыФайлов.ToHref = СтрокаДереваФайлов.Href;
						НоваяСтрокаТаблицыФайлов.ToEtag = СтрокаДереваФайлов.Etag;
						НоваяСтрокаТаблицыФайлов.РодительСервер = ОбъектВладелец;
						НоваяСтрокаТаблицыФайлов.Наименование = СтрокаДереваФайлов.ИмяФайла;
						НоваяСтрокаТаблицыФайлов.НаименованиеСервер = СтрокаДереваФайлов.ИмяФайла;
						НоваяСтрокаТаблицыФайлов.Обработан = Истина;
						НоваяСтрокаТаблицыФайлов.ЭтоФайл = Истина;
						
						ЗапомнитьСерверныеДанныеСсылки(
							НоваяСтрокаТаблицыФайлов.ФайлСсылка,
							НоваяСтрокаТаблицыФайлов.ToHref,
							НоваяСтрокаТаблицыФайлов.ToEtag,
							НоваяСтрокаТаблицыФайлов.ЭтоФайл,
							НоваяСтрокаТаблицыФайлов.Родитель,
							НоваяСтрокаТаблицыФайлов.ЭтоПапка,
							ПараметрыСинхронизации.УчетнаяЗапись);
						
						ТекстСобытия = НСтр("ru = 'Загружена папка с сервера:  %1'");
						ЗаписатьВЖурналСобытийСинхронизацииФайлов(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСобытия, НоваяСтрокаТаблицыФайлов.НаименованиеСервер), ПараметрыСинхронизации);
						
					Исключение
						ЗаписатьВЖурналСобытийСинхронизацииФайлов(ОписаниеОшибки(),ПараметрыСинхронизации);
					КонецПопытки; 
				КонецЕсли;
				
			Иначе
				// Обновим ToHref
				СтараяСтрокаТаблицыФайлов = ТаблицаФайлов.Найти(ТекущаяПапкаФайлов.Ссылка, "ФайлСсылка");
				СтараяСтрокаТаблицыФайлов.ToHref = СтрокаДереваФайлов.Href;
				СтараяСтрокаТаблицыФайлов.ToEtag = СтрокаДереваФайлов.Etag;
				СтараяСтрокаТаблицыФайлов.РодительСервер = ОбъектВладелец;
				СтараяСтрокаТаблицыФайлов.НаименованиеСервер = СтрокаДереваФайлов.ИмяФайла;
				СтараяСтрокаТаблицыФайлов.ЕстьНаСервере = Истина;
				СтараяСтрокаТаблицыФайлов.ИзмененНаСервере = НЕ ЭтоОдинаковыеПутиURI(СтараяСтрокаТаблицыФайлов.ToHref,СтараяСтрокаТаблицыФайлов.Href);
			КонецЕсли; 
			// Для подчиненных строк это теперь родитель
			ЗагрузитьНовыеПрисоединенныеФайлы(СтрокаДереваФайлов.Строки, ТаблицаФайлов, ПараметрыСинхронизации, ТекущаяПапкаФайлов.Ссылка);
			
		Иначе 
			// Это файл
			// Файл определяется сначала по UID1C, если не найден, то по старому Href, т.к. UID может теряться при редактировании, а новый Href еще не может быть найден в базе,
			// если UID потерялся при редактировали и файл переместили в другую папку (Href поменялся), то он будет загружен в новую карточку файла
			// поиск по Href оправдан, т.к. он уникален на файловом сервере для каждого файла.
			
			ТекущийФайл = НайтиСтрокуПоURI(СтрокаДереваФайлов.Href, ТаблицаФайлов, "Href");
			
			Если (ТекущийФайл = Неопределено) ИЛИ (ТаблицаФайлов.Найти(ТекущийФайл.ФайлСсылка ,"ФайлСсылка") = Неопределено) Тогда
				// Это новый файл на сервере - грузим его
				Если НЕ ПроверитьВозможностьUID1C(СтрокаДереваФайлов.Href, Строка(Новый УникальныйИдентификатор), ПараметрыСинхронизации) Тогда
					ТекстСобытия = НСтр("ru = 'Невозможно сохранение дополнительных свойств файла, он не будет загружен: %1'");
					ЗаписатьВЖурналСобытийСинхронизацииФайлов(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСобытия, СтрокаДереваФайлов.ИмяФайла), ПараметрыСинхронизации);
					Продолжить;
				КонецЕсли; 
				
				Попытка
					
					ПараметрыФайла = Новый Структура;
					ПараметрыФайла.Вставить("ИмяФайла", СтрокаДереваФайлов.ИмяФайла);
					ПараметрыФайла.Вставить("Href",     СтрокаДереваФайлов.Href);
					ПараметрыФайла.Вставить("Etag",     СтрокаДереваФайлов.Etag);
					ПараметрыФайла.Вставить("ДатаМодификацииФайла", СтрокаДереваФайлов.ДатаМодификации);
					ПараметрыФайла.Вставить("ДлинаФайла", СтрокаДереваФайлов.Длина);
					ПараметрыФайла.Вставить("ДляПользователя", ПараметрыСинхронизации.АвторФайлов);
					ПараметрыФайла.Вставить("ОбъектВладелец", ОбъектВладелец);
					ПараметрыФайла.Вставить("СсылкаСуществующегоФайла", Неопределено);
					ПараметрыФайла.Вставить("ПараметрыСинхронизации", ПараметрыСинхронизации);
					ЗагрузитьФайлССервера(ПараметрыФайла);
					
				Исключение
					ЗаписатьВЖурналСобытийСинхронизацииФайлов(ОписаниеОшибки(),ПараметрыСинхронизации);
				КонецПопытки; 
				
			Иначе
				// Обновим ToHref
				СтараяСтрокаТаблицыФайлов = ТаблицаФайлов.Найти(ТекущийФайл.ФайлСсылка,"ФайлСсылка");
				СтараяСтрокаТаблицыФайлов.ToHref = СтрокаДереваФайлов.Href;
				СтараяСтрокаТаблицыФайлов.ToEtag = СтрокаДереваФайлов.Etag;
				СтараяСтрокаТаблицыФайлов.РодительСервер = ОбъектВладелец;
				СтараяСтрокаТаблицыФайлов.НаименованиеСервер = СтрокаДереваФайлов.ИмяФайла;
				СтараяСтрокаТаблицыФайлов.ЕстьНаСервере = Истина;
				СтараяСтрокаТаблицыФайлов.ИзмененНаСервере = НЕ ЭтоОдинаковыеПутиURI(СтараяСтрокаТаблицыФайлов.ToHref,СтараяСтрокаТаблицыФайлов.Href);
			КонецЕсли; 
			
		КонецЕсли; 
		
	КонецЦикла; 
	
КонецПроцедуры

Процедура ЗаполнитьДанныеИзОблачногоСервиса(СтрокиДереваФайлов, ТаблицаФайлов, ПараметрыСинхронизации, ОбъектВладелец = Неопределено)
	
	ПодсистемаРаботаСФайламиСуществует = ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами");
	
	Для каждого СтрокаДереваФайлов Из СтрокиДереваФайлов Цикл
		
		Если СтрокаДереваФайлов.ЭтоПапка = Истина Тогда //папки
			// Папка определяется сначала по UID1C, если не найдена, то по старому Href, т.к. UID может теряться при редактировании, а новый Href еще не может быть найден в базе,
			// если UID потерялся при редактировали и папку переместили в другую папку (Href поменялся), то она будет загружена в новую карточку папки
			// поиск по Href оправдан, т.к. он уникален на файловом сервере для каждой папки.
			ТекущаяПапкаФайлов = Неопределено;
			// Теоретически еще можно искать файлы по Etag, но встанет вопрос дублей, поэтому дальше не ищем.
			
			Если Не ПустаяСтрока(СтрокаДереваФайлов.UID1C) Тогда
			
				Запрос = Новый Запрос;
				Запрос.Текст = 
					"ВЫБРАТЬ
					|	СтатусыСинхронизацииФайловСОблачнымСервисом.Файл
					|ИЗ
					|	РегистрСведений.СтатусыСинхронизацииФайловСОблачнымСервисом КАК СтатусыСинхронизацииФайловСОблачнымСервисом
					|ГДЕ
					|	СтатусыСинхронизацииФайловСОблачнымСервисом.УникальныйИдентификатор1С = &УникальныйИдентификатор1С";
					
				Запрос.УстановитьПараметр("УникальныйИдентификатор1С", Новый УникальныйИдентификатор(СтрокаДереваФайлов.UID1C));
				
				РезультатЗапроса = Запрос.Выполнить();
				
				ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
				
				
				Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
					ТекущаяПапкаФайлов = ВыборкаДетальныеЗаписи.Файл;
				КонецЦикла;
				
			КонецЕсли;
			
			Если ТекущаяПапкаФайлов = Неопределено Тогда
				ТекущаяПапкаФайлов = НайтиСтрокуПоURI(СтрокаДереваФайлов.Href, ТаблицаФайлов,"Href");// может быть помечена на удаление, тогда у нее нет Href, и тут она не будет найдена
			КонецЕсли; 
			
			Если (ТекущаяПапкаФайлов <> Неопределено) ИЛИ (ТаблицаФайлов.Найти(ТекущаяПапкаФайлов.Ссылка,"ФайлСсылка") <> Неопределено) Тогда
				СтараяСтрокаТаблицыФайлов = ТаблицаФайлов.Найти(ТекущаяПапкаФайлов.Ссылка, "ФайлСсылка");
				СтараяСтрокаТаблицыФайлов.ToHref = СтрокаДереваФайлов.Href;
				СтараяСтрокаТаблицыФайлов.ToEtag = СтрокаДереваФайлов.Etag;
				СтараяСтрокаТаблицыФайлов.РодительСервер = ОбъектВладелец;
				СтараяСтрокаТаблицыФайлов.НаименованиеСервер = СтрокаДереваФайлов.ИмяФайла;
				СтараяСтрокаТаблицыФайлов.ЕстьНаСервере = Истина;
				СтараяСтрокаТаблицыФайлов.ИзмененНаСервере = НЕ ЭтоОдинаковыеПутиURI(СтараяСтрокаТаблицыФайлов.ToHref,СтараяСтрокаТаблицыФайлов.Href);
			КонецЕсли; 
			// Для подчиненных строк это теперь родитель
			ЗаполнитьДанныеИзОблачногоСервиса(СтрокаДереваФайлов.Строки, ТаблицаФайлов, ПараметрыСинхронизации, ТекущаяПапкаФайлов.Ссылка);
			
		Иначе 
			// Это файл
			// Файл определяется сначала по UID1C, если не найден, то по старому Href, т.к. UID может теряться при редактировании, а новый Href еще не может быть найден в базе,
			// если UID потерялся при редактировали и файл переместили в другую папку (Href поменялся), то он будет загружен в новую карточку файла
			// поиск по Href оправдан, т.к. он уникален на файловом сервере для каждого файла.
			
			ТекущийФайл = НайтиСтрокуПоURI(СтрокаДереваФайлов.Href,ТаблицаФайлов,"Href");
			
			Если (ТекущийФайл <> Неопределено) ИЛИ (ТаблицаФайлов.Найти(ТекущийФайл.ФайлСсылка,"ФайлСсылка") <> Неопределено) Тогда
				// Обновим ToHref
				СтараяСтрокаТаблицыФайлов = ТаблицаФайлов.Найти(ТекущийФайл.ФайлСсылка,"ФайлСсылка");
				СтараяСтрокаТаблицыФайлов.ToHref = СтрокаДереваФайлов.Href;
				СтараяСтрокаТаблицыФайлов.ToEtag = СтрокаДереваФайлов.Etag;
				СтараяСтрокаТаблицыФайлов.РодительСервер = ОбъектВладелец;
				СтараяСтрокаТаблицыФайлов.НаименованиеСервер = СтрокаДереваФайлов.ИмяФайла;
				СтараяСтрокаТаблицыФайлов.ЕстьНаСервере = Истина;
				СтараяСтрокаТаблицыФайлов.ИзмененНаСервере = НЕ ЭтоОдинаковыеПутиURI(СтараяСтрокаТаблицыФайлов.ToHref,СтараяСтрокаТаблицыФайлов.Href);
			КонецЕсли; 
			
		КонецЕсли; 
		
	КонецЦикла; 
	
КонецПроцедуры

// Подготавливает структуру обмена, содержащую значения на время сеанса обмена
Функция ОсновныеОбъектыСинхронизации(УчетнаяЗапись)

	СтруктураВозврата = Новый Структура("СтруктураАдресаСервера, Ответ, Логин, Пароль");
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	УчетныеЗаписиСинхронизацииФайлов.Ссылка КАК УчетнаяЗапись,
	               |	УчетныеЗаписиСинхронизацииФайлов.Сервис КАК АдресСервера,
	               |	УчетныеЗаписиСинхронизацииФайлов.КорневаяПапка,
	               |	УчетныеЗаписиСинхронизацииФайлов.АвторФайлов
	               |ИЗ
	               |	Справочник.УчетныеЗаписиСинхронизацииФайлов КАК УчетныеЗаписиСинхронизацииФайлов
	               |ГДЕ
	               |	УчетныеЗаписиСинхронизацииФайлов.Ссылка = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка", УчетнаяЗапись);
	
	Результат = Запрос.Выполнить().Выгрузить();
	
	Если Результат.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Для каждого КолонкаРезультата Из Результат.Колонки Цикл
		СтруктураВозврата.Вставить(КолонкаРезультата.Имя,Результат[0][КолонкаРезультата.Имя]);
	КонецЦикла; 
	
	Если Не ПустаяСтрока(СтруктураВозврата.КорневаяПапка) Тогда
		СтруктураВозврата.АдресСервера = СтруктураВозврата.АдресСервера + "/" + СтруктураВозврата.КорневаяПапка;
	КонецЕсли;
	
	Если ПустаяСтрока(СтруктураВозврата.АвторФайлов) Тогда
		СтруктураВозврата.АвторФайлов = УчетнаяЗапись;
	КонецЕсли;
	
	СтруктураВозврата.СтруктураАдресаСервера = СтруктураURIРаскодированная(СтруктураВозврата.АдресСервера);
	
	УстановитьПривилегированныйРежим(Истина);
	СтруктураВозврата.Логин =  ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(УчетнаяЗапись, "Логин");
	СтруктураВозврата.Пароль = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(УчетнаяЗапись);
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат СтруктураВозврата;

КонецФункции

Процедура СинхронизироватьФайлыСОблачнымСервисом(УчетнаяЗапись)
	
	ПараметрыСинхронизации = ОсновныеОбъектыСинхронизации(УчетнаяЗапись);
	
	Если ПараметрыСинхронизации = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	АдресОблачногоСервиса = КодироватьURIПоСтруктуре(ПараметрыСинхронизации.СтруктураАдресаСервера, Ложь);
	АдресСервера = КодироватьURIПоСтруктуре(ПараметрыСинхронизации.СтруктураАдресаСервера);
	
	ТекстСобытия = НСтр("ru = 'Начало синхронизации файлов с облачным сервисом.'");
	ЗаписатьВЖурналСобытийСинхронизацииФайлов(ТекстСобытия, ПараметрыСинхронизации);
	
	Попытка
		
		ДеревоФайловСервера = Новый ДеревоЗначений;
		ДеревоФайловСервера.Колонки.Добавить("Href");
		ДеревоФайловСервера.Колонки.Добавить("UID1C");
		ДеревоФайловСервера.Колонки.Добавить("Etag");
		ДеревоФайловСервера.Колонки.Добавить("ИмяФайла");
		ДеревоФайловСервера.Колонки.Добавить("ЭтоПапка");
		ДеревоФайловСервера.Колонки.Добавить("ДатаМодификации");
		ДеревоФайловСервера.Колонки.Добавить("Длина");
		
		Отказ = Ложь;
		СкачатьДеревоФайловРекурсивно(ДеревоФайловСервера.Строки, АдресСервера, ПараметрыСинхронизации, Отказ);
		Если Отказ = Истина Тогда
			ТекстОшибки = НСтр("ru = 'При загрузке структуры файлов с сервера произошла ошибка, синхронизация не выполнена.'");
			ВызватьИсключение ТекстОшибки;
		КонецЕсли; 
		
		// Сравниваем с деревом файлов в системе, синхронизация идет по уникальному идентификатору.
		МассивИсключений = Новый Массив;
		ТаблицаФайлов = ВыбратьДанныеПоПравилам(УчетнаяЗапись, МассивИсключений);
		
		Для каждого СтрокаТаблицы Из ТаблицаФайлов Цикл
			СтрокаТаблицы.UID1C = Строка(СтрокаТаблицы.ФайлСсылка.УникальныйИдентификатор());
		КонецЦикла;
		
		// Перебираем дерево, загружаем и добавляем те, которых нет в базе, в таблицу, а по старым заполняем реквизиты с сервера.
		ЗагрузитьНовыеПрисоединенныеФайлы(ДеревоФайловСервера.Строки, ТаблицаФайлов, ПараметрыСинхронизации);
		
		ВычислитьУровеньРекурсивно(ТаблицаФайлов);
		ТаблицаФайлов.Сортировать("ЭтоПапка УБЫВ, Уровень, РодительСортировка");
		// Перебираем таблицу и решаем что делать с файлами и папками.
		Для Каждого СтрокаТаблицы Из ТаблицаФайлов Цикл

			Если СтрокаТаблицы.Обработан Тогда
				Продолжить;
			КонецЕсли; 
			
			ОбновитьСтатусСинхронизацииФайла = Ложь;
			
			СозданНовыйВБазе = (НЕ ЗначениеЗаполнено(СтрокаТаблицы.Href)) И (НЕ ЗначениеЗаполнено(СтрокаТаблицы.ToHref));
			
			ИзмененВБазе = ЗначениеЗаполнено(СтрокаТаблицы.Изменения);// что-то поменялось
			ИзмененоСодержимоеНаСервере = ЗначениеЗаполнено(СтрокаТаблицы.Etag) И ЗначениеЗаполнено(СтрокаТаблицы.ToEtag) И (СтрокаТаблицы.Etag <> СтрокаТаблицы.ToEtag);// поменялось содержимое
			ИзмененНаСервере = ИзмененоСодержимоеНаСервере ИЛИ СтрокаТаблицы.ИзмененНаСервере;// поменялось имя/подчиненность или содержание
			
			УдаленВБазе = СтрокаТаблицы.ПометкаУдаления;
			УдаленНаСервере = ЗначениеЗаполнено(СтрокаТаблицы.Href) И НЕ ЗначениеЗаполнено(СтрокаТаблицы.ToHref);
			
			НачатьТранзакцию();
			
			Попытка
				
				Если СозданНовыйВБазе И НЕ УдаленВБазе Тогда
					
					// отправим новый на сервер
					СтрокаТаблицы.ToHref = ЗакончитьБезСлеша(АдресСервера) + НачатьСлешем(ЗакончитьБезСлеша(РассчитатьHref(СтрокаТаблицы,ТаблицаФайлов)));
					Если СтрокаТаблицы.ЭтоПапка Тогда
						ВызватьМетодMKCOL(СтрокаТаблицы.ToHref, ПараметрыСинхронизации);
					Иначе
						СтрокаТаблицы.ToEtag = ВызватьМетодPUT(СтрокаТаблицы.ToHref, СтрокаТаблицы.ФайлСсылка, ПараметрыСинхронизации, СтрокаТаблицы.ЭтоФайл);
					КонецЕсли; 
					ОбновитьUID1CФайла(СтрокаТаблицы.ToHref, СтрокаТаблицы.UID1C, ПараметрыСинхронизации);
					СтрокаТаблицы.РодительСервер = СтрокаТаблицы.Родитель;
					СтрокаТаблицы.НаименованиеСервер = СтрокаТаблицы.Наименование;
					СтрокаТаблицы.ЕстьНаСервере = Истина;
					СтрокаТаблицы.Обработан = Истина;
					
					Если Не СтрокаТаблицы.ЭтоФайл
						И Не СтрокаТаблицы.ЭтоПапка Тогда
						Если ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СтрокаТаблицы.ФайлСсылка, "Редактирует") <> ПараметрыСинхронизации.АвторФайлов Тогда
							МодульПрисоединенныеФайлыСлужебный = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлыСлужебный");
							МодульПрисоединенныеФайлыСлужебный.ЗанятьФайлДляРедактированияСервер(СтрокаТаблицы.ФайлСсылка, ПараметрыСинхронизации.АвторФайлов);
						КонецЕсли;
					ИначеЕсли Не СтрокаТаблицы.ЭтоПапка Тогда
						МодульРаботаСФайламиСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
						ДанныеФайла = МодульРаботаСФайламиСлужебныйВызовСервера.ДанныеФайла(СтрокаТаблицы.ФайлСсылка);
						МодульРаботаСФайламиСлужебныйВызовСервера.ЗанятьФайл(ДанныеФайла, , , ПараметрыСинхронизации.АвторФайлов);
					КонецЕсли;
					
					ТекстСобытия = НСтр("ru = 'Создан объект в облачном сервисе %1'");
					ЗаписатьВЖурналСобытийСинхронизацииФайлов(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСобытия, СтрокаТаблицы.Наименование), ПараметрыСинхронизации);
					
					ОбновитьСтатусСинхронизацииФайла = Истина;
					
				ИначеЕсли УдаленНаСервере И НЕ УдаленВБазе Тогда
					
					Если Не ЗначениеЗаполнено(СтрокаТаблицы.ФайлСсылка) Тогда
						Продолжить;
					КонецЕсли;
					
					// Если это элемент справочника ИдентификаторыОбъектовМетаданных, то не удаляем.
					Если ТипЗнч(СтрокаТаблицы.ФайлСсылка) = Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных") Тогда
						СтрокаТаблицы.Обработан = Истина;
						Продолжить;
					КонецЕсли;
					// удаляем в базе
					СтрокаТаблицы.ФайлСсылка.ПолучитьОбъект().УстановитьПометкуУдаления(Истина,Ложь);
					СтрокаТаблицы.ПометкаУдаления = Истина;
					СтрокаТаблицы.Изменения = СтрокаТаблицы.ФайлСсылка;
					СтрокаТаблицы.Обработан = Истина;
					
					ТекстСобытия = НСтр("ru = 'Удалено в базе: %1'");
					ЗаписатьВЖурналСобытийСинхронизацииФайлов(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСобытия, СтрокаТаблицы.Наименование), ПараметрыСинхронизации);
					
					ОбновитьСтатусСинхронизацииФайла = Истина;
					
				ИначеЕсли (ИзмененВБазе ИЛИ ИзмененНаСервере) И НЕ (УдаленВБазе ИЛИ УдаленНаСервере) Тогда
					
					Если ИзмененНаСервере И НЕ ИзмененВБазе Тогда
						// загрузим с сервера
						Если СтрокаТаблицы.ЭтоПапка Тогда
							// Возможно можно отследить переименование 
							ОбъектСтрокиТаблицы = СтрокаТаблицы.ФайлСсылка.ПолучитьОбъект();
							ОбъектСтрокиТаблицы.Наименование = СтрокаТаблицы.НаименованиеСервер;
							ОбъектСтрокиТаблицы.Родитель = Неопределено;
							ОбъектСтрокиТаблицы.ПометкаУдаления = Ложь;
							ОбъектСтрокиТаблицы.Записать();
							
							СтрокаТаблицы.Наименование = СтрокаТаблицы.НаименованиеСервер;
							СтрокаТаблицы.Изменения = СтрокаТаблицы.ФайлСсылка;
							СтрокаТаблицы.Родитель = СтрокаТаблицы.РодительСервер;
							СтрокаТаблицы.ПометкаУдаления = Ложь;
							
							ОбновитьСтатусСинхронизацииФайла = Истина;
						Иначе
							
							СтруктураИмениФайла = Новый Файл(СтрокаТаблицы.НаименованиеСервер);
							НовоеРасширениеФайла = ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(СтруктураИмениФайла.Расширение);
							// Загружаем только если поменялось содержимое, т.е. Etag, иначе обновляем реквизиты.
							Если СтрокаТаблицы.ЭтоФайл Тогда
								Если ИзмененоСодержимоеНаСервере ИЛИ (НовоеРасширениеФайла <> СтрокаТаблицы.ФайлСсылка.ТекущаяВерсияРасширение) Тогда
									
									ПараметрыФайла = Новый Структура;
									ПараметрыФайла.Вставить("ИмяФайла", СтрокаТаблицы.НаименованиеСервер);
									ПараметрыФайла.Вставить("Href",     СтрокаТаблицы.ToHref);
									ПараметрыФайла.Вставить("Etag",     СтрокаТаблицы.ToEtag);
									ПараметрыФайла.Вставить("ДатаМодификацииФайла", Неопределено);
									ПараметрыФайла.Вставить("ДлинаФайла", Неопределено);
									ПараметрыФайла.Вставить("ДляПользователя", ПараметрыСинхронизации.АвторФайлов);
									ПараметрыФайла.Вставить("ОбъектВладелец", СтрокаТаблицы.Родитель);
									ПараметрыФайла.Вставить("СсылкаСуществующегоФайла", СтрокаТаблицы.ФайлСсылка);
									ПараметрыФайла.Вставить("ПараметрыСинхронизации", ПараметрыСинхронизации);
									
									ЗагрузитьФайлССервера(ПараметрыФайла, СтрокаТаблицы.ЭтоФайл);
									
								КонецЕсли;
							Иначе
								Если ИзмененоСодержимоеНаСервере ИЛИ (НовоеРасширениеФайла <> СтрокаТаблицы.ФайлСсылка.Расширение) Тогда
									
									ПараметрыФайла = Новый Структура;
									ПараметрыФайла.Вставить("ИмяФайла", СтрокаТаблицы.НаименованиеСервер);
									ПараметрыФайла.Вставить("Href",     СтрокаТаблицы.ToHref);
									ПараметрыФайла.Вставить("Etag",     СтрокаТаблицы.ToEtag);
									ПараметрыФайла.Вставить("ЭтоФайл",  СтрокаТаблицы.ЭтоФайл);
									ПараметрыФайла.Вставить("ДатаМодификацииФайла", Неопределено);
									ПараметрыФайла.Вставить("ДлинаФайла", Неопределено);
									ПараметрыФайла.Вставить("ДляПользователя", ПараметрыСинхронизации.АвторФайлов);
									ПараметрыФайла.Вставить("ОбъектВладелец", СтрокаТаблицы.Родитель);
									ПараметрыФайла.Вставить("СсылкаСуществующегоФайла", СтрокаТаблицы.ФайлСсылка);
									ПараметрыФайла.Вставить("ПараметрыСинхронизации", ПараметрыСинхронизации);
									
									ЗагрузитьФайлССервера(ПараметрыФайла, СтрокаТаблицы.ЭтоФайл);
									
								КонецЕсли;
							КонецЕсли;
							
							ОбъектСтрокиТаблицы = СтрокаТаблицы.ФайлСсылка.ПолучитьОбъект();
							Если СтрокаТаблицы.ЭтоФайл Тогда
								ОбъектСтрокиТаблицы.ПолноеНаименование = СтруктураИмениФайла.ИмяБезРасширения;
							Иначе
								ОбъектСтрокиТаблицы.Наименование = СтруктураИмениФайла.ИмяБезРасширения;
							КонецЕсли;
							ОбъектСтрокиТаблицы.ВладелецФайла = СтрокаТаблицы.РодительСервер;
							ОбъектСтрокиТаблицы.ПометкаУдаления = Ложь;
							ОбъектСтрокиТаблицы.Записать();
							
							СтрокаТаблицы.Наименование = СтрокаТаблицы.НаименованиеСервер;
							СтрокаТаблицы.Изменения = СтрокаТаблицы.ФайлСсылка;
							СтрокаТаблицы.Родитель = СтрокаТаблицы.РодительСервер;
							СтрокаТаблицы.ПометкаУдаления = Ложь;
							
						КонецЕсли;
						
						СтрокаТаблицы.Обработан = Истина;
						ТекстСобытия = НСтр("ru = 'Обновлен объект в базе: %1'");
						ЗаписатьВЖурналСобытийСинхронизацииФайлов(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСобытия, СтрокаТаблицы.Наименование), ПараметрыСинхронизации);
						
						ОбновитьСтатусСинхронизацииФайла = Истина; 
						
					КонецЕсли;
					
				КонецЕсли;
				
				Если ОбновитьСтатусСинхронизацииФайла Тогда
					// Записываем обновления в регистр сведений статусов
					Если СтрокаТаблицы.ПометкаУдаления Тогда
						// Удаляем последний Href, чтобы повторно не идентифицировать
						УдалитьСерверныеДанныеСсылки(СтрокаТаблицы.ФайлСсылка, УчетнаяЗапись);
					Иначе
						ЗапомнитьСерверныеДанныеСсылки(
						СтрокаТаблицы.ФайлСсылка,
						СтрокаТаблицы.ToHref,
						СтрокаТаблицы.ToEtag,
						СтрокаТаблицы.ЭтоФайл,
						СтрокаТаблицы.Родитель,
						СтрокаТаблицы.ЭтоПапка,
						УчетнаяЗапись);
					КонецЕсли;
				КонецЕсли;
				
				ЗафиксироватьТранзакцию();
				
			Исключение
				ЗаписатьВЖурналСобытийСинхронизацииФайлов(ОписаниеОшибки(),ПараметрыСинхронизации);
				ОтменитьТранзакцию();
			КонецПопытки;
			
		КонецЦикла;
		
	Исключение
		ЗаписатьВЖурналСобытийСинхронизацииФайлов(ОписаниеОшибки(),ПараметрыСинхронизации);
	КонецПопытки; 
	
	ТекстСобытия = НСтр("ru = 'Завершена синхронизация файлов с облачным сервисом'");
	ЗаписатьВЖурналСобытийСинхронизацииФайлов(ТекстСобытия, ПараметрыСинхронизации);

КонецПроцедуры

Функция ВыбратьДанныеПоПравилам(УчетнаяЗапись, МассивИсключений)
	
	ЗапросНастройкиСинхронизации = Новый Запрос;
	ЗапросНастройкиСинхронизации.Текст = "ВЫБРАТЬ
	                                     |	НастройкиСинхронизацииФайлов.ВладелецФайла,
	                                     |	НастройкиСинхронизацииФайлов.ТипВладельцаФайла,
	                                     |	ИдентификаторыОбъектовМетаданных.Ссылка КАК ИдентификаторВладельца,
	                                     |	ВЫБОР
	                                     |		КОГДА ТИПЗНАЧЕНИЯ(ИдентификаторыОбъектовМетаданных.Ссылка) <> ТИПЗНАЧЕНИЯ(НастройкиСинхронизацииФайлов.ВладелецФайла)
	                                     |			ТОГДА ИСТИНА
	                                     |		ИНАЧЕ ЛОЖЬ
	                                     |	КОНЕЦ КАК ЭтоНастройкаДляЭлементаСправочника,
	                                     |	НастройкиСинхронизацииФайлов.ПравилоОтбора,
	                                     |	НастройкиСинхронизацииФайлов.ЭтоФайл,
	                                     |	НастройкиСинхронизацииФайлов.УчетнаяЗапись
	                                     |ИЗ
	                                     |	РегистрСведений.НастройкиСинхронизацииФайлов КАК НастройкиСинхронизацииФайлов
	                                     |		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовМетаданных КАК ИдентификаторыОбъектовМетаданных
	                                     |		ПО (ТИПЗНАЧЕНИЯ(НастройкиСинхронизацииФайлов.ВладелецФайла) = ТИПЗНАЧЕНИЯ(ИдентификаторыОбъектовМетаданных.ЗначениеПустойСсылки))
	                                     |ГДЕ
	                                     |	НастройкиСинхронизацииФайлов.Синхронизировать
	                                     |	И НастройкиСинхронизацииФайлов.УчетнаяЗапись = &УчетнаяЗапись";
	ЗапросНастройкиСинхронизации.УстановитьПараметр("УчетнаяЗапись", УчетнаяЗапись);
	НастройкиСинхронизации = ЗапросНастройкиСинхронизации.Выполнить().Выгрузить();
	
	ТаблицаФайлов = Неопределено;
	
	Для Каждого Настройка Из НастройкиСинхронизации Цикл
		ДеревоФайлов = ВыбратьДанныеПоПравилуСинхронизации(Настройка, МассивИсключений);
		Если ТаблицаФайлов = Неопределено Тогда
			ТаблицаФайлов = Новый ТаблицаЗначений;
			Для Каждого Колонка Из ДеревоФайлов.Колонки Цикл
				ТаблицаФайлов.Колонки.Добавить(Колонка.Имя);
			КонецЦикла;
		КонецЕсли;
		
		Если Настройка.ЭтоНастройкаДляЭлементаСправочника Тогда
			КорневаяПапка = Настройка.ИдентификаторВладельца;
		Иначе
			КорневаяПапка = Настройка.ВладелецФайла;
		КонецЕсли;
		
		Для Каждого СтрокаФайлов Из ДеревоФайлов.Строки Цикл
			НоваяСтрока = ТаблицаФайлов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаФайлов);
			Если НоваяСтрока.ФайлСсылка = Неопределено Тогда
				НоваяСтрока.ФайлСсылка = КорневаяПапка;
			КонецЕсли;
			Если НоваяСтрока.Родитель = Неопределено Тогда
				НоваяСтрока.Родитель = КорневаяПапка;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ВЫБОР
		|		КОГДА ТИПЗНАЧЕНИЯ(НастройкиСинхронизацииФайлов.ВладелецФайла) = ТИП(Справочник.ИдентификаторыОбъектовМетаданных)
		|			ТОГДА НастройкиСинхронизацииФайлов.ВладелецФайла
		|		ИНАЧЕ ИдентификаторыОбъектовМетаданных.Ссылка
		|	КОНЕЦ КАК ФайлСсылка,
		|	НастройкиСинхронизацииФайлов.ЭтоФайл КАК ЭтоФайл,
		|	НастройкиСинхронизацииФайлов.УчетнаяЗапись КАК УчетнаяЗапись,
		|	НастройкиСинхронизацииФайлов.ВладелецФайла КАК ВладелецФайла,
		|	НастройкиСинхронизацииФайлов.ТипВладельцаФайла КАК ТипВладельцаФайла
		|ПОМЕСТИТЬ ВТВиртуальныеКорневыеПапки
		|ИЗ
		|	РегистрСведений.НастройкиСинхронизацииФайлов КАК НастройкиСинхронизацииФайлов
		|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовМетаданных КАК ИдентификаторыОбъектовМетаданных
		|		ПО (ТИПЗНАЧЕНИЯ(НастройкиСинхронизацииФайлов.ВладелецФайла) = ТИПЗНАЧЕНИЯ(ИдентификаторыОбъектовМетаданных.ЗначениеПустойСсылки))
		|ГДЕ
		|	НастройкиСинхронизацииФайлов.Синхронизировать
		|	И НастройкиСинхронизацииФайлов.УчетнаяЗапись = &УчетнаяЗапись
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	УчетнаяЗапись
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ВТВиртуальныеКорневыеПапки.ФайлСсылка КАК ФайлСсылка,
		|	ВТВиртуальныеКорневыеПапки.ЭтоФайл КАК ЭтоФайл,
		|	ЛОЖЬ КАК ПометкаУдаления,
		|	ИСТИНА КАК ЭтоПапка,
		|	ИСТИНА КАК ЕстьВБазе,
		|	ЛОЖЬ КАК ЕстьНаСервере,
		|	ЛОЖЬ КАК Обработан,
		|	ЛОЖЬ КАК ИзмененНаСервере,
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.Href КАК Href,
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.Etag КАК Etag,
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.УникальныйИдентификатор1С КАК УникальныйИдентификатор1С,
		|	ВТВиртуальныеКорневыеПапки.ВладелецФайла,
		|	ВТВиртуальныеКорневыеПапки.ТипВладельцаФайла
		|ИЗ
		|	ВТВиртуальныеКорневыеПапки КАК ВТВиртуальныеКорневыеПапки
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.СтатусыСинхронизацииФайловСОблачнымСервисом КАК СтатусыСинхронизацииФайловСОблачнымСервисом
		|		ПО ВТВиртуальныеКорневыеПапки.УчетнаяЗапись = СтатусыСинхронизацииФайловСОблачнымСервисом.УчетнаяЗапись
		|			И ВТВиртуальныеКорневыеПапки.ФайлСсылка = СтатусыСинхронизацииФайловСОблачнымСервисом.Файл
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|УНИЧТОЖИТЬ ВТВиртуальныеКорневыеПапки";
		
	Запрос.УстановитьПараметр("УчетнаяЗапись", УчетнаяЗапись);
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	МассивВиртуальныхПапок = Новый Массив;
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		Если МассивВиртуальныхПапок.Найти(ВыборкаДетальныеЗаписи.ФайлСсылка) <> Неопределено Тогда 
			Продолжить;
		КонецЕсли;
		МассивВиртуальныхПапок.Добавить(ВыборкаДетальныеЗаписи.ФайлСсылка);
		СтрокаВиртуальнойКорневойПапки = ТаблицаФайлов.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаВиртуальнойКорневойПапки, ВыборкаДетальныеЗаписи);
		СтрокаВиртуальнойКорневойПапки.Наименование = СтрЗаменить(ВыборкаДетальныеЗаписи.ФайлСсылка.Синоним, ":", "");
	КонецЦикла;
	
	Возврат ТаблицаФайлов;
	
КонецФункции

Функция ВыбратьДанныеПоПравилуСинхронизации(НастройкаСинхронизации, МассивИсключений)
	
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	
	НастройкиКомпоновщика = НастройкаСинхронизации.ПравилоОтбора.Получить();
	Если НастройкиКомпоновщика <> Неопределено Тогда
		КомпоновщикНастроек.ЗагрузитьНастройки(НастройкаСинхронизации.ПравилоОтбора.Получить());
	КонецЕсли;
	
	СхемаКомпоновкиДанных = Новый СхемаКомпоновкиДанных;
	ИсточникДанных = СхемаКомпоновкиДанных.ИсточникиДанных.Добавить();
	ИсточникДанных.Имя = "ИсточникДанных1";
	ИсточникДанных.ТипИсточникаДанных = "Local";
	
	НаборДанных = СхемаКомпоновкиДанных.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	НаборДанных.Имя = "НаборДанных1";
	НаборДанных.ИсточникДанных = ИсточникДанных.Имя;
	
	СхемаКомпоновкиДанных.ПоляИтога.Очистить();
	
	Если НастройкаСинхронизации.ЭтоНастройкаДляЭлементаСправочника Тогда
		ВладелецФайла = НастройкаСинхронизации.ИдентификаторВладельца;
		ЭлементИсключение = НастройкаСинхронизации.ВладелецФайла;
	Иначе
		ВладелецФайла = НастройкаСинхронизации.ВладелецФайла;
		ЭлементИсключение = Неопределено;
	КонецЕсли;
	
	СхемаКомпоновкиДанных.НаборыДанных[0].Запрос = ТекстЗапросаДляСинхронизацииФайлов(
		ВладелецФайла,
		НастройкаСинхронизации,
		МассивИсключений,
		ЭлементИсключение);
		
	Структура = КомпоновщикНастроек.Настройки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("ФайлСсылка");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("Наименование");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("ПометкаУдаления");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("Родитель");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("ЭтоПапка");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("ЕстьВБазе");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("ЕстьНаСервере");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("Изменения");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("Href");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("Etag");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("Обработан");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("UID1C");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("ToHref");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("ToEtag");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("РодительСервер");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("НаименованиеСервер");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("ИзмененНаСервере");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("Уровень");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("РодительСортировка");
	
	ВыбранноеПоле = Структура.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("ЭтоФайл");
	
	КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновкиДанных));
	
	Настройки = КомпоновщикНастроек.ПолучитьНастройки();
	
	Параметр = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("УчетнаяЗапись");
	Параметр.Значение = НастройкаСинхронизации.УчетнаяЗапись;
	Параметр.Использование = Истина;
	
	Если НастройкаСинхронизации.ЭтоФайл Тогда
		Параметр = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("ТипВладельца");
		Параметр.Значение = ТипЗнч(ВладелецФайла.ЗначениеПустойСсылки);
		Параметр.Использование = Истина;
	КонецЕсли;
	
	Если МассивИсключений.Количество() > 0 Тогда
		Параметр = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("МассивИсключений");
		Параметр.Значение = МассивИсключений;
		Параметр.Использование = Истина;
	КонецЕсли;
	
	Если НастройкаСинхронизации.ЭтоНастройкаДляЭлементаСправочника Тогда
		Параметр = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("ЭлементИсключение");
		Параметр.Значение = ЭлементИсключение;
		Параметр.Использование = Истина;
	КонецЕсли;
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ДеревоЗначений = Новый ДеревоЗначений;
	
	МакетКомпоновкиДанных = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, КомпоновщикНастроек.Настройки, , , Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновкиДанных);
	ПроцессорВывода.УстановитьОбъект(ДеревоЗначений);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
	
	Возврат ДеревоЗначений;
	
КонецФункции

Функция ТекстЗапросаДляСинхронизацииФайлов(ВладелецФайла, НастройкаСинхронизации, МассивИсключений, ЭлементИсключение)
	
	Если НастройкаСинхронизации.ЭтоФайл И ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		
		МодульРаботаСФайламиСлужебный = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебный");
		Возврат МодульРаботаСФайламиСлужебный.ТекстЗапросаДляСинхронизацииФайлов(ВладелецФайла, НастройкаСинхронизации, МассивИсключений, ЭлементИсключение);
		
	КонецЕсли;
	
	Если Не НастройкаСинхронизации.ЭтоФайл И ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПрисоединенныеФайлы") Тогда
		
		МодульПрисоединенныеФайлыСлужебный = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлыСлужебный");
		Возврат МодульПрисоединенныеФайлыСлужебный.ТекстЗапросаДляСинхронизацииФайлов(ВладелецФайла, НастройкаСинхронизации, МассивИсключений, ЭлементИсключение);
		
	КонецЕсли;
	
КонецФункции

Процедура РегламентнаяСинхронизацияФайловWebdav(УчетнаяЗапись = Неопределено) Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.СинхронизацияФайлов);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если УчетнаяЗапись = Неопределено Тогда
		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ РАЗЛИЧНЫЕ
		               |	УчетныеЗаписиСинхронизацииФайлов.Ссылка,
		               |	УчетныеЗаписиСинхронизацииФайлов.Сервис
		               |ИЗ
		               |	РегистрСведений.НастройкиСинхронизацииФайлов КАК НастройкиСинхронизацииФайлов
		               |		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.УчетныеЗаписиСинхронизацииФайлов КАК УчетныеЗаписиСинхронизацииФайлов
		               |		ПО НастройкиСинхронизацииФайлов.УчетнаяЗапись = УчетныеЗаписиСинхронизацииФайлов.Ссылка
		               |ГДЕ
		               |	НЕ УчетныеЗаписиСинхронизацииФайлов.ПометкаУдаления
		               |	И НастройкиСинхронизацииФайлов.Синхронизировать";
		
		Результат = Запрос.Выполнить().Выгрузить();
		Для каждого Выборка Из Результат Цикл
			Если ПустаяСтрока(Выборка.Сервис) Тогда
				Продолжить;
			КонецЕсли; 
			СинхронизироватьФайлыСОблачнымСервисом(Выборка.Ссылка);
		КонецЦикла; 
	Иначе
		СинхронизироватьФайлыСОблачнымСервисом(УчетнаяЗапись);
	КонецЕсли;
	
	ОсвободитьЗахваченныеФайлы();
	
КонецПроцедуры

Процедура ВыполнитьПроверкуПодключения(УчетнаяЗапись, РезультатПроверки) Экспорт 

	РезультатПроверки = Новый Структура("РезультатТекст,РезультатПротокол,Отказ","","",Ложь);
	
	ПараметрыСинхронизации = ОсновныеОбъектыСинхронизации(УчетнаяЗапись);
	
	АдресСервера = КодироватьURIПоСтруктуре(ПараметрыСинхронизации.СтруктураАдресаСервера);
	
	ТекстСобытия = НСтр("ru = 'Начата проверка синхронизации файлов'") + " " + УчетнаяЗапись.Наименование;
	ЗаписатьВЖурналСобытийСинхронизацииФайлов(ТекстСобытия, ПараметрыСинхронизации);
	
	ПрочитатьПараметрыКаталога(РезультатПроверки,АдресСервера, ПараметрыСинхронизации);
	
	ТекстСобытия = НСтр("ru = 'Завершена проверка синхронизации файлов'") + " " + УчетнаяЗапись.Наименование;
	ЗаписатьВЖурналСобытийСинхронизацииФайлов(ТекстСобытия, ПараметрыСинхронизации);

КонецПроцедуры

Процедура ОсвободитьЗахваченныеФайлы()
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	УчетныеЗаписиСинхронизацииФайлов.Ссылка КАК УчетнаяЗапись
		|ПОМЕСТИТЬ НеактивныеУчетныеЗаписи
		|ИЗ
		|	Справочник.УчетныеЗаписиСинхронизацииФайлов КАК УчетныеЗаписиСинхронизацииФайлов
		|ГДЕ
		|	УчетныеЗаписиСинхронизацииФайлов.ПометкаУдаления
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	УчетныеЗаписиСинхронизацииФайлов.Ссылка
		|ИЗ
		|	Справочник.УчетныеЗаписиСинхронизацииФайлов КАК УчетныеЗаписиСинхронизацииФайлов
		|ГДЕ
		|	НЕ УчетныеЗаписиСинхронизацииФайлов.ПометкаУдаления
		|	И НЕ УчетныеЗаписиСинхронизацииФайлов.Ссылка В
		|				(ВЫБРАТЬ
		|					НастройкиСинхронизацииФайлов.УчетнаяЗапись
		|				ИЗ
		|					РегистрСведений.НастройкиСинхронизацииФайлов КАК НастройкиСинхронизацииФайлов
		|				ГДЕ
		|					НастройкиСинхронизацииФайлов.Синхронизировать)
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	НеактивныеУчетныеЗаписи.УчетнаяЗапись
		|ИЗ
		|	НеактивныеУчетныеЗаписи КАК НеактивныеУчетныеЗаписи
		|ГДЕ
		|	НеактивныеУчетныеЗаписи.УчетнаяЗапись В
		|			(ВЫБРАТЬ
		|				СтатусыСинхронизацииФайловСОблачнымСервисом.УчетнаяЗапись
		|			ИЗ
		|				РегистрСведений.СтатусыСинхронизацииФайловСОблачнымСервисом КАК СтатусыСинхронизацииФайловСОблачнымСервисом)";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаУчетнаяЗапись = РезультатЗапроса.Выбрать();
	
	Пока ВыборкаУчетнаяЗапись.Следующий() Цикл
		ОсвободитьЗахваченныеФайлыУчетнойЗаписи(ВыборкаУчетнаяЗапись.УчетнаяЗапись);
	КонецЦикла;
	
КонецПроцедуры

// Освобождение файлов, захваченных учетными записями с пометкой на удаление или с отключенными настройками синхронизации.
//
Процедура ОсвободитьЗахваченныеФайлыУчетнойЗаписи(УчетнаяЗапись = Неопределено)
	
	ПараметрыСинхронизации = ОсновныеОбъектыСинхронизации(УчетнаяЗапись);
	
	Если ПараметрыСинхронизации = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	АдресОблачногоСервиса = КодироватьURIПоСтруктуре(ПараметрыСинхронизации.СтруктураАдресаСервера, Ложь);
	АдресСервера = КодироватьURIПоСтруктуре(ПараметрыСинхронизации.СтруктураАдресаСервера);
	
	ТекстСобытия = НСтр("ru = 'Начало освобождения файлов, захваченных облачным сервисом.'");
	ЗаписатьВЖурналСобытийСинхронизацииФайлов(ТекстСобытия, ПараметрыСинхронизации);
	
	Попытка
		
		ДеревоФайловСервера = Новый ДеревоЗначений;
		ДеревоФайловСервера.Колонки.Добавить("Href");
		ДеревоФайловСервера.Колонки.Добавить("UID1C");
		ДеревоФайловСервера.Колонки.Добавить("Etag");
		ДеревоФайловСервера.Колонки.Добавить("ИмяФайла");
		ДеревоФайловСервера.Колонки.Добавить("ЭтоПапка");
		ДеревоФайловСервера.Колонки.Добавить("ДатаМодификации");
		ДеревоФайловСервера.Колонки.Добавить("Длина");
		
		Отказ = Ложь;
		СкачатьДеревоФайловРекурсивно(ДеревоФайловСервера.Строки, АдресСервера, ПараметрыСинхронизации, Отказ);
		Если Отказ = Истина Тогда
			ТекстОшибки = НСтр("ru = 'При загрузке структуры файлов с сервера произошла ошибка, синхронизация не выполнена.'");
			ВызватьИсключение ТекстОшибки;
		КонецЕсли; 
		
		// Сравниваем с деревом файлов в системе, синхронизация идет по уникальному идентификатору.
		ТаблицаФайлов = ЗахваченныеФайлы(УчетнаяЗапись);
		
		// Перебираем дерево, загружаем и добавляем те, которых нет в базе, в таблицу, а по старым заполняем реквизиты с сервера.
		ЗаполнитьДанныеИзОблачногоСервиса(ДеревоФайловСервера.Строки, ТаблицаФайлов, ПараметрыСинхронизации);
		
		ВычислитьУровеньРекурсивно(ТаблицаФайлов);
		ТаблицаФайлов.Сортировать("ЭтоПапка ВОЗР, Уровень УБЫВ, РодительСортировка УБЫВ");
		// Перебираем таблицу и решаем что делать с файлами и папками.
		Для Каждого СтрокаТаблицы Из ТаблицаФайлов Цикл
			
			Если СтрокаТаблицы.Обработан Тогда
				Продолжить;
			КонецЕсли; 
			
			НачатьТранзакцию();
			
			Попытка
				
				// удаляем на сервере
				ВызватьМетодDELETE(СтрокаТаблицы.Href, ПараметрыСинхронизации);
				
				ТекстСобытия = НСтр("ru = 'Удален объект в облачном сервисе %1'");
				ЗаписатьВЖурналСобытийСинхронизацииФайлов(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСобытия, СтрокаТаблицы.НаименованиеСервер), ПараметрыСинхронизации);
				
				СтрокаТаблицы.РодительСервер = Неопределено;
				СтрокаТаблицы.НаименованиеСервер = "";
				СтрокаТаблицы.ЕстьНаСервере = Ложь;
				СтрокаТаблицы.Обработан = Истина;
				
				Если Не СтрокаТаблицы.ЭтоПапка Тогда
					
					Если Не СтрокаТаблицы.ЭтоФайл И ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПрисоединенныеФайлы") Тогда
			
						МодульПрисоединенныеФайлыСлужебный = ОбщегоНазначения.ОбщийМодуль("ПрисоединенныеФайлыСлужебный");
						МодульПрисоединенныеФайлыСлужебный.ОсвободитьФайл(СтрокаТаблицы.ФайлСсылка);
			
					КонецЕсли;
		
					Если СтрокаТаблицы.ЭтоФайл И ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
			
						МодульРаботаСФайламиСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
						МодульРаботаСФайламиСлужебныйВызовСервера.ОсвободитьФайл(СтрокаТаблицы.ФайлСсылка);
			
					КонецЕсли;
					
				КонецЕсли;
				
				// Удаляем последний Href, чтобы повторно не идентифицировать
				УдалитьСерверныеДанныеСсылки(СтрокаТаблицы.ФайлСсылка, УчетнаяЗапись);
				
				ЗафиксироватьТранзакцию();
				
			Исключение
				ЗаписатьВЖурналСобытийСинхронизацииФайлов(ОписаниеОшибки(),ПараметрыСинхронизации);
				ОтменитьТранзакцию();
			КонецПопытки;
			
		КонецЦикла;
		
	Исключение
		ЗаписатьВЖурналСобытийСинхронизацииФайлов(ОписаниеОшибки(),ПараметрыСинхронизации);
	КонецПопытки; 
	
	ТекстСобытия = НСтр("ru = 'Завершено освобождения файлов, захваченных облачным сервисом'");
	ЗаписатьВЖурналСобытийСинхронизацииФайлов(ТекстСобытия, ПараметрыСинхронизации);
	
КонецПроцедуры

Функция ОбъектЯвляетсяФайлом(ОбъектВладелец)
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		МодульРаботаСФайламиСлужебный = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебный");
		Возврат МодульРаботаСФайламиСлужебный.ОбъектЯвляетсяФайлом(ОбъектВладелец);
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция ЗахваченныеФайлы(УчетнаяЗапись)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.Файл КАК ФайлСсылка,
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.Файл.Наименование КАК Наименование,
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.Href,
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.Etag,
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.УникальныйИдентификатор1С КАК UID1C,
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.ЭтоФайл,
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.ЭтоВладелецФайла КАК ЭтоПапка,
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.ВладелецФайла КАК Родитель,
		|	ИСТИНА КАК ЕстьВБазе,
		|	ЛОЖЬ КАК ЕстьНаСервере,
		|	НЕОПРЕДЕЛЕНО КАК Изменения,
		|	ЕСТЬNULL(СтатусыСинхронизацииФайловСОблачнымСервисом.Href, """") КАК Href,
		|	ЕСТЬNULL(СтатусыСинхронизацииФайловСОблачнымСервисом.Etag, """") КАК Etag,
		|	ЛОЖЬ КАК Обработан,
		|	ВЫРАЗИТЬ("""" КАК СТРОКА(255)) КАК ToHref,
		|	ВЫРАЗИТЬ("""" КАК СТРОКА(255)) КАК ToEtag,
		|	ВЫРАЗИТЬ("""" КАК СТРОКА(255)) КАК РодительСервер,
		|	ВЫРАЗИТЬ("""" КАК СТРОКА(255)) КАК НаименованиеСервер,
		|	ЛОЖЬ КАК ИзмененНаСервере,
		|	НЕОПРЕДЕЛЕНО КАК Уровень,
		|	ВЫРАЗИТЬ("""" КАК СТРОКА(255)) КАК РодительСортировка
		|ИЗ
		|	РегистрСведений.СтатусыСинхронизацииФайловСОблачнымСервисом КАК СтатусыСинхронизацииФайловСОблачнымСервисом
		|ГДЕ
		|	СтатусыСинхронизацииФайловСОблачнымСервисом.УчетнаяЗапись = &УчетнаяЗапись";
	
	Запрос.УстановитьПараметр("УчетнаяЗапись", УчетнаяЗапись);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ЗахваченныеФайлы = РезультатЗапроса.Выгрузить();
	
	Возврат  ЗахваченныеФайлы;
	
КонецФункции

#КонецОбласти
