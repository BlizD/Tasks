////////////////////////////////////////////////////////////////////////////////
// Подсистема "Управление доступом".
// 
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

////////////////////////////////////////////////////////////////////////////////
// Объявление служебных событий, к которым можно добавлять обработчики.

// Объявляет события подсистемы УправлениеДоступом:
//
// Серверные события:
//   ПриЗаполненииВозможныхПравДляНастройкиПравОбъектов,
//   ПриЗаполненииЗависимостейПравДоступа,
//   ПриЗаполненииВидовОграниченийПравОбъектовМетаданных,
//   ПриЗаполненииВидовДоступа,
//   ПриЗаполненииПоставляемыхПрофилейГруппДоступа,
//   ПриЗаполненииИспользованияВидаДоступа,
//   ПриИзмененииНаборовЗначенийДоступа.
//
// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииСлужебныхСобытий(КлиентскиеСобытия, СерверныеСобытия) Экспорт
	
	// СЕРВЕРНЫЕ СОБЫТИЯ.
	
	// Заполняет описания возможных прав, назначаемых для объектов, указанных типов.
	// 
	// Параметры:
	//  ВозможныеПрава - ТаблицаЗначений, содержащая поля,
	//                   описание которых  см. в комментарии к функции
	//                   РегистрыСведений.НастройкиПравОбъектов.ВозможныеПрава().
	//
	// Синтаксис:
	// Процедура ПриЗаполненииВозможныхПравДляНастройкиПравОбъектов(Знач ВозможныеПрава) Экспорт
	//
	// (То же, что УправлениеДоступомПереопределяемый.ПриЗаполненииВозможныхПравДляНастройкиПравОбъектов).
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.УправлениеДоступом\ПриЗаполненииВозможныхПравДляНастройкиПравОбъектов");
	
	// Заполняет зависимости прав доступа "подчиненного" объекта, например, задачи ЗадачаИсполнителя,
	// от "ведущего" объекта, например,  бизнес-процесса Задание, которые отличаются от стандартных.
	//
	// Зависимости прав используются в стандартном шаблоне ограничения доступа для вида доступа "Объект":
	// 1) стандартно при чтении "подчиненного" объекта
	//    проверяется наличие права чтения "ведущего" объекта
	//    и проверяется отсутствие ограничения чтения "ведущего" объекта;
	// 2) стандартно при добавлении, изменении, удалении "подчиненного" объекта
	//    проверяется наличие права изменения "ведущего" объекта
	//    и проверяется отсутствие ограничения изменения "ведущего" объекта.
	//
	// Допускается только одно переназначение по сравнению со стандартным:
	// в пункте "2)" вместо проверки права изменения "ведущего" объекта установить
	// проверку права чтения "ведущего" объекта.
	//
	// Параметры:
	//  ЗависимостиПрав - ТаблицаЗначений с колонками:
	//                    - ВедущаяТаблица     - Строка, например, "БизнесПроцесс.Задание".
	//                    - ПодчиненнаяТаблица - Строка, например, "Задача.ЗадачаИсполнителя".
	//
	// Синтаксис:
	// Процедура ПриЗаполненииЗависимостейПравДоступа(ЗависимостиПрав) Экспорт
	//
	// (То же, что УправлениеДоступомПереопределяемый.ПриЗаполненииЗависимостейПравДоступа).
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.УправлениеДоступом\ПриЗаполненииЗависимостейПравДоступа");
	
	// Заполняет состав видов доступа, используемых при ограничении прав объектов метаданных.
	// Если состав видов доступа не заполнен, отчет "Права доступа" покажет некорректные сведения.
	//
	// Обязательно требуется заполнить только виды доступа, используемые
	// в шаблонах ограничения доступа явно, а виды доступа, используемые
	// в наборах значений доступа могут быть получены из текущего состояния
	// регистра сведений НаборыЗначенийДоступа.
	//
	//  Для автоматической подготовки содержимого процедуры следует
	// воспользоваться инструментами разработчика для подсистемы
	// Управление доступом.
	//
	// Параметры:
	//  Описание     - Строка, многострочная строка формата <Таблица>.<Право>.<ВидДоступа>[.Таблица объекта].
	//                 Например, Документ.ПриходнаяНакладная.Чтение.Организации
	//                           Документ.ПриходнаяНакладная.Чтение.Контрагенты
	//                           Документ.ПриходнаяНакладная.Изменение.Организации
	//                           Документ.ПриходнаяНакладная.Изменение.Контрагенты
	//                           Документ.ЭлектронныеПисьма.Чтение.Объект.Документ.ЭлектронныеПисьма
	//                           Документ.ЭлектронныеПисьма.Изменение.Объект.Документ.ЭлектронныеПисьма
	//                           Документ.Файлы.Чтение.Объект.Справочник.ПапкиФайлов
	//                           Документ.Файлы.Чтение.Объект.Документ.ЭлектронноеПисьмо
	//                           Документ.Файлы.Изменение.Объект.Справочник.ПапкиФайлов
	//                           Документ.Файлы.Изменение.Объект.Документ.ЭлектронноеПисьмо
	//                 Вид доступа Объект предопределен, как литерал. Этот вид доступа используется в
	//                 шаблонах ограничений доступа, как "ссылка" на другой объект, по которому
	//                 ограничивается текущий объект таблицы.
	//                 Когда вид доступа "Объект" задан, также требуется задать типы таблиц,
	//                 которые используются для этого вида доступа. Т.е. перечислить типы,
	//                 которые соответствуют полю, использованному в шаблоне ограничения доступа
	//                 в паре с видом доступа "Объект". При перечислении типов по виду доступа "Объект"
	//                 нужно перечислить только те типы поля, которые есть у поля
	//                 РегистрыСведений.НаборыЗначенийДоступа.Объект, остальные типы лишние.
	//
	// Синтаксис:
	// Процедура ПриЗаполненииВидовОграниченийПравОбъектовМетаданных(Описание) Экспорт
	//
	// (То же, что УправлениеДоступомПереопределяемый.ПриЗаполненииВидовОграниченийПравОбъектовМетаданных).
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.УправлениеДоступом\ПриЗаполненииВидовОграниченийПравОбъектовМетаданных");
	
	// Заполняет виды доступа, используемые в ограничениях прав доступа.
	// Виды доступа Пользователи и ВнешниеПользователи уже заполнены.
	// Их можно удалить, если они не требуются для ограничения прав доступа.
	//
	// Параметры:
	//  ВидыДоступа - ТаблицаЗначений - с колонками:
	//   * Имя                    - Строка - имя используемое в описании поставляемых
	//                                       профилей групп доступа и текстах ОДД.
	//   * Представление          - Строка - представляет вид доступа в профилях и группах доступа.
	//   * ТипЗначений            - Тип    - тип ссылки значений доступа.
	//                                       Например, Тип("СправочникСсылка.Номенклатура").
	//   * ТипГруппЗначений       - Тип    - тип ссылки групп значений доступа.
	//                                       Например, Тип("СправочникСсылка.ГруппыДоступаНоменклатуры").
	//   * НесколькоГруппЗначений - Булево - Истина указывает, что для значения доступа (Номенклатуры), можно
	//                                       выбрать несколько групп значений (Групп доступа номенклатуры).
	//
	// Синтаксис:
	// Процедура ПриЗаполненииВидовДоступа(ВидыДоступа) Экспорт
	//
	// (То же, что УправлениеДоступомПереопределяемый.ПриЗаполненииВидовДоступа).
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.УправлениеДоступом\ПриЗаполненииВидовДоступа");
	
	// Заполняет описания поставляемых профилей групп доступа и
	// переопределяет параметры обновления профилей и групп доступа.
	//
	//  Для автоматической подготовки содержимого процедуры следует
	// воспользоваться инструментами разработчика для подсистемы
	// Управление доступом.
	//
	// Параметры:
	//  ОписанияПрофилей    - Массив в который нужно добавить описания.
	//                        Пустая структура должна быть получена при помощи функции
	//                        УправлениеДоступом.НовоеОписаниеПрофиляГруппДоступа().
	//
	//  ПараметрыОбновления - Структура со свойствами:
	//
	//                        ОбновлятьИзмененныеПрофили - Булево (начальное значение Истина).
	//
	//                        ЗапретитьИзменениеПрофилей - Булево (начальное значение Истина),
	//                        если установить Ложь, тогда поставляемые профили будут открываться
	//                        в режиме ТолькоПросмотр.
	//
	//                        ОбновлятьГруппыДоступа - Булево (начальное значение Истина).
	//
	//                        ОбновлятьГруппыДоступаСУстаревшимиНастройками - Булево (начальное
	//                        значение Ложь), если установить Истина, то настройки значений,
	//                        сделанные администратором по виду доступа, который удален из
	//                        профиля, будут удалены из группы доступа.
	//
	// Синтаксис:
	// Процедура ПриЗаполненииПоставляемыхПрофилейГруппДоступа(ОписанияПрофилей, ПараметрыОбновления) Экспорт
	//
	// (То же, что УправлениеДоступомПереопределяемый.ЗаполнитьПоставляемыеПрофилиГруппДоступа).
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.УправлениеДоступом\ПриЗаполненииПоставляемыхПрофилейГруппДоступа");
	
	// Заполняет использование видов доступа в зависимости от функциональных опций конфигурации,
	// например, ИспользоватьГруппыДоступаНоменклатуры.
	//
	// Параметры:
	//  ВидДоступа    - Строка - имя вида доступа заданное в процедуре ПриЗаполненииВидовДоступа.
	//  Использование - Булево - начальное значение Истина.
	// 
	// Синтаксис:
	// Процедура ПриЗаполненииИспользованияВидаДоступа(ИмяВидаДоступа, Использование) Экспорт
	//
	// (То же, что УправлениеДоступомПереопределяемый.ПриЗаполненииИспользованияВидаДоступа).
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.УправлениеДоступом\ПриЗаполненииИспользованияВидаДоступа");
	
	// Позволяет реализовать перезапись зависимых наборов значений доступа других объектов.
	//
	//  Вызывается из процедур:
	// УправлениеДоступомСлужебный.ЗаписатьНаборыЗначенийДоступа(),
	// УправлениеДоступомСлужебный.ЗаписатьЗависимыеНаборыЗначенийДоступа().
	//
	// Параметры:
	//  Ссылка       - СправочникСсылка, ДокументСсылка, ... - ссылка на объект для которого
	//                 записаны наборы значений доступа.
	//
	//  СсылкиНаЗависимыеОбъекты - Массив элементов типа СправочникСсылка, ДокументСсылка, ...
	//                 Содержит ссылки на объекты с зависимыми наборами значений доступа.
	//                 Начальное значение - пустой массив.
	//
	// Синтаксис:
	// Процедура ПриИзмененииНаборовЗначенийДоступа(Знач Ссылка, СсылкиНаЗависимыеОбъекты) Экспорт
	//
	// (То же, что УправлениеДоступомПереопределяемый.ПриИзмененииНаборовЗначенийДоступа).
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.УправлениеДоступом\ПриИзмененииНаборовЗначенийДоступа");
	
	// Вызывается при обновлении ролей пользователя информационной базы.
	//
	// Параметры:
	//  ИдентификаторПользователяИБ - УникальныйИдентификатор,
	//  Отказ - Булево. При установке значения параметра в значение Ложь внутри обработчика события
	//    обновление ролей для этого пользователя информационной базы будет пропущено.
	//
	// Синтаксис:
	// Процедура ПриОбновленииРолейПользователяИБ(ИдентификаторПользователяИБ, Отказ) Экспорт
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.УправлениеДоступом\ПриОбновленииРолейПользователяИБ");
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Добавление обработчиков событий.

// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииОбработчиковСлужебныхСобытий(КлиентскиеОбработчики, СерверныеОбработчики) Экспорт
	
	// СЕРВЕРНЫЕ ОБРАБОТЧИКИ.
	
	СерверныеОбработчики["СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПослеОбновленияИнформационнойБазы"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииПараметровРаботыКлиента"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииИсключенийПоискаСсылок"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриОбнаруженииНеУникальностиПредопределенного"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриОтправкеДанныхГлавному"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриОтправкеДанныхПодчиненному"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриПолученииДанныхОтГлавного"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриПолученииДанныхОтПодчиненного"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПослеПолученияДанныхОтПодчиненного"].Добавить(
		"УправлениеДоступомСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПослеПолученияДанныхОтГлавного"].Добавить(
		"УправлениеДоступомСлужебный");
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ВариантыОтчетов") Тогда
		СерверныеОбработчики["СтандартныеПодсистемы.ВариантыОтчетов\ПриНастройкеВариантовОтчетов"].Добавить(
			"УправлениеДоступомСлужебный");
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.ВыгрузкаЗагрузкаДанных") Тогда
		СерверныеОбработчики[
			"ТехнологияСервиса.ВыгрузкаЗагрузкаДанных\ПриЗаполненииТиповОбщихДанныхНеТребующихСопоставлениеСсылокПриЗагрузке"].Добавить(
				"УправлениеДоступомСлужебный");
		СерверныеОбработчики[
			"ТехнологияСервиса.ВыгрузкаЗагрузкаДанных\ПриЗаполненииТиповИсключаемыхИзВыгрузкиЗагрузки"].Добавить(
				"УправлениеДоступомСлужебный");
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ТекущиеДела") Тогда
		СерверныеОбработчики["СтандартныеПодсистемы.ТекущиеДела\ПриЗаполненииСпискаТекущихДел"].Добавить(
			"Справочники.ПрофилиГруппДоступа");
	КонецЕсли;
	
КонецПроцедуры

// Определить объекты метаданных, в модулях менеджеров которых ограничивается возможность 
// редактирования реквизитов при групповом изменении.
//
// Параметры:
//   Объекты - Соответствие - в качестве ключа указать полное имя объекта метаданных,
//                            подключенного к подсистеме "Групповое изменение объектов". 
//                            Дополнительно в значении могут быть перечислены имена экспортных функций:
//                            "РеквизитыНеРедактируемыеВГрупповойОбработке",
//                            "РеквизитыРедактируемыеВГрупповойОбработке".
//                            Каждое имя должно начинаться с новой строки.
//                            Если указана пустая строка, значит в модуле менеджера определены обе функции.
//
Процедура ПриОпределенииОбъектовСРедактируемымиРеквизитами(Объекты) Экспорт
	Объекты.Вставить(Метаданные.Справочники.ГруппыДоступа.ПолноеИмя(), "РеквизитыНеРедактируемыеВГрупповойОбработке");
	Объекты.Вставить(Метаданные.Справочники.ПрофилиГруппДоступа.ПолноеИмя(), "РеквизитыНеРедактируемыеВГрупповойОбработке");
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Основные процедуры и функции.

// Добавляет пользователя в группу доступа, соответствующую поставляемому профилю.
// Группа доступа определяется по идентификатору ссылки поставляемого профиля.
// Если группа доступа не будет найдена, она будет создана.
//
// Параметры:
//  Пользователь        - СправочникСсылка.Пользователи,
//                        СправочникСсылка.ВнешниеПользователи,
//                        СправочникСсылка.ГруппыПользователей,
//                        СправочникСсылка.ГруппыВнешнихПользователей
//                        - участник, которого нужно включить в группу доступа.
// 
//  ПоставляемыйПрофиль - Строка - строка идентификатора поставляемого профиля.
//                      - СправочникСсылка.ПрофилиГруппДоступа - ссылка на профиль, который
//                        создан по описанию в модуле УправлениеДоступомПереопределяемый
//                        в процедуре ЗаполнитьПоставляемыеПрофилиГруппДоступа.
//                        Профили с непустым списком видов доступа не поддерживаются.
//                        Профиль групп доступа Администратор не поддерживается.
// 
Процедура ВключитьПользователяВГруппуДоступа(Пользователь, ПоставляемыйПрофиль) Экспорт
	
	ОбработатьСвязьПользователяСГруппойДоступа(Пользователь, ПоставляемыйПрофиль, Истина);
	
КонецПроцедуры

// Удаляет пользователя из группы доступа, соответствующей поставляемому профилю.
// Группа доступа определяется по идентификатору ссылки поставляемого профиля.
// Если группа доступа не будет найдена, никаких действий не будет выполнено.
// 
// Параметры:
//  Пользователь        - СправочникСсылка.Пользователи,
//                        СправочникСсылка.ВнешниеПользователи,
//                        СправочникСсылка.ГруппыПользователей,
//                        СправочникСсылка.ГруппыВнешнихПользователей
//                        - участник, которого нужно исключить из группы доступа.
// 
//  ПоставляемыйПрофиль - Строка - строка идентификатора поставляемого профиля.
//                      - СправочникСсылка.ПрофилиГруппДоступа - ссылка на профиль, который
//                        создан по описанию в модуле УправлениеДоступомПереопределяемый
//                        в процедуре ЗаполнитьПоставляемыеПрофилиГруппДоступа.
//                        Профили с непустым списком видов доступа не поддерживаются.
//                        Профиль групп доступа Администратор не поддерживается.
// 
Процедура ИсключитьПользователяИзГруппыДоступа(Пользователь, ПоставляемыйПрофиль) Экспорт
	
	ОбработатьСвязьПользователяСГруппойДоступа(Пользователь, ПоставляемыйПрофиль, Ложь);
	
КонецПроцедуры

// Найти пользователя в группе доступа, соответствующей поставляемому профилю.
// Группа доступа определяется по идентификатору ссылки поставляемого профиля.
// Если группа доступа не будет найдена, никаких действий не будет выполнено.
// 
// Параметры:
//  Пользователь        - СправочникСсылка.Пользователи,
//                        СправочникСсылка.ВнешниеПользователи,
//                        СправочникСсылка.ГруппыПользователей,
//                        СправочникСсылка.ГруппыВнешнихПользователей
//                        - участник, которого нужно найти в группе доступа.
// 
//  ПоставляемыйПрофиль - Строка - строка идентификатора поставляемого профиля.
//                      - СправочникСсылка.ПрофилиГруппДоступа - ссылка на профиль, который
//                        создан по описанию в модуле УправлениеДоступомПереопределяемый
//                        в процедуре ЗаполнитьПоставляемыеПрофилиГруппДоступа.
//                        Профили с непустым списком видов доступа не поддерживаются.
//                        Профиль групп доступа Администратор не поддерживается.
// 
Функция НайтиПользователяВГруппеДоступа(Пользователь, ПоставляемыйПрофиль) Экспорт
	
	Возврат ОбработатьСвязьПользователяСГруппойДоступа(Пользователь, ПоставляемыйПрофиль);
	
КонецФункции

// Устанавливает параметры сеанса по текущим настройкам констант и
// настройкам групп доступа пользователей.
//  Вызывается ПриНачалеРаботыСистемы.
//
Процедура УстановкаПараметровСеанса(ИмяПараметра, УстановленныеПараметры) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если НЕ Константы.ОграничиватьДоступНаУровнеЗаписей.Получить() Тогда
		// Для корректной работы препроцессора в ограничениях доступа, требуется инициализации всех
		// параметров сеанса, которые могут быть востребованы в работе препроцессора.
		ПараметрыСеанса.ВсеВидыДоступаКромеСпециальных             = "";
		ПараметрыСеанса.ВидыДоступаСОтключеннымИспользованием      = "";
		ПараметрыСеанса.ВидыДоступаБезГруппДляЗначенияДоступа      = "";
		ПараметрыСеанса.ВидыДоступаСОднойГруппойДляЗначенияДоступа = "";
		
		ПараметрыСеанса.ТипыЗначенийДоступаСГруппами
			= Новый ФиксированныйМассив(Новый Массив);
		
		ПараметрыСеанса.ТаблицыСОтдельнымиНастройкамиПрав          = "";
		
		ПараметрыСеанса.ИдентификаторыТаблицСОтдельнымиНастройкамиПрав
			= Новый ФиксированныйМассив(Новый Массив);
		
		ПараметрыСеанса.ТипыВладельцевНастроекПрав
			= Новый ФиксированныйМассив(Новый Массив);
		
		УстановленныеПараметры.Добавить("ВсеВидыДоступаКромеСпециальных");
		УстановленныеПараметры.Добавить("ВидыДоступаСОтключеннымИспользованием");
		УстановленныеПараметры.Добавить("ВидыДоступаБезГруппДляЗначенияДоступа");
		УстановленныеПараметры.Добавить("ВидыДоступаСОднойГруппойДляЗначенияДоступа");
		УстановленныеПараметры.Добавить("ТипыЗначенийДоступаСГруппами");
		УстановленныеПараметры.Добавить("ТаблицыСОтдельнымиНастройкамиПрав");
		УстановленныеПараметры.Добавить("ИдентификаторыТаблицСОтдельнымиНастройкамиПрав");
		УстановленныеПараметры.Добавить("ТипыВладельцевНастроекПрав");
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ТекущийПользователь", Пользователи.АвторизованныйПользователь());
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ЗначенияПоУмолчанию.ТипЗначенийДоступа КАК ТипЗначений,
	|	ЗначенияПоУмолчанию.ВсеРазрешеныБезИсключений КАК ВсеРазрешеныБезИсключений
	|ПОМЕСТИТЬ ЗначенияПоУмолчаниюДляПользователя
	|ИЗ
	|	РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
	|ГДЕ
	|	ИСТИНА В
	|			(ВЫБРАТЬ ПЕРВЫЕ 1
	|				ИСТИНА
	|			ИЗ
	|				Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|					ПО
	|						ГруппыДоступаПользователи.Ссылка = ЗначенияПоУмолчанию.ГруппаДоступа
	|							И ГруппыДоступаПользователи.Пользователь = СоставыГруппПользователей.ГруппаПользователей
	|							И СоставыГруппПользователей.Пользователь = &ТекущийПользователь)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ЗначенияПоУмолчанию.ТипЗначений
	|ИЗ
	|	ЗначенияПоУмолчаниюДляПользователя КАК ЗначенияПоУмолчанию
	|
	|СГРУППИРОВАТЬ ПО
	|	ЗначенияПоУмолчанию.ТипЗначений
	|
	|ИМЕЮЩИЕ
	|	МИНИМУМ(ЗначенияПоУмолчанию.ВсеРазрешеныБезИсключений) = ИСТИНА";
	
	ТипыЗначенийВсеРазрешеныБезИсключений = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ТипЗначений");
	
	// Установка параметров ВсеВидыДоступаКромеСпециальных, ВидыДоступаСОтключеннымИспользованием.
	ВсеВидыДоступаКромеСпециальных        = Новый Массив;
	ВидыДоступаСОтключеннымИспользованием = Новый Массив;
	
	Параметры = УправлениеДоступомСлужебныйПовтИсп.Параметры();
	
	Для каждого СвойстваВидаДоступа Из Параметры.СвойстваВидовДоступа.Массив Цикл
		ВсеВидыДоступаКромеСпециальных.Добавить(СвойстваВидаДоступа.Имя);
		
		Если НЕ ВидДоступаИспользуется(СвойстваВидаДоступа.Ссылка)
		 ИЛИ ТипыЗначенийВсеРазрешеныБезИсключений.Найти(СвойстваВидаДоступа.Ссылка) <> Неопределено Тогда
			
			ВидыДоступаСОтключеннымИспользованием.Добавить(СвойстваВидаДоступа.Имя);
		КонецЕсли;
	КонецЦикла;
	
	ПараметрыСеанса.ВсеВидыДоступаКромеСпециальных = ВсеКомбинацииВидовДоступа(ВсеВидыДоступаКромеСпециальных);
	
	УстановленныеПараметры.Добавить("ВсеВидыДоступаКромеСпециальных");
	
	ВсеВидыДоступаКромеСпециальныхОтключены = (ВсеВидыДоступаКромеСпециальных.Количество()
		= ВидыДоступаСОтключеннымИспользованием.Количество());
	
	Если ВсеВидыДоступаКромеСпециальныхОтключены Тогда
		ПараметрыСеанса.ВидыДоступаСОтключеннымИспользованием = "Все";
	Иначе
		ПараметрыСеанса.ВидыДоступаСОтключеннымИспользованием
			= ВсеКомбинацииВидовДоступа(ВидыДоступаСОтключеннымИспользованием);
	КонецЕсли;
	
	УстановленныеПараметры.Добавить("ВидыДоступаСОтключеннымИспользованием");
	
	// Установка параметров ВидыДоступаБезГруппДляЗначенияДоступа,
	// ВидыДоступаСОднойГруппойДляЗначенияДоступа, ТипыЗначенийДоступаСГруппами.
	ПараметрыСеанса.ВидыДоступаБезГруппДляЗначенияДоступа =
		ВсеКомбинацииВидовДоступа(Параметры.СвойстваВидовДоступа.БезГруппДляЗначенияДоступа);
	ПараметрыСеанса.ВидыДоступаСОднойГруппойДляЗначенияДоступа =
		ВсеКомбинацииВидовДоступа(Параметры.СвойстваВидовДоступа.СОднойГруппойДляЗначенияДоступа);
	
	ТипыЗначенийДоступаСГруппами = Новый Массив;
	Для каждого КлючИЗначение Из Параметры.СвойстваВидовДоступа.ТипыЗначенийДоступаСГруппами Цикл
		ТипыЗначенийДоступаСГруппами.Добавить(КлючИЗначение.Значение);
	КонецЦикла;
	ПараметрыСеанса.ТипыЗначенийДоступаСГруппами = Новый ФиксированныйМассив(ТипыЗначенийДоступаСГруппами);
	
	УстановленныеПараметры.Добавить("ВидыДоступаБезГруппДляЗначенияДоступа");
	УстановленныеПараметры.Добавить("ВидыДоступаСОднойГруппойДляЗначенияДоступа");
	УстановленныеПараметры.Добавить("ТипыЗначенийДоступаСГруппами");
	
	// Установка параметров ТаблицыСОтдельнымиНастройкамиПрав,
	// ИдентификаторыТаблицСОтдельнымиНастройкамиПрав, ТипыВладельцевНастроекПрав.
	ОтдельныеТаблицы = Параметры.ВозможныеПраваДляНастройкиПравОбъектов.ОтдельныеТаблицы;
	ТаблицыСОтдельнымиНастройкамиПрав = "";
	ИдентификаторыТаблицСОтдельнымиНастройкамиПрав = Новый Массив;
	Для каждого КлючИЗначение Из ОтдельныеТаблицы Цикл
		ТаблицыСОтдельнымиНастройкамиПрав = ТаблицыСОтдельнымиНастройкамиПрав
			+ "|" + КлючИЗначение.Значение + ";" + Символы.ПС;
		ИдентификаторыТаблицСОтдельнымиНастройкамиПрав.Добавить(КлючИЗначение.Ключ);
	КонецЦикла;
	
	ПараметрыСеанса.ТаблицыСОтдельнымиНастройкамиПрав = ТаблицыСОтдельнымиНастройкамиПрав;
	
	ПараметрыСеанса.ИдентификаторыТаблицСОтдельнымиНастройкамиПрав =
		Новый ФиксированныйМассив(ИдентификаторыТаблицСОтдельнымиНастройкамиПрав);
	
	ПараметрыСеанса.ТипыВладельцевНастроекПрав = Параметры.ВозможныеПраваДляНастройкиПравОбъектов.ТипыВладельцев;
	
	УстановленныеПараметры.Добавить("ТаблицыСОтдельнымиНастройкамиПрав");
	УстановленныеПараметры.Добавить("ИдентификаторыТаблицСОтдельнымиНастройкамиПрав");
	УстановленныеПараметры.Добавить("ТипыВладельцевНастроекПрав");
	
КонецПроцедуры

// Обновляет состав пользователей указанных групп исполнителей.
// 
// Требуется вызывать при изменении состава пользователей у групп исполнителей,
// например, у групп исполнителей задач.
//
// В качестве значений параметра передается группы исполнителей, состав которых изменился.
//
// Параметры:
//  ГруппыИсполнителей - Например, СправочникСсылка.ГруппыИсполнителейЗадач.
//                     - Массив значений указанных выше типов.
//                     - Неопределено - без отбора.
//
Процедура ОбновитьПользователейГруппИсполнителей(ГруппыИсполнителей = Неопределено) Экспорт
	
	Если ТипЗнч(ГруппыИсполнителей) = Тип("Массив") И ГруппыИсполнителей.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Параметры = Новый Структура;
	Параметры.Вставить("ГруппыИсполнителей", ГруппыИсполнителей);
	
	РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
	
КонецПроцедуры

// Проверяет существование вида доступа с указанным именем.
// Применяется для автоматизации условного встраивания подсистем.
// 
Функция ВидДоступаСуществует(ИмяВидаДоступа) Экспорт
	
	Возврат СвойстваВидаДоступа(ИмяВидаДоступа) <> Неопределено;
	
КонецФункции

// Возвращает вид интерфейса пользователя для настройки доступа.
Функция УпрощенныйИнтерфейсНастройкиПравДоступа() Экспорт
	
	УпрощенныйИнтерфейс = Ложь;
	УправлениеДоступомПереопределяемый.ПриОпределенииИнтерфейсаНастройкиДоступа(УпрощенныйИнтерфейс);
	
	Возврат УпрощенныйИнтерфейс = Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в эту подсистему.

// См. описание одноименной процедуры в общем модуле РегламентныеЗаданияПереопределяемый.
//
Процедура ПриОпределенииНастроекРегламентныхЗаданий(Зависимости) Экспорт
	Зависимость = Зависимости.Добавить();
	Зависимость.РегламентноеЗадание = Метаданные.РегламентныеЗадания.ЗаполнениеДанныхДляОграниченияДоступа;
	Зависимость.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.ОграничиватьДоступНаУровнеЗаписей;
КонецПроцедуры

// Возвращает соответствие имен параметров сеанса и обработчиков для их инициализации.
//
Процедура ПриДобавленииОбработчиковУстановкиПараметровСеанса(Обработчики) Экспорт
	
	Обработчики.Вставить("ВидыДоступа*",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ВсеВидыДоступаКромеСпециальных",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ТаблицыСОтдельнымиНастройкамиПрав",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ТипыЗначенийДоступаСГруппами",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ТипыВладельцевНастроекПрав",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
	Обработчики.Вставить("ИдентификаторыТаблицСОтдельнымиНастройкамиПрав",
		"УправлениеДоступомСлужебный.УстановкаПараметровСеанса");
	
КонецПроцедуры

// Вызовы из подсистемы Пользователи.

// См. одноименную процедуру в общем модуле ПользователиПереопределяемый.
Процедура ПриОпределенииНастроек(Настройки) Экспорт
	
	// Роли устанавливаются автоматически по данным групп доступа
	// через связь: ПользователиГруппыДоступа -> Профиль -> РолиПрофиля.
	Настройки.РедактированиеРолей = Ложь;
	
КонецПроцедуры

// См. одноименную процедуру в общем модуле ПользователиПереопределяемый.
Процедура ПриОпределенииНазначенияРолей(НазначениеРолей) Экспорт
	
	Для Каждого Роль Из Метаданные.Роли Цикл
		Если ЭтоПрофильнаяРоль(Роль.Имя) Тогда
			НазначениеРолей.ТолькоДляПользователейСистемы.Добавить(Роль.Имя);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// См. процедуру ИзменитьДействияВФорме в общем модуле ПользователиПереопределяемый.
Процедура ПриОпределенииДействийВФорме(Ссылка, ДействияВФорме) Экспорт
	
	ДействияВФорме.Роли = "";
	
КонецПроцедуры

// Переопределяет текст комментария при авторизации пользователя ИБ,
// созданного в конфигураторе с административными правами.
//  Вызывается из Пользователи.АвторизоватьТекущегоПользователя().
//  Комментарий записывается в журнал регистрации.
// 
// Параметры:
//  Комментарий  - Строка - начальное значение задано.
//
Процедура ПослеЗаписиАдминистратораПриАвторизации(Комментарий) Экспорт
	
	Комментарий =
		НСтр("ru = 'Выполнен запуск от имени пользователя с ролью ""Полные права"",
		           |который не зарегистрирован в списке пользователей.
		           |Выполнена автоматическая регистрация в списке пользователей.
		           |Пользователь добавлен в группу доступа Администраторы.
		           |
		           |Для ведения списка и настройки прав пользователей предназначен список Пользователи,
		           |режим конфигурирования 1С:Предприятия для этого использовать не следует.'");
	
КонецПроцедуры

// Доопределяет действия, необходимые после установки пользователя
// информационной базы у пользователя или внешнего пользователя,
// т.е. при изменении реквизита ИдентификаторПользователяИБ на не пустой.
//
// Например, можно обновить роли.
// 
// Параметры:
//  Ссылка - СправочникСсылка.Пользователи, СправочникСсылка.ВнешниеПользователи - пользователь.
//
Процедура ПослеУстановкиПользователяИБ(Ссылка, ПарольПользователяСервиса) Экспорт
	
	УправлениеДоступом.ОбновитьРолиПользователей(Ссылка, ПарольПользователяСервиса);
	
КонецПроцедуры

// Позволяет переопределить текст вопроса перед записью первого администратора.
//  Вызывается из обработчика ПередЗаписью формы пользователя.
//  Вызов выполняется если установлен ЗапретРедактированияРолей() и
// количество пользователей информационной базы равно нулю.
// 
// Параметры:
//  ТекстВопроса - Строка - текст вопроса, который можно переопределить.
//
Процедура ПриОпределенииТекстаВопросаПередЗаписьюПервогоАдминистратора(ТекстВопроса) Экспорт
	
	ТекстВопроса = НСтр("ru = 'В список пользователей программы добавляется первый пользователь,
		|поэтому он будет автоматически включен в группу доступа Администраторы. 
		|Продолжить?'")
	
КонецПроцедуры

// Доопределяет действия при создании администратора в подсистеме Пользователи.
// 
// Параметры:
//  Администратор - СправочникСсылка.Пользователи (изменение объекта запрещено).
//  Уточнение     - Строка - поясняет при каких условиях был создан администратор.
//
Процедура ПриСозданииАдминистратора(Администратор, Уточнение) Экспорт
	
	Если ТипЗнч(Администратор) <> Тип("СправочникСсылка.Пользователи") Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Пользователь", Администратор);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|ГДЕ
	|	ГруппыДоступаПользователи.Ссылка = ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.Администраторы)
	|	И ГруппыДоступаПользователи.Пользователь = &Пользователь";
	
	Если Не Запрос.Выполнить().Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	КомментарийДляЖурнала = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Пользователь ""%1"" добавлен в группу доступа Администраторы по причине:
		           |%2'"),
		Администратор,
		Уточнение);
	
	Объект = Справочники.ГруппыДоступа.Администраторы.ПолучитьОбъект();
	
	НачатьТранзакцию();
	Попытка
		ЗаблокироватьДанныеДляРедактирования(Объект.Ссылка, Объект.ВерсияДанных);
		Если Объект.Пользователи.Найти(Администратор, "Пользователь") = Неопределено Тогда
			Объект.Пользователи.Добавить().Пользователь = Администратор;
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Управление доступом.Автоматическое изменение группы доступа Администраторы'",
				     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Информация,
				Метаданные.Справочники.Пользователи,
				Администратор,
				КомментарийДляЖурнала,
				РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
		КонецЕсли;
		РазблокироватьДанныеДляРедактирования(Объект.Ссылка);
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Обновляет связь для новой группы пользователей (группы внешних пользователей).
//
// Параметры:
//  Ссылка     - СправочникСсылка.Пользователи,
//               СправочникСсылка.ГруппыПользователей,
//               СправочникСсылка.ВнешниеПользователи,
//               СправочникСсылка.ГруппыВнешнихПользователей - измененный объект.
//
//  ЭтоНовый   - Булево, если Истина, объект был добавлен, иначе изменен.
//
Процедура ПослеДобавленияИзмененияПользователяИлиГруппы(Ссылка, ЭтоНовый) Экспорт
	
	Если ЭтоНовый Тогда
		Если ТипЗнч(Ссылка) = Тип("СправочникСсылка.ГруппыПользователей")
		 ИЛИ ТипЗнч(Ссылка) = Тип("СправочникСсылка.ГруппыВнешнихПользователей") Тогда
		
			Параметры = Новый Структура;
			Параметры.Вставить("ГруппыПользователей", Ссылка);
			РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Обновляет группировки пользователей после обновления составов групп пользователей
// используемых для выполнения проверок разрешенных пользователей.
//
// Параметры:
//  УчастникиИзменений - Массив значений типов:
//                       - СправочникСсылка.Пользователи.
//                       - СправочникСсылка.ВнешниеПользователи.
//                       Пользователи которые участвовали в изменении состава групп.
//
//  ИзмененныеГруппы   - Массив значений типов:
//                       - СправочникСсылка.ГруппыПользователей.
//                       - СправочникСсылка.ГруппыВнешнихПользователей.
//                       Группы, состав которых был изменен.
//
Процедура ПослеОбновленияСоставовГруппПользователей(УчастникиИзменений, ИзмененныеГруппы) Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("Пользователи",        УчастникиИзменений);
	Параметры.Вставить("ГруппыПользователей", ИзмененныеГруппы);
	
	РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
	
	УправлениеДоступом.ОбновитьРолиПользователей(УчастникиИзменений);
	
КонецПроцедуры

// Обновляет группировки внешних пользователей по объекту авторизации.
//
// Параметры:
//  ВнешнийПользователь     - СправочникСсылка.ВнешниеПользователи - внешний пользователь.
//  СтарыйОбъектАвторизации - NULL - при добавлении внешнего пользователя.
//                          - ОпределяемыйТип.ВнешнийПользователь - тип объекта авторизации.
//  НовыйОбъектАвторизации  - ОпределяемыйТип.ВнешнийПользователь - тип объекта авторизации.
//
Процедура ПослеИзмененияОбъектаАвторизацииВнешнегоПользователя(ВнешнийПользователь,
                                                               СтарыйОбъектАвторизации,
                                                               НовыйОбъектАвторизации) Экспорт
	
	ОбъектыАвторизации = Новый Массив;
	Если СтарыйОбъектАвторизации <> NULL Тогда
		ОбъектыАвторизации.Добавить(СтарыйОбъектАвторизации);
	КонецЕсли;
	ОбъектыАвторизации.Добавить(НовыйОбъектАвторизации);
	
	Параметры = Новый Структура;
	Параметры.Вставить("ОбъектыАвторизации", ОбъектыАвторизации);
	
	РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей(Параметры);
	
КонецПроцедуры

// Дополняет массив проверяемых ролей профильными ролями.
Процедура ПередПроверкойДоступностиРолей(МассивИменРолей) Экспорт
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	ДополнительныеРоли = Новый Соответствие;
	ВхожденияРолейВПрофильныеРоли = УправлениеДоступомСлужебныйПовтИсп.ВхожденияРолейВПрофильныеРоли();
	
	Для каждого ИмяРоли Из МассивИменРолей Цикл
		ВхожденияРолиВПрофильныеРоли = ВхожденияРолейВПрофильныеРоли.Получить(ИмяРоли);
		Если ВхожденияРолиВПрофильныеРоли = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Для каждого ПрофильнаяРоль Из ВхожденияРолиВПрофильныеРоли Цикл
			ДополнительныеРоли.Вставить(ПрофильнаяРоль, Истина);
		КонецЦикла;
	КонецЦикла;
	
	Для каждого КлючИЗначение Из ДополнительныеРоли Цикл
		МассивИменРолей.Добавить(КлючИЗначение.Ключ);
	КонецЦикла;
	
КонецПроцедуры

// Добавляет администраторов системы в группу, связанную с предопределенным профилем ОткрытиеВнешнихОтчетовИОбработок.
Процедура УстановитьПравоОткрытияВнешнихОтчетовИОбработок(ОткрытиеРазрешено) Экспорт
	// В модели сервиса право открытия внешних отчетов и обработок не используется для пользователей областей данных.
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	// Поиск предопределенного профиля с ролью "ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок".
	СвойстваПрофиля = СвойстваПрофиляОткрытиеВнешнихОтчетовИОбработок();
	
	// Удаление роли "ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок" из профиля "Администратор".
	ПрофильАдминистратора = ОбщегоНазначенияКлиентСервер.ПредопределенныйЭлемент("Справочник.ПрофилиГруппДоступа.Администратор");
	Если ПрофильАдминистратора <> Неопределено Тогда
		ПрофильОбъект = ПрофильАдминистратора.ПолучитьОбъект();
		Найденные = ПрофильОбъект.Роли.НайтиСтроки(Новый Структура("Роль", СвойстваПрофиля.Роль));
		Если Найденные.Количество() > 0 Тогда
			Для Каждого СтрокаТаблицы Из Найденные Цикл
				ПрофильОбъект.Роли.Удалить(СтрокаТаблицы);
			КонецЦикла;
			// При обновлении ИБ важно, чтобы изменения уехали в подчиненный узел.
			ПрофильОбъект.Записать();
		КонецЕсли;
	КонецЕсли;
	
	// В расширенном интерфейсе группа профиля создается безусловно (вне зависимости от принятого решения).
	УпрощенныйИнтерфейс = УпрощенныйИнтерфейсНастройкиПравДоступа();
	ГруппаДоступаМодифицирована = Ложь;
	Если Не УпрощенныйИнтерфейс Тогда
		ГруппаПрофиля = ГруппаДоступаОткрытиеВнешнихОтчетовИОбработок(СвойстваПрофиля);
	КонецЕсли;
	
	Если ОткрытиеРазрешено Тогда
		
		// Включение администраторов в группы с этим профилем.
		ГруппаДоступаМодифицирована = Ложь;
		Если Не УпрощенныйИнтерфейс Тогда
			ГруппаДоступаОбъект = ГруппаПрофиля.ПолучитьОбъект()
		КонецЕсли;
		РольАдминистратора = Метаданные.Роли.АдминистраторСистемы;
		АдминистраторыСРолью = Новый Массив;
		ПользователиИБ = ПользователиИнформационнойБазы.ПолучитьПользователей();
		Для Каждого ПользовательИБ Из ПользователиИБ Цикл
			Если ПользовательИБ.Роли.Содержит(РольАдминистратора) Тогда
				Пользователь = Справочники.Пользователи.НайтиПоРеквизиту(
					"ИдентификаторПользователяИБ",
					ПользовательИБ.УникальныйИдентификатор);
				Если Пользователь = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если УпрощенныйИнтерфейс Тогда
					// В упрощенном интерфейсе каждый администратор включаются в отдельную группу.
					ВключитьОтключитьПрофильПользователя(Пользователь, СвойстваПрофиля.Ссылка, Истина);
				Иначе
					// В расширенном интерфейсе администраторы включаются в одну группу, связанную с предопределенным профилем.
					Если ГруппаДоступаОбъект.Пользователи.Найти(Пользователь, "Пользователь") = Неопределено Тогда
						ГруппаДоступаМодифицирована = Истина;
						ГруппаДоступаОбъект.Пользователи.Добавить().Пользователь = Пользователь;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		Если Не УпрощенныйИнтерфейс И ГруппаДоступаМодифицирована Тогда
			// При обновлении ИБ важно, чтобы изменения уехали в подчиненный узел.
			ГруппаДоступаОбъект.Записать();
		КонецЕсли;
		
	Иначе
		
		// Удаление роли из всех профилей, за исключением предопределенного.
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ПрофилиГруппДоступаРоли.Ссылка
		|ИЗ
		|	Справочник.ПрофилиГруппДоступа.Роли КАК ПрофилиГруппДоступаРоли
		|ГДЕ
		|	ПрофилиГруппДоступаРоли.Роль = &Роль
		|	И ПрофилиГруппДоступаРоли.Ссылка <> &ИсключаемыйПрофиль";
		Запрос.УстановитьПараметр("Роль", СвойстваПрофиля.Роль);
		Запрос.УстановитьПараметр("ИсключаемыйПрофиль", СвойстваПрофиля.Ссылка);
		МассивПрофилей = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
		Для Каждого Профиль Из МассивПрофилей Цикл
			ПрофильОбъект = Профиль.ПолучитьОбъект();
			Найденные = ПрофильОбъект.Роли.НайтиСтроки(Новый Структура("Роль", СвойстваПрофиля.Роль));
			Для Каждого СтрокаТаблицы Из Найденные Цикл
				ПрофильОбъект.Роли.Удалить(СтрокаТаблицы);
			КонецЦикла;
			// При обновлении ИБ важно, чтобы изменения уехали в подчиненный узел.
			ПрофильОбъект.Записать();
		КонецЦикла;
		
		// Очистка состава групп доступа, связанных с предопределенным профилем.
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ГруппыДоступа.Ссылка
		|ИЗ
		|	Справочник.ГруппыДоступа КАК ГруппыДоступа
		|ГДЕ
		|	ГруппыДоступа.Профиль = &Профиль";
		Запрос.УстановитьПараметр("Профиль", СвойстваПрофиля.Ссылка);
		МассивГрупп = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
		Для Каждого ГруппаДоступа Из МассивГрупп Цикл
			ГруппаДоступаОбъект = ГруппаДоступа.ПолучитьОбъект();
			ГруппаДоступаОбъект.Пользователи.Очистить();
			// При обновлении ИБ важно, чтобы изменения уехали в подчиненный узел.
			ГруппаДоступаОбъект.Записать();
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Прочие процедуры и функции.

// Определяет принадлежность роли специальной группе профильных ролей.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПрофильнаяРоль(ИмяРоли) Экспорт
	
	Возврат ВРег(Лев(ИмяРоли, СтрДлина("Профиль"))) = ВРег("Профиль");
	
КонецФункции

// Возвращает профили текущего пользователя у которых есть роль БазовыеПрава или
// или это профиль Администратор.
//
// Возвращаемое значение:
//  Массив - содержит элементы типа СправочникСсылка.ПрофилиГруппДоступа.
//
Функция ОсновныеПрофилиПользователя() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Параметры.Вставить("АвторизованныйПользователь", Пользователи.АвторизованныйПользователь());
	Запрос.Параметры.Вставить("РольБазовыеПрава", ОбщегоНазначения.ИдентификаторОбъектаМетаданных(
		Метаданные.Роли.БазовыеПрава));
	
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ГруппыДоступа.Профиль КАК Профиль
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|		ПО (СоставыГруппПользователей.ГруппаПользователей = ГруппыДоступаПользователи.Пользователь)
	|			И (СоставыГруппПользователей.Пользователь = &АвторизованныйПользователь)
	|			И (СоставыГруппПользователей.Используется)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа КАК ГруппыДоступа
	|		ПО (ГруппыДоступа.Ссылка = ГруппыДоступаПользователи.Ссылка)
	|			И (НЕ ГруппыДоступа.ПометкаУдаления)
	|			И (НЕ ГруппыДоступа.Профиль.ПометкаУдаления)
	|			И (НЕ(НЕ ГруппыДоступа.Профиль = ЗНАЧЕНИЕ(Справочник.ПрофилиГруппДоступа.Администратор)
	|					И НЕ ИСТИНА В
	|							(ВЫБРАТЬ ПЕРВЫЕ 1
	|								ИСТИНА
	|							ИЗ
	|								Справочник.ПрофилиГруппДоступа.Роли КАК РолиПрофилей
	|							ГДЕ
	|								РолиПрофилей.Ссылка = ГруппыДоступа.Профиль
	|								И РолиПрофилей.Роль = &РольБазовыеПрава)))";
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Профиль");
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Обновляет список ролей пользователей информационной базы
// по их текущим принадлежностям к группам доступа.
//  Пользователи с ролью "ПолныеПрава" игнорируется.
// 
// Параметры:
//  Пользователи - СправочникСсылка.Пользователи,
//                 СправочникСсылка.ВнешниеПользователи.
//                 Массив значений указанных выше типов.
//               - Неопределено - обновить роли всех пользователей.
//               - Тип по которому будет найден объект метаданных:
//                 если будет найден Справочник.ВнешниеПользователи,
//                 то будут обновлены роли всех внешних пользователей,
//                 иначе будут обновлены роли всех пользователей.
//
//  ПарольПользователяСервиса - Строка - Пароль для авторизации в менеджере 
//                        сервиса.
//  ЕстьИзменения - Булево (возвращаемое значение) - в этот параметр возвращается
//                  значение Истина, если производилась запись, иначе не изменяется.
//
Процедура ОбновитьРолиПользователей(Знач Пользователи1 = Неопределено,
                                    Знач ПарольПользователяСервиса = Неопределено,
                                    ЕстьИзменения = Ложь) Экспорт
	
	Если НЕ ПользователиСлужебный.ЗапретРедактированияРолей() Тогда
		// Роли устанавливаются механизмами подсистем Пользователи и ВнешниеПользователи.
		Возврат;
	КонецЕсли;
	
	Если Пользователи1 = Неопределено Тогда
		МассивПользователей = Неопределено;
		Пользователи.НайтиНеоднозначныхПользователейИБ(Неопределено);
		
	ИначеЕсли ТипЗнч(Пользователи1) = Тип("Массив") Тогда
		МассивПользователей = Пользователи1;
		Если МассивПользователей.Количество() = 0 Тогда
			Возврат;
		КонецЕсли;
		Пользователи.НайтиНеоднозначныхПользователейИБ(Неопределено);
		
	ИначеЕсли ТипЗнч(Пользователи1) = Тип("Тип") Тогда
		МассивПользователей = Пользователи1;
	Иначе
		МассивПользователей = Новый Массив;
		МассивПользователей.Добавить(Пользователи1);
		Пользователи.НайтиНеоднозначныхПользователейИБ(Пользователи1);
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТекущиеСвойстваПользователей = ТекущиеСвойстваПользователей(МассивПользователей);
	
	// Параметры проверки в цикле.
	ВсеРоли                       = ПользователиСлужебный.ВсеРоли().Соответствие;
	ИдентификаторыПользователейИБ = ТекущиеСвойстваПользователей.ИдентификаторыПользователейИБ;
	НовыеРолиПользователей        = ТекущиеСвойстваПользователей.РолиПользователей;
	Администраторы                = ТекущиеСвойстваПользователей.Администраторы;
	
	ИмяРолиАдминистратораСистемы = Пользователи.РольАдминистратораСистемы().Имя;
	РолиАдминистратора = Новый Соответствие;
	РолиАдминистратора.Вставить("ПолныеПрава", Истина);
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Если ИмяРолиАдминистратораСистемы <> "ПолныеПрава" Тогда
			РолиАдминистратора.Вставить(ИмяРолиАдминистратораСистемы, Истина);
		КонецЕсли;
	КонецЕсли;
	
	// Будущий итог после цикла.
	НовыеАдминистраторыИБ     = Новый Соответствие;
	ОбновляемыеПользователиИБ = Новый Соответствие;
	
	Для каждого ОписаниеПользователя Из ИдентификаторыПользователейИБ Цикл
		
		ТекущийПользователь         = ОписаниеПользователя.Пользователь;
		ИдентификаторПользователяИБ = ОписаниеПользователя.ИдентификаторПользователяИБ;
		НовыйАдминистраторИБ        = Ложь;
		
		Отказ = Ложь;
		Обработчики = ОбщегоНазначения.ОбработчикиСлужебногоСобытия("СтандартныеПодсистемы.УправлениеДоступом\ПриОбновленииРолейПользователяИБ");
		Для Каждого Обработчик Из Обработчики Цикл
			Обработчик.Модуль.ПриОбновленииРолейПользователяИБ(ИдентификаторПользователяИБ, Отказ);
		КонецЦикла;
		Если Отказ Тогда
			Продолжить;
		КонецЕсли;
		
		// Поиск пользователя ИБ.
		Если ТипЗнч(ИдентификаторПользователяИБ) = Тип("УникальныйИдентификатор") Тогда
			ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
				ИдентификаторПользователяИБ);
		Иначе
			ПользовательИБ = Неопределено;
		КонецЕсли;
		
		СтарыеРоли = Неопределено;
		
		Если ПользовательИБ <> Неопределено И ЗначениеЗаполнено(ПользовательИБ.Имя) Тогда
			
			НовыеРоли = НовыеРолиПользователей.Скопировать(НовыеРолиПользователей.НайтиСтроки(
				Новый Структура("Пользователь", ТекущийПользователь)), "Роль");
			
			НовыеРоли.Индексы.Добавить("Роль");
			
			Если НовыеРоли.Найти("ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок", "Роль") = Неопределено Тогда
				РолиТекущегоАдминистратора = РолиАдминистратора;
			Иначе
				РолиТекущегоАдминистратора = Новый ФиксированноеСоответствие(РолиАдминистратора);
				РолиТекущегоАдминистратора = Новый Соответствие(РолиТекущегоАдминистратора);
				РолиТекущегоАдминистратора.Вставить("ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок", Истина);
			КонецЕсли;
			
			// Проверка старых ролей.
			СтарыеРоли        = Новый Соответствие;
			РолиДляДобавления = Новый Соответствие;
			РолиДляУдаления   = Новый Соответствие;
			
			Если Администраторы[ТекущийПользователь] = Неопределено Тогда
				Для каждого Роль Из ПользовательИБ.Роли Цикл
					ИмяРоли = Роль.Имя;
					СтарыеРоли.Вставить(ИмяРоли, Истина);
					Если НовыеРоли.Найти(ИмяРоли, "Роль") = Неопределено Тогда
						РолиДляУдаления.Вставить(ИмяРоли, Истина);
					КонецЕсли;
				КонецЦикла;
			Иначе // Администратор.
				Для каждого Роль Из ПользовательИБ.Роли Цикл
					ИмяРоли = Роль.Имя;
					СтарыеРоли.Вставить(ИмяРоли, Истина);
					Если РолиТекущегоАдминистратора[ИмяРоли] = Неопределено Тогда
						РолиДляУдаления.Вставить(ИмяРоли, Истина);
					КонецЕсли;
				КонецЦикла;
				
				Для каждого КлючИЗначение Из РолиТекущегоАдминистратора Цикл
					
					Если СтарыеРоли[КлючИЗначение.Ключ] = Неопределено Тогда
						РолиДляДобавления.Вставить(КлючИЗначение.Ключ, Истина);
						
						Если КлючИЗначение.Ключ = ИмяРолиАдминистратораСистемы Тогда
							НовыйАдминистраторИБ = Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			
			// Проверка новых ролей.
			Для каждого Строка Из НовыеРоли Цикл
				
				Если СтарыеРоли = Неопределено
				 ИЛИ Администраторы[ТекущийПользователь] <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				Если СтарыеРоли[Строка.Роль] = Неопределено Тогда
					Если ВсеРоли.Получить(Строка.Роль) <> Неопределено Тогда
					
						РолиДляДобавления.Вставить(Строка.Роль, Истина);
						
						Если Строка.Роль = ИмяРолиАдминистратораСистемы Тогда
							НовыйАдминистраторИБ = Истина;
						КонецЕсли;
					Иначе
						// Новые роли не найденные в метаданных.
						Профили = ПрофилиПользователяСРолью(ТекущийПользователь, Строка.Роль);
						Для каждого Профиль Из Профили Цикл
							ЗаписьЖурналаРегистрации(
								НСтр("ru = 'Управление доступом.Роль не найдена в метаданных'",
								     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
								УровеньЖурналаРегистрации.Ошибка,
								,
								,
								СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
									НСтр("ru= 'При обновлении ролей пользователя ""%1""
									          |роль ""%2""
									          |профиля групп доступа ""%3""
									          |не найдена в метаданных.'"),
									Строка(ТекущийПользователь),
									Строка.Роль,
									Строка(Профиль)),
								РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
		// Завершение обработки текущего пользователя.
		Если СтарыеРоли <> Неопределено
		   И (  РолиДляДобавления.Количество() <> 0
			  ИЛИ РолиДляУдаления.Количество() <> 0) Тогда
			
			ИзмененияРолей = Новый Структура;
			ИзмененияРолей.Вставить("ПользовательСсылка", ТекущийПользователь);
			ИзмененияРолей.Вставить("ПользовательИБ",     ПользовательИБ);
			ИзмененияРолей.Вставить("РолиДляДобавления",  РолиДляДобавления);
			ИзмененияРолей.Вставить("РолиДляУдаления",    РолиДляУдаления);
			
			Если НовыйАдминистраторИБ Тогда
				НовыеАдминистраторыИБ.Вставить(ТекущийПользователь, ИзмененияРолей);
			Иначе
				ОбновляемыеПользователиИБ.Вставить(ТекущийПользователь, ИзмененияРолей);
			КонецЕсли;
			
			ЕстьИзменения = Истина;
		КонецЕсли;
	КонецЦикла;
	
	// Добавление новых администраторов.
	ОбновитьРолиПользователейИБ(НовыеАдминистраторыИБ, ПарольПользователяСервиса);
	
	// Удаление старых администраторов и обновление остальных пользователей.
	ОбновитьРолиПользователейИБ(ОбновляемыеПользователиИБ, ПарольПользователяСервиса);
	
КонецПроцедуры

// Проверка группы доступа Администраторы перед записью.
Процедура ПроверитьНаличиеПользователяИБВГруппеДоступаАдминистраторы(ПользователиГруппы, ОписаниеОшибки) Экспорт
	
	Пользователи.НайтиНеоднозначныхПользователейИБ(Неопределено);
	
	// Проверка пустого списка пользователей ИБ в группе доступа Администраторы.
	УстановитьПривилегированныйРежим(Истина);
	НайденДействующийАдминистратор = Ложь;
	
	Для Каждого ОписаниеПользователя Из ПользователиГруппы Цикл
		
		Если Не ЗначениеЗаполнено(ОписаниеПользователя.Пользователь)
		 Или ТипЗнч(ОписаниеПользователя.Пользователь) <> Тип("СправочникСсылка.Пользователи")
		   И ТипЗнч(ОписаниеПользователя.Пользователь) <> Тип("СправочникСсылка.Пользователи") Тогда
			Продолжить;
		КонецЕсли;
		
		ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
			ОписаниеПользователя.Пользователь.ИдентификаторПользователяИБ);
		
		Если ПользовательИБ <> Неопределено
		   И Пользователи.ВходВПрограммуРазрешен(ПользовательИБ) Тогда
			
			НайденДействующийАдминистратор = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если НЕ НайденДействующийАдминистратор Тогда
		ОписаниеОшибки =
			НСтр("ru = 'В группе доступа Администраторы
			           |должен быть хотя бы один пользователь,
			           |которому разрешен вход в программу.'");
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики событий подсистем БСП.

// Добавляет процедуры-обработчики обновления, необходимые данной подсистеме.
//
// Параметры:
//  Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
//                                  общего модуля ОбновлениеИнформационнойБазы.
// 
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	// Обработчики обновления неразделенных данных.
	Обработчик = Обработчики.Добавить();
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.УправлениеОбработчиками = Истина;
	Обработчик.Приоритет = 1;
	Обработчик.Версия = "*";
	Обработчик.МонопольныйРежим = Истина;
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ЗаполнитьОбработчикиРазделенныхДанных";
	
	// Обработчики обновления разделенных данных.
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "*";
	Обработчик.МонопольныйРежим = Истина;
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.2.8";
	Обработчик.Процедура = "РегистрыСведений.УдалитьПраваПоЗначениямДоступа.ПереместитьДанныеВНовыйРегистр";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.2.8";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ПреобразоватьИменаРолейВИдентификаторы";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.2.8";
	Обработчик.Процедура = "РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.2.16";
	Обработчик.Процедура = "РегистрыСведений.ТаблицыГруппДоступа.ОбновитьДанныеРегистра";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.2.16";
	Обработчик.Процедура = "УправлениеДоступом.ОбновитьРолиПользователей";
	Обработчик.РежимВыполнения = "Оперативно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.3.5";
	Обработчик.Процедура = "РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.4.15";
	Обработчик.Процедура = "Справочники.ПрофилиГруппДоступа.ЗаполнитьИдентификаторыПоставляемыхДанных";
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 1;
	
	// Должен выполнятся после обработчика ЗаполнитьИдентификаторыПоставляемыхДанных.
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "1.0.0.1";
	Обработчик.НачальноеЗаполнение = Истина;
	Обработчик.Процедура = "Справочники.ГруппыДоступа.ЗаполнитьПрофильГруппыДоступаАдминистраторы";
	Обработчик.РежимВыполнения = "Монопольно";
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 1;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.1.15";
	Обработчик.Процедура = "Справочники.ПрофилиГруппДоступа.ПреобразоватьИдентификаторыВидовДоступа";
	Обработчик.РежимВыполнения = "Монопольно";
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 1;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.1.15";
	Обработчик.Процедура = "РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппировкиПользователей";
	Обработчик.РежимВыполнения = "Монопольно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.1.15";
	Обработчик.Процедура = "РегистрыСведений.ЗначенияГруппДоступа.ОбновитьДанныеРегистра";
	Обработчик.РежимВыполнения = "Монопольно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.1.15";
	Обработчик.Процедура = "РегистрыСведений.УдалитьГруппыЗначенийДоступа.ПереместитьДанныеВНовыйРегистр";
	Обработчик.РежимВыполнения = "Монопольно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.1.15";
	Обработчик.Процедура = "РегистрыСведений.НаследованиеНастроекПравОбъектов.ОбновитьДанныеРегистра";
	Обработчик.РежимВыполнения = "Монопольно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.1.15";
	Обработчик.Процедура = "РегистрыСведений.НастройкиПравОбъектов.ОбновитьВспомогательныеДанныеРегистра";
	Обработчик.РежимВыполнения = "Монопольно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.1.15";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ВключитьЗаполнениеДанныхДляОграниченияДоступа";
	Обработчик.РежимВыполнения = "Монопольно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.1.35";
	Обработчик.Процедура = "РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппыПустыхЗначенийДоступа";
	Обработчик.РежимВыполнения = "Оперативно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.3.27";
	Обработчик.Процедура = "РегистрыСведений.ЗначенияГруппДоступа.ОбновитьДанныеРегистра";
	Обработчик.РежимВыполнения = "Оперативно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.5.4";
	Обработчик.Процедура = "РегистрыСведений.УдалитьГруппыЗначенийДоступа.ОчиститьРегистр";
	Обработчик.РежимВыполнения = "Оперативно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.5.7";
	Обработчик.Процедура = "УправлениеДоступом.ОбновитьРолиПользователей";
	Обработчик.РежимВыполнения = "Оперативно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.3.1.61";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ЗаполнитьНазначениеПрофилейГруппДоступа";
	Обработчик.РежимВыполнения = "Оперативно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.3.1.55";
	Обработчик.Процедура = "УправлениеДоступомСлужебный.ЗаменитьУдаленныеРолиВПрофиляхГруппДоступа";
	Обработчик.РежимВыполнения = "Оперативно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.3.2.23";
	Обработчик.Процедура = "РегистрыСведений.ЗначенияГруппДоступа.ОбновитьДанныеРегистра";
	Обработчик.РежимВыполнения = "Оперативно";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.НачальноеЗаполнение = Истина;
	Обработчик.Процедура = "УправлениеДоступомСлужебный.СоздатьПрофильОткрытияВнешнихОтчетовИОбработок";
	
КонецПроцедуры

// См. комментарий одноименной процедуры общего модуля ОбновлениеИнформационнойБазыПереопределяемый.
Процедура ПослеОбновленияИнформационнойБазы(Знач ПредыдущаяВерсияИБ, Знач ТекущаяВерсияИБ,
	Знач ВыполненныеОбработчики, ВыводитьОписаниеОбновлений, МонопольныйРежим) Экспорт
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	Запустить = ПараметрыСеанса.ПараметрыКлиентаНаСервере.Получить("ЗапуститьОбновлениеИнформационнойБазы");
	УстановитьПривилегированныйРежим(Ложь);
	
	Если Запустить = Истина Тогда
		// При ручном запуске обновления требуется полное обновление ролей
		// так как в режиме отладки профильные роли отключены, а в обычном режиме включены.
		УправлениеДоступом.ОбновитьРолиПользователей();
	КонецЕсли;
	
КонецПроцедуры

// Заполняет структуру параметров, необходимых для работы клиентского кода
// конфигурации.
//
// Параметры:
//   Параметры   - Структура - структура параметров.
//
Процедура ПриДобавленииПараметровРаботыКлиента(Параметры) Экспорт
	
	Параметры.Вставить("УпрощенныйИнтерфейсНастройкиПравДоступа",
		УпрощенныйИнтерфейсНастройкиПравДоступа());
	
КонецПроцедуры

// Заполняет массив списком имен объектов метаданных, данные которых могут содержать ссылки на различные объекты
// метаданных, но при этом эти ссылки не должны учитываться в бизнес-логике приложения.
//
// Параметры:
//  Массив       - массив строк, например, "РегистрСведений.ВерсииОбъектов".
//
Процедура ПриДобавленииИсключенийПоискаСсылок(Массив) Экспорт
	
	Массив.Добавить(Метаданные.РегистрыСведений.ГруппыЗначенийДоступа.ПолноеИмя());
	Массив.Добавить(Метаданные.РегистрыСведений.ЗависимостиПравДоступа.ПолноеИмя());
	Массив.Добавить(Метаданные.РегистрыСведений.ЗначенияГруппДоступа.ПолноеИмя());
	Массив.Добавить(Метаданные.РегистрыСведений.ЗначенияГруппДоступаПоУмолчанию.ПолноеИмя());
	Массив.Добавить(Метаданные.РегистрыСведений.НаборыЗначенийДоступа.ПолноеИмя());
	Массив.Добавить(Метаданные.РегистрыСведений.ПраваРолей.ПолноеИмя());
	Массив.Добавить(Метаданные.РегистрыСведений.НаследованиеНастроекПравОбъектов.ПолноеИмя());
	Массив.Добавить(Метаданные.РегистрыСведений.НастройкиПравОбъектов.ПолноеИмя());
	Массив.Добавить(Метаданные.РегистрыСведений.ТаблицыГруппДоступа.ПолноеИмя());
	
КонецПроцедуры

// Вызывается при загрузке ссылок предопределенных элементов в процессе загрузки важных данных.
// Позволяет выполнить действия по исправлению или регистрации сведений о не уникальности
// предопределенных элементов, а также позволяет отказаться от продолжения, если это недопустимо.
//
// Параметры:
//   Объект          - СправочникОбъект, ПланВидовХарактеристикОбъект, ПланСчетовОбъект, ПланВидовРасчетаОбъект -
//                     объект предопределенного элемента после записи которого обнаружено наличие не уникальности.
//   ЗаписатьВЖурнал - Булево - возвращаемое значение. Если указать Ложь, тогда сведения о не уникальности не будут
//                     добавлены в журнал регистрации в общем сообщении.
//                     Нужно установить Ложь, если не уникальность была устранена автоматически.
//   Отказ           - Булево - возвращаемое значение. Если указать Истина, будет вызвано общее исключение,
//                     содержащее все причины отказа.
//   ОписаниеОтказа  - Строка - возвращаемое значение. Если Отказ установлен в Истина, то описание будет добавлено
//                     в список причин невозможности продолжения.
//
Процедура ПриОбнаруженииНеУникальностиПредопределенного(Объект, ЗаписатьВЖурнал, Отказ, ОписаниеОтказа) Экспорт
	
	Если ТипЗнч(Объект) = Тип("СправочникОбъект.ПрофилиГруппДоступа")
	   И Объект.ИмяПредопределенныхДанных = "Администратор" Тогда
		
		ЗаписатьВЖурнал = Ложь;
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
		Запрос.УстановитьПараметр("ИмяПредопределенныхДанных", "Администратор");
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ПрофилиГруппДоступа.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ПрофилиГруппДоступа КАК ПрофилиГруппДоступа
		|ГДЕ
		|	ПрофилиГруппДоступа.Ссылка <> &Ссылка
		|	И ПрофилиГруппДоступа.ИмяПредопределенныхДанных = &ИмяПредопределенныхДанных";
		
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			ТекущийОбъект = Выборка.Ссылка.ПолучитьОбъект();
			ТекущийОбъект.ИмяПредопределенныхДанных = "";
			ТекущийОбъект.ИдентификаторПоставляемыхДанных = "";
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(ТекущийОбъект);
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Объект) = Тип("СправочникОбъект.ГруппыДоступа")
	        И Объект.ИмяПредопределенныхДанных = "Администраторы" Тогда
		
		ЗаписатьВЖурнал = Ложь;
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ИмяПредопределенныхДанных", "Администраторы");
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ГруппыДоступаПользователи.Пользователь
		|ИЗ
		|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
		|ГДЕ
		|	ГруппыДоступаПользователи.Ссылка.ИмяПредопределенныхДанных = &ИмяПредопределенныхДанных";
		ВсеПользователи = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Пользователь");
		
		Записать = Ложь;
		Для каждого Пользователь Из ВсеПользователи Цикл
			Если Объект.Пользователи.Найти(Пользователь, "Пользователь") = Неопределено Тогда
				Объект.Пользователи.Добавить().Пользователь = Пользователь;
				Записать = Истина;
			КонецЕсли;
		КонецЦикла;
		
		Если Записать Тогда
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
		КонецЕсли;
		
		Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ГруппыДоступа.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ГруппыДоступа КАК ГруппыДоступа
		|ГДЕ
		|	ГруппыДоступа.Ссылка <> &Ссылка
		|	И ГруппыДоступа.ИмяПредопределенныхДанных = &ИмяПредопределенныхДанных";
		
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			ТекущийОбъект = Выборка.Ссылка.ПолучитьОбъект();
			ТекущийОбъект.ИмяПредопределенныхДанных = "";
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(ТекущийОбъект);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Процедура является обработчиком одноименного события, возникающего при обмене данными в распределенной информационной базе.
//
// Параметры:
// см. описание обработчика события ПриОтправкеДанныхГлавному() в синтаксис-помощнике.
// 
Процедура ПриОтправкеДанныхГлавному(ЭлементДанных, ОтправкаЭлемента, Получатель) Экспорт
	
	Если ИмяОбъектаПодсистемыУправлениеДоступомНачинаетсяСУдалить(ЭлементДанных) Тогда
		ОтправкаЭлемента = ОтправкаЭлементаДанных.Игнорировать;
	КонецЕсли;
	
КонецПроцедуры

// Процедура является обработчиком одноименного события, возникающего при обмене данными в распределенной информационной базе.
//
// Параметры:
// см. описание обработчика события ПриОтправкеДанныхПодчиненному() в синтаксис-помощнике.
// 
Процедура ПриОтправкеДанныхПодчиненному(ЭлементДанных, ОтправкаЭлемента, СозданиеНачальногоОбраза, Получатель) Экспорт
	
	Если СозданиеНачальногоОбраза Тогда
		Возврат;
	КонецЕсли;
	
	Если ИмяОбъектаПодсистемыУправлениеДоступомНачинаетсяСУдалить(ЭлементДанных) Тогда
		ОтправкаЭлемента = ОтправкаЭлементаДанных.Игнорировать;
	КонецЕсли;
	
КонецПроцедуры

// Процедура является обработчиком одноименного события, возникающего при обмене данными в распределенной
// информационной базе.
//
// Параметры:
// см. описание обработчика события ПриПолученииДанныхОтГлавного() в синтаксис-помощнике.
// 
Процедура ПриПолученииДанныхОтГлавного(ЭлементДанных, ПолучениеЭлемента, ОтправкаНазад, Отправитель) Экспорт
	
	// Стандартная обработка не переопределяется.
	Если ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать Тогда
		Возврат;
	КонецЕсли;
	
	Если ИмяОбъектаПодсистемыУправлениеДоступомНачинаетсяСУдалить(ЭлементДанных) Тогда
		ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать;
		Возврат;
	КонецЕсли;
	
	// Администраторы назначаются во всех подчиненных РИБ-узлах независимо.
	Если ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ГруппыДоступа") Тогда
		Справочники.ГруппыДоступа.ВосстановитьСоставУчастниковГруппыДоступаАдминистраторы(ЭлементДанных, ОтправкаНазад);
	КонецЕсли;
	
КонецПроцедуры

// Процедура является обработчиком одноименного события, возникающего при обмене данными в распределенной
// информационной базе.
//
// Параметры:
// см. описание обработчика события ПриПолученииДанныхОтПодчиненного() в синтаксис-помощнике.
// 
Процедура ПриПолученииДанныхОтПодчиненного(ЭлементДанных, ПолучениеЭлемента, ОтправкаНазад, Отправитель) Экспорт
	
	// Стандартная обработка не переопределяется.
	Если ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать Тогда
		Возврат;
	КонецЕсли;
	
	Если ИмяОбъектаПодсистемыУправлениеДоступомНачинаетсяСУдалить(ЭлементДанных) Тогда
		ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать;
		Возврат;
	КонецЕсли;
	
	Если Не ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		
		// Администраторы назначаются во всех подчиненных РИБ-узлах независимо.
		Если ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ГруппыДоступа") Тогда
			Справочники.ГруппыДоступа.ВосстановитьСоставУчастниковГруппыДоступаАдминистраторы(ЭлементДанных, ОтправкаНазад);
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(ЭлементДанных) = Тип("КонстантаМенеджерЗначения.ОграничиватьДоступНаУровнеЗаписей")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ГруппыДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("СправочникОбъект.ПрофилиГруппДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ГруппыЗначенийДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ЗначенияГруппДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.НаборыЗначенийДоступа")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.НастройкиПравОбъектов")
	      ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ТаблицыГруппДоступа") Тогда
		
		// Получение данных из автономного рабочего места пропускается, а для соответствия
		// данных в узлах, текущие данные отправляются обратно в автономное рабочее место.
		ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать;
		ОтправкаНазад = Истина;
	КонецЕсли;
	
КонецПроцедуры

// Процедура-обработчик события после получения данных в главном узле от подчиненного узла распределенной ИБ.
// Вызывается в момент завершения чтения сообщения обмена, когда все данные из сообщения обмена успешно прочитаны и
// записаны в ИБ.
// 
//  Параметры:
// Отправитель - ПланОбменаОбъект. Объект узла плана обмена, от которого получены данные.
// Отказ - Булево. Флаг отказа. Если установить данному параметру значение Истина,
// то сообщение будет считаться не принятым. Также произойдет отмена транзакции загрузки данных,
// если все данные были загружены в одной транзакции или отмена последней транзакции загрузки данных,
// если данные были загружены порциями.
//
Процедура ПослеПолученияДанныхОтПодчиненного(Отправитель, Отказ) Экспорт
	
	ПослеПолученияДанных(Отправитель, Отказ, Истина);
	
КонецПроцедуры

// Процедура-обработчик события после получения данных в подчиненном узле от главного узла распределенной ИБ.
// Вызывается в момент завершения чтения сообщения обмена, когда все данные из сообщения обмена успешно прочитаны и
// записаны в ИБ.
// 
//  Параметры:
// Отправитель - ПланОбменаОбъект. Объект узла плана обмена, от которого получены данные.
// Отказ - Булево. Флаг отказа. Если установить данному параметру значение Истина,
// то сообщение будет считаться не принятым. Также произойдет отмена транзакции загрузки данных,
// если все данные были загружены в одной транзакции или отмена последней транзакции загрузки данных,
// если данные были загружены порциями.
//
Процедура ПослеПолученияДанныхОтГлавного(Отправитель, Отказ) Экспорт
	
	ПослеПолученияДанных(Отправитель, Отказ, Ложь);
	
КонецПроцедуры

// Обработчики событий подсистемы ВариантыОтчетов.

// Содержит настройки размещения вариантов отчетов в панели отчетов.
//
// Параметры:
//   Настройки - Коллекция - Содержит настройки всех отчетов и вариантов конфигурации.
//       Используется для передачи в параметрах вспомогательных методов.
//
// Описание:
//   См. ВариантыОтчетовПереопределяемый.НастроитьВариантыОтчетов().
//
// Вспомогательные методы:
//   1. Функции ОписаниеОтчета и ОписаниеВарианта формируют описание настроек отчета и варианта для последующего изменения:
//       НастройкиОтчета   = ВариантыОтчетов.ОписаниеОтчета(Настройки, Метаданные.Отчеты.<ИмяОтчета>);
//       НастройкиВарианта = ВариантыОтчетов.ОписаниеВарианта(Настройки, НастройкиОтчета, "<ИмяВарианта>");
//       Возвращаемые коллекции содержат одинаковый набор свойств.
//       НастройкиОтчета используются как умолчания для вариантов, описания которых еще не получены.
//       Подробнее - см. "свойства для изменения" в комментарии к ВариантыОтчетовПереопределяемый.НастроитьВариантыОтчетов().
//   2. Процедура УстановитьРежимВыводаВПанеляхОтчетов позволяет настроить режим группировки вариантов в панелях отчетов:
//       ВариантыОтчетов.УстановитьРежимВыводаВПанеляхОтчетов(Настройки, НастройкиОтчета, Истина/Ложь);
//       ВариантыОтчетов.УстановитьРежимВыводаВПанеляхОтчетов(Настройки, Метаданные.Отчеты.<ИмяОтчета>, Истина/Ложь);
//       ВариантыОтчетов.УстановитьРежимВыводаВПанеляхОтчетов(Настройки, Метаданные.Подсистемы.<ИмяПодсистемы>, Истина/Ложь);
//   3. Процедура НастроитьОтчетВМодулеМенеджера позволяет переопределять настройки отчета в его модуле менеджера:
//       ВариантыОтчетов.НастроитьОтчетВМодулеМенеджера(Настройки, Метаданные.Отчеты.<ИмяОтчета>);
//
Процедура ПриНастройкеВариантовОтчетов(Настройки) Экспорт
	МодульВариантыОтчетов = ОбщегоНазначения.ОбщийМодуль("ВариантыОтчетов");
	МодульВариантыОтчетов.НастроитьОтчетВМодулеМенеджера(Настройки, Метаданные.Отчеты.ПраваДоступа);
КонецПроцедуры

// Обработчики событий библиотеки ТехнологияСервиса.

// Заполняет массив типов неразделенных данных, для которых не требуется сопоставление ссылок
// при загрузке данных в другую информационную базу, т.к. корректное сопоставление ссылок
// гарантируется с помощью других механизмов.
//
// Параметры:
//  Типы - Массив(ОбъектМетаданных).
//
Процедура ПриЗаполненииТиповОбщихДанныхНеТребующихСопоставлениеСсылокПриЗагрузке(Типы) Экспорт
	
	// В разделенных данных используются ссылки только на предопределенные элементы
	// плана видов характеристик УдалитьВидыДоступа.
	Типы.Добавить(Метаданные.ПланыВидовХарактеристик.УдалитьВидыДоступа);
	
КонецПроцедуры

// Заполняет массив типов, исключаемых из выгрузки и загрузки данных.
//
// Параметры:
//  Типы - Массив(Типы).
//
Процедура ПриЗаполненииТиповИсключаемыхИзВыгрузкиЗагрузки(Типы) Экспорт
	
	Типы.Добавить(Метаданные.ПланыВидовХарактеристик.УдалитьВидыДоступа);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики подписок на события.

// Обработчик подписки ОбновитьГруппыЗначенийДоступа на событие ПередЗаписью:
// - вызывает метод записи групп значений доступа в
//   РегистрСведений.ГруппыЗначенийДоступа для требуемых объектов метаданных;
//
Процедура ОбновитьГруппыЗначенийДоступа(Знач Объект, Отказ) Экспорт
	
	Если Объект.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	Если СтандартныеПодсистемыСервер.ЭтоИдентификаторОбъектаМетаданных(Объект) Тогда
		Возврат;
	КонецЕсли;
	
	Параметры = УправлениеДоступомСлужебныйПовтИсп.Параметры();
	ЗначенияДоступаСГруппами = Параметры.СвойстваВидовДоступа.ЗначенияДоступаСГруппами;
	
	Если ЗначенияДоступаСГруппами.ПоТипам.Получить(ТипЗнч(Объект)) <> Неопределено Тогда
		РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппыЗначенийДоступа(Объект);
	КонецЕсли;
	
КонецПроцедуры

// Обработчик подписки ОбновитьГруппыВладельцевНастроекПрав на событие ПередЗаписью:
// - вызывает метод записи иерархии владельцев настроек прав объектов в
//   РегистрСведений.НаследованиеНастроекПравОбъектов для требуемых объектов метаданных.
//
Процедура ОбновитьГруппыВладельцевНастроекПрав(Знач Объект, Отказ) Экспорт
	
	Если Объект.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	Если СтандартныеПодсистемыСервер.ЭтоИдентификаторОбъектаМетаданных(Объект) Тогда
		Возврат;
	КонецЕсли;
	
	Параметры = УправлениеДоступомСлужебныйПовтИсп.Параметры();
	ВозможныеПраваПоТипам    = Параметры.ВозможныеПраваДляНастройкиПравОбъектов.ПоТипам;
	
	Если ВозможныеПраваПоТипам.Получить(ТипЗнч(Объект)) <> Неопределено Тогда
		РегистрыСведений.НаследованиеНастроекПравОбъектов.ОбновитьДанныеРегистра(Объект);
	КонецЕсли;
	
КонецПроцедуры

// Обработчик подписки ЗаписатьНаборыЗначенийДоступа на событие ПриЗаписи
// вызывает метод записи значений доступа объекта в РегистрСведений.НаборыЗначенийДоступа.
//  Возможен случай использования подсистемы "УправлениеДоступом", когда
// указанной подписки не существует, если наборы значений доступа не применяются.
//
Процедура ЗаписатьНаборыЗначенийДоступаПриЗаписи(Знач Объект, Отказ) Экспорт

	Если Объект.ОбменДанными.Загрузка
	   И НЕ Объект.ДополнительныеСвойства.Свойство("ЗаписатьНаборыЗначенийДоступа") Тогда
		
		Возврат;
	КонецЕсли;
	
	Если СтандартныеПодсистемыСервер.ЭтоИдентификаторОбъектаМетаданных(Объект) Тогда
		Возврат;
	КонецЕсли;
	
	ЗаписатьНаборыЗначенийДоступа(Объект, , Объект.ДополнительныеСвойства.Свойство(
		"ЗаписьНаборовЗначенийДоступаПриОбновленииИБ"));
	
КонецПроцедуры

// Обработчик подписки ЗаписатьЗависимыеНаборыЗначенийДоступа события ПриЗаписи
// вызывает перезапись зависимых наборов значений доступа в регистре сведений НаборыЗначенийДоступа.
//
//  Возможен случай использования подсистемы "УправлениеДоступом", когда
// указанной подписки не существует, если зависимые наборы значений доступа не применяются.
//
Процедура ЗаписатьЗависимыеНаборыЗначенийДоступаПриЗаписи(Знач Объект, Отказ) Экспорт
	
	Если Объект.ОбменДанными.Загрузка
	   И НЕ Объект.ДополнительныеСвойства.Свойство("ЗаписатьЗависимыеНаборыЗначенийДоступа") Тогда
		
		Возврат;
	КонецЕсли;
	
	Если СтандартныеПодсистемыСервер.ЭтоИдентификаторОбъектаМетаданных(Объект) Тогда
		Возврат;
	КонецЕсли;
	
	ЗаписатьЗависимыеНаборыЗначенийДоступа(Объект, Объект.ДополнительныеСвойства.Свойство(
		"ЗаписьНаборовЗначенийДоступаПриОбновленииИБ"));
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики регламентных заданий.

// Обработчик регламентного задания ЗаполнениеДанныхДляОграниченияДоступа.
Процедура ЗаполнениеДанныхДляОграниченияДоступаОбработчикЗадания() Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(
		Метаданные.РегламентныеЗадания.ЗаполнениеДанныхДляОграниченияДоступа);
	
	ЗаполнениеДанныхДляОграниченияДоступа();
	
КонецПроцедуры

// Выполняет последовательное заполнение и обновление данных, необходимых для работы
// подсистемы УправленияДоступом в режиме ограничения доступа на уровне записей.
// 
//  При включенном режиме ограничения доступа на уровне записей заполняет наборы
// значений доступа. Заполнение выполняется частями при каждом запуске, пока все
// наборы значений доступа не будут заполнены.
//  При отключении режима ограничения доступа на уровне записей наборы значений доступа
// (заполненные ранее) удаляются при перезаписи объектов, а не все сразу.
//  Независимо от режима ограничения доступа на уровне записей обновляет кэш-реквизиты.
//  После завершения всех обновлений и заполнений отключает использование регламентного задания.
//
//  Сведения о состоянии работы записываются в журнал регистрации.
//
//  Возможно вызывать программно, например, при обновлении информационной базы.
// Также для целей обновления есть форма Справочник.ГруппыДоступа.ОбновлениеДанныхОграниченияДоступа,
// с помощью которой можно сделать интерактивное обновление данных ограничения доступа
// при обновлении информационной базы.
//
Процедура ЗаполнениеДанныхДляОграниченияДоступа(КоличествоДанных = 0, ТолькоКэшРеквизиты = Ложь, ЕстьИзменения = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Параметры = УправлениеДоступомСлужебныйПовтИсп.Параметры();
	ЗначенияДоступаСГруппами = Параметры.СвойстваВидовДоступа.ЗначенияДоступаСГруппами;
	
	Если УправлениеДоступом.ОграничиватьДоступНаУровнеЗаписей() И НЕ ТолькоКэшРеквизиты Тогда
		
		// Заполнение групп значений доступа в регистре сведений ГруппыЗначенийДоступа.
		Для каждого ИмяТаблицы Из ЗначенияДоступаСГруппами.ИменаТаблиц Цикл
			
			Если КоличествоДанных < 10000 Тогда
				
				Запрос = Новый Запрос;
				Запрос.Текст =
				"ВЫБРАТЬ ПЕРВЫЕ 10000
				|	ТекущаяТаблица.Ссылка КАК Ссылка
				|ИЗ
				|	&ТекущаяТаблица КАК ТекущаяТаблица
				|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				|		ПО ТекущаяТаблица.Ссылка = ГруппыЗначенийДоступа.ЗначениеДоступа
				|			И (ГруппыЗначенийДоступа.ГруппаДанных = 0)
				|ГДЕ
				|	ГруппыЗначенийДоступа.ЗначениеДоступа ЕСТЬ NULL ";
				
				Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекущаяТаблица", ИмяТаблицы);
				Значения = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
				
				РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьГруппыЗначенийДоступа(Значения, ЕстьИзменения);
				
				КоличествоДанных = КоличествоДанных + Значения.Количество();
			КонецЕсли;
			
		КонецЦикла;
		
		Если КоличествоДанных < 10000
		   И НЕ РегистрыСведений.УдалитьНаборыЗначенийДоступа.ПереместитьДанныеВНовыйРегистр() Тогда
			// Перед заполнением наборов значений доступа выполняется перенос
			// наборов значений доступа из старого регистра.
			Возврат;
			
		ИначеЕсли КоличествоДанных < 10000 Тогда
			
			// Заполнение регистра сведений НаборыЗначенийДоступа.
			ТипыОбъектов = УправлениеДоступомСлужебныйПовтИсп.ТипыОбъектовВПодпискахНаСобытия(
				"ЗаписатьНаборыЗначенийДоступа");
			
			Для каждого ОписаниеТипа Из ТипыОбъектов Цикл
				Тип = ОписаниеТипа.Ключ;
				
				Если КоличествоДанных < 10000 И Тип <> Тип("Строка") Тогда
				
					Запрос = Новый Запрос;
					Запрос.Текст =
					"ВЫБРАТЬ ПЕРВЫЕ 10000
					|	ТекущаяТаблица.Ссылка КАК Ссылка
					|ИЗ
					|	&ТекущаяТаблица КАК ТекущаяТаблица
					|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.НаборыЗначенийДоступа КАК РегистрСведенийНаборыЗначенийДоступа
					|		ПО ТекущаяТаблица.Ссылка = РегистрСведенийНаборыЗначенийДоступа.Объект
					|ГДЕ
					|	РегистрСведенийНаборыЗначенийДоступа.Объект ЕСТЬ NULL ";
					Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекущаяТаблица", Метаданные.НайтиПоТипу(Тип).ПолноеИмя());
					Выборка = Запрос.Выполнить().Выбрать();
					КоличествоДанных = КоличествоДанных + Выборка.Количество();
					
					Пока Выборка.Следующий() Цикл
						ОбновитьНаборыЗначенийДоступа(Выборка.Ссылка, ЕстьИзменения);
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Иначе
		РегистрыСведений.УдалитьНаборыЗначенийДоступа.ПереместитьДанныеВНовыйРегистр();
	КонецЕсли;
	
	// Обновление кэш-реквизитов в наборах значений доступа.
	Если КоличествоДанных < 10000 Тогда
		
		ТипыЗначенийДоступа          = Параметры.СвойстваВидовДоступа.ПоТипамЗначений;
		ТипыЗначенийДоступаСГруппами = Параметры.СвойстваВидовДоступа.ТипыЗначенийДоступаСГруппами;
		
		ТаблицаТиповЗначений = Новый ТаблицаЗначений;
		ТаблицаТиповЗначений.Колонки.Добавить("ТипЗначений", Метаданные.ОпределяемыеТипы.ЗначениеДоступа.Тип);
		Для каждого КлючИЗначение Из ТипыЗначенийДоступа Цикл
			ТаблицаТиповЗначений.Добавить().ТипЗначений = ПустаяСсылкаОбъектаМетаданных(КлючИЗначение.Ключ);
		КонецЦикла;
		
		ТаблицаТиповЗначенийСГруппами = Новый ТаблицаЗначений;
		ТаблицаТиповЗначенийСГруппами.Колонки.Добавить("ТипЗначений", Метаданные.ОпределяемыеТипы.ЗначениеДоступа.Тип);
		Для каждого КлючИЗначение Из ТипыЗначенийДоступаСГруппами Цикл
			ТаблицаТиповЗначенийСГруппами.Добавить().ТипЗначений = ПустаяСсылкаОбъектаМетаданных(КлючИЗначение.Ключ);
		КонецЦикла;
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ТаблицаТиповЗначений", ТаблицаТиповЗначений);
		Запрос.УстановитьПараметр("ТаблицаТиповЗначенийСГруппами", ТаблицаТиповЗначенийСГруппами);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ТаблицаТипов.ТипЗначений
		|ПОМЕСТИТЬ ТаблицаТиповЗначений
		|ИЗ
		|	&ТаблицаТиповЗначений КАК ТаблицаТипов
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	ТаблицаТипов.ТипЗначений
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ТаблицаТипов.ТипЗначений
		|ПОМЕСТИТЬ ТаблицаТиповЗначенийСГруппами
		|ИЗ
		|	&ТаблицаТиповЗначенийСГруппами КАК ТаблицаТипов
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	ТаблицаТипов.ТипЗначений
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ ПЕРВЫЕ 10000
		|	НаборыЗначенийДоступа.Объект,
		|	НаборыЗначенийДоступа.НомерНабора,
		|	НаборыЗначенийДоступа.ЗначениеДоступа,
		|	НаборыЗначенийДоступа.Уточнение,
		|	НаборыЗначенийДоступа.Чтение,
		|	НаборыЗначенийДоступа.Изменение
		|ИЗ
		|	РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначенийДоступа
		|ГДЕ
		|	ВЫБОР
		|			КОГДА НаборыЗначенийДоступа.СтандартноеЗначение <> ИСТИНА В
		|					(ВЫБРАТЬ ПЕРВЫЕ 1
		|						ИСТИНА
		|					ИЗ
		|						ТаблицаТиповЗначений КАК ТаблицаТиповЗначений
		|					ГДЕ
		|						ТИПЗНАЧЕНИЯ(ТаблицаТиповЗначений.ТипЗначений) = ТИПЗНАЧЕНИЯ(НаборыЗначенийДоступа.ЗначениеДоступа))
		|				ТОГДА ИСТИНА
		|			КОГДА НаборыЗначенийДоступа.СтандартноеЗначение = ИСТИНА
		|				ТОГДА НаборыЗначенийДоступа.ЗначениеБезГрупп = ИСТИНА В
		|						(ВЫБРАТЬ ПЕРВЫЕ 1
		|							ИСТИНА
		|						ИЗ
		|							ТаблицаТиповЗначенийСГруппами КАК ТаблицаТиповЗначенийСГруппами
		|						ГДЕ
		|							ТИПЗНАЧЕНИЯ(ТаблицаТиповЗначенийСГруппами.ТипЗначений) = ТИПЗНАЧЕНИЯ(НаборыЗначенийДоступа.ЗначениеДоступа))
		|			ИНАЧЕ НаборыЗначенийДоступа.ЗначениеБезГрупп = ИСТИНА
		|		КОНЕЦ";
		Выборка = Запрос.Выполнить().Выбрать();
		КоличествоДанных = КоличествоДанных + Выборка.Количество();
		
		Пока Выборка.Следующий() Цикл
			МенеджерЗаписи = РегистрыСведений.НаборыЗначенийДоступа.СоздатьМенеджерЗаписи();
			ЗаполнитьЗначенияСвойств(МенеджерЗаписи, Выборка);
			
			ТипЗначенияДоступа = ТипЗнч(Выборка.ЗначениеДоступа);
			
			Если ТипыЗначенийДоступа.Получить(ТипЗначенияДоступа) <> Неопределено Тогда
				МенеджерЗаписи.СтандартноеЗначение = Истина;
				Если ТипыЗначенийДоступаСГруппами.Получить(ТипЗначенияДоступа) = Неопределено Тогда
					МенеджерЗаписи.ЗначениеБезГрупп = Истина;
				КонецЕсли;
			КонецЕсли;
			
			МенеджерЗаписи.Записать();
			ЕстьИзменения = Истина;
		КонецЦикла;
	КонецЕсли;
	
	Если КоличествоДанных < 10000 Тогда
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Управление доступом.Заполнение данных для ограничения доступа'",
				 ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Информация,
			,
			,
			НСтр("ru = 'Завершено заполнение данных для ограничения доступа.'"),
			РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
			
		УстановитьЗаполнениеДанныхДляОграниченияДоступа(Ложь);
	Иначе
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Управление доступом.Заполнение данных для ограничения доступа'",
				 ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Информация,
			,
			,
			НСтр("ru = 'Выполнена запись части данных для ограничения доступа.'"),
			РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает использование регламентного задания заполнения данных управления доступом.
//
// Параметры:
// Использование - Булево - Истина, если задание нужно включить, иначе Ложь.
//
Процедура УстановитьЗаполнениеДанныхДляОграниченияДоступа(Знач Использование) Экспорт
	
	СтандартныеПодсистемыСервер.УстановитьИспользованиеПредопределенногоРегламентногоЗадания(
		Метаданные.РегламентныеЗадания.ЗаполнениеДанныхДляОграниченияДоступа, Использование);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с видами доступа.

// Возвращает Истина, если вид доступа включен по функциональным опциям для всех сеансов.
//
// Параметры:
//  ВидДоступа - Ссылка - пустая ссылка основного типа.
//             - Строка - имя вида доступа.
//
// Возвращаемое значение:
//  Булево.
//
Функция ВидДоступаИспользуется(Знач ВидДоступа) Экспорт
	
	Используется = Ложь;
	
	СвойстваВидаДоступа = СвойстваВидаДоступа(ВидДоступа);
	Если СвойстваВидаДоступа = Неопределено Тогда
		Возврат Используется;
	КонецЕсли;
	
	Если СвойстваВидаДоступа.Имя = "ВнешниеПользователи"
	 Или СвойстваВидаДоступа.Имя = "Пользователи" Тогда
		// Эти виды доступа не могут быть отключены по функциональным опциям.
		Возврат Истина;
	КонецЕсли;
	
	Используется = Истина;
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.УправлениеДоступом\ПриЗаполненииИспользованияВидаДоступа");
	
	Для Каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриЗаполненииИспользованияВидаДоступа(СвойстваВидаДоступа.Имя, Используется);
	КонецЦикла;
	
	УправлениеДоступомПереопределяемый.ПриЗаполненииИспользованияВидаДоступа(СвойстваВидаДоступа.Имя, Используется);
	
	Возврат Используется;
	
КонецФункции

// Возвращает свойства вида доступа или всех видов доступа.
//
// Параметры:
//  ВидДоступа - Ссылка - пустая ссылка основного типа;
//             - Строка - имя вида доступа;
//             - Неопределено - вернуть массив свойств всех видов доступа.
//
// Возвращаемое значение:
//  Неопределено - когда для вида доступа свойств не найдено,
//  Структура - свойства найденного вида доступа,
//  Массив Структур со свойствами,
//      описание которых см. в комментарии к функции
//      СвойстваВидовДоступа в модуле менеджера константы ПараметрыОграниченияДоступа.
//
Функция СвойстваВидаДоступа(Знач ВидДоступа = Неопределено) Экспорт
	
	Свойства = УправлениеДоступомСлужебныйПовтИсп.Параметры().СвойстваВидовДоступа;
	
	Если ВидДоступа = Неопределено Тогда
		Возврат Свойства.Массив;
	КонецЕсли;
	
	СвойстваВидаДоступа = Свойства.ПоИменам.Получить(ВидДоступа);
	
	Если СвойстваВидаДоступа = Неопределено Тогда
		СвойстваВидаДоступа = Свойства.ПоСсылкам.Получить(ВидДоступа);
	КонецЕсли;
	
	Возврат СвойстваВидаДоступа;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с наборами значений доступа.

// Возвращает новые наборы для заполнения табличной части.
Функция ПолучитьНаборыЗначенийДоступаТабличнойЧасти(Объект) Экспорт
	
	СсылкаНаОбъект = Объект.Ссылка;
	ТипЗначенияОбъект = ТипЗнч(Объект);
	
	Если Объект.Метаданные().ТабличныеЧасти.Найти("НаборыЗначенийДоступа") = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверные параметры.
			           |У объекта типа ""%1""
			           |не найдена табличная часть ""Наборы значений доступа"".'"),
			ТипЗначенияОбъект);
	КонецЕсли;
	
	Таблица = УправлениеДоступом.ТаблицаНаборыЗначенийДоступа();
	
	Если НЕ УправлениеДоступом.ОграничиватьДоступНаУровнеЗаписей() Тогда
		Возврат Таблица;
	КонецЕсли;
	
	УправлениеДоступом.ЗаполнитьНаборыЗначенийДоступа(Объект, Таблица);
	
	УправлениеДоступом.ДобавитьНаборыЗначенийДоступа(
		Таблица, УправлениеДоступом.ТаблицаНаборыЗначенийДоступа(), Ложь, Истина);
	
	Возврат Таблица;
	
КонецФункции

// Выполняет обновление наборов значений доступа объекта, если они изменились.
// Наборы обновляются в табличной части (если используется) и
// в регистре сведений НаборыЗначенийДоступа.
//
// Параметры:
//  СсылкаИлиОбъект - СправочникСсылка, ДокументСсылка и другие типы ссылок или объектов - ссылка или объект,
//                    для которого заполняются наборы значений доступа.
//
//  ОбновлениеИБ    - Булево - если Истина, то необходимо выполнять запись данных,
//                            не выполняя лишних, избыточных действий с данными.
//                            См. ОбновлениеИнформационнойБазы.ЗаписатьДанные.
//
Процедура ОбновитьНаборыЗначенийДоступа(СсылкаИлиОбъект, ЕстьИзменения = Неопределено, ОбновлениеИБ = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Объект = ?(СсылкаИлиОбъект = СсылкаИлиОбъект.Ссылка, СсылкаИлиОбъект.ПолучитьОбъект(), СсылкаИлиОбъект);
	СсылкаНаОбъект = Объект.Ссылка;
	ТипЗначенияОбъект = ТипЗнч(Объект);
	
	НаборыЗаписываются = УправлениеДоступомСлужебныйПовтИсп.ТипыОбъектовВПодпискахНаСобытия(
		"ЗаписатьНаборыЗначенийДоступа").Получить(ТипЗначенияОбъект) <> Неопределено;
	
	Если НЕ НаборыЗаписываются Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверные параметры.
			           |Тип объекта ""%1""
			           |не найден в подписке на события
			           |""Записать наборы значений доступа"".'"),
			ТипЗначенияОбъект);
	КонецЕсли;
	
	Если Метаданные.РегистрыСведений.НаборыЗначенийДоступа.Измерения.Объект.Тип.Типы().Найти(ТипЗнч(СсылкаНаОбъект)) = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка при записи наборов значений доступа:
			           |в регистре сведений НаборыЗначенийДоступа в измерении Объект
			           |не задан тип %1'"),
			СсылкаНаОбъект.Метаданные().ПолноеИмя());
	КонецЕсли;
	
	Если СсылкаНаОбъект.Метаданные().ТабличныеЧасти.Найти("НаборыЗначенийДоступа") <> Неопределено Тогда
		// Обновление объекта требуется.
		Таблица = ПолучитьНаборыЗначенийДоступаТабличнойЧасти(Объект);
		
		Если НаборыЗначенийДоступаТабличнойЧастиИзменены(СсылкаНаОбъект, Таблица) Тогда
			ПодготовитьНаборыЗначенийДоступаКЗаписи(Неопределено, Таблица, Ложь);
			
			Объект.ДополнительныеСвойства.Вставить("ЗаписатьНаборыЗначенийДоступа");
			Объект.ДополнительныеСвойства.Вставить("ЗаписатьЗависимыеНаборыЗначенийДоступа");
			Объект.ДополнительныеСвойства.Вставить("НаборыЗначенийДоступаТабличнойЧастиЗаполнены");
			Объект.НаборыЗначенийДоступа.Загрузить(Таблица);
			Если ОбновлениеИБ Тогда
				Объект.ДополнительныеСвойства.Вставить("ЗаписьНаборовЗначенийДоступаПриОбновленииИБ");
				ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
			Иначе
				Объект.ОбменДанными.Загрузка = Истина;
				Объект.Записать();
			КонецЕсли;
			ЕстьИзменения = Истина;
		КонецЕсли;
	КонецЕсли;
	
	// Обновление объекта не требуется или объект уже обновлен.
	ЗаписатьНаборыЗначенийДоступа(Объект, ЕстьИзменения, ОбновлениеИБ);
	
КонецПроцедуры

// Заполняет вспомогательные данные, ускоряющие работу шаблонов ограничений доступа.
//  Выполняется перед записью в регистр НаборыЗначенийДоступа.
//
// Параметры:
//  СсылкаНаОбъект - СправочникСсылка.*, ДокументСсылка.*, ...
//  Таблица        - ТаблицаЗначений.
//
Процедура ПодготовитьНаборыЗначенийДоступаКЗаписи(СсылкаНаОбъект, Таблица, ДобавитьКэшРеквизиты = Ложь) Экспорт
	
	Если ДобавитьКэшРеквизиты Тогда
		
		Таблица.Колонки.Добавить("Объект", Метаданные.РегистрыСведений.НаборыЗначенийДоступа.Измерения.Объект.Тип);
		Таблица.Колонки.Добавить("СтандартноеЗначение", Новый ОписаниеТипов("Булево"));
		Таблица.Колонки.Добавить("ЗначениеБезГрупп", Новый ОписаниеТипов("Булево"));
		
		Параметры = УправлениеДоступомСлужебныйПовтИсп.Параметры();
		
		ТипыЗначенийДоступаСГруппами = Параметры.СвойстваВидовДоступа.ТипыЗначенийДоступаСГруппами;
		ТипыЗначенийДоступа          = Параметры.СвойстваВидовДоступа.ПоТипамЗначений;
		ОтдельныеТаблицы             = Параметры.ВозможныеПраваДляНастройкиПравОбъектов.ОтдельныеТаблицы;
		ТипыВладельцевНастроекПрав   = Параметры.ВозможныеПраваДляНастройкиПравОбъектов.ПоТипамСсылок;
	КонецЕсли;
	
	// Нормализация ресурсов Чтение, Изменение.
	НомерНабора = -1;
	Для каждого Строка Из Таблица Цикл
		
		Если ДобавитьКэшРеквизиты Тогда
			// Установка значения измерения Объект.
			Строка.Объект = СсылкаНаОбъект;
			
			ТипЗначенияДоступа = ТипЗнч(Строка.ЗначениеДоступа);
			
			Если ТипыЗначенийДоступа.Получить(ТипЗначенияДоступа) <> Неопределено Тогда
				Строка.СтандартноеЗначение = Истина;
				Если ТипыЗначенийДоступаСГруппами.Получить(ТипЗначенияДоступа) = Неопределено Тогда
					Строка.ЗначениеБезГрупп = Истина;
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
		// Очистка флажков прав и соответствующих им вторичных данных
		// для всех строк каждого набора, кроме первой строки.
		Если НомерНабора = Строка.НомерНабора Тогда
			Строка.Чтение    = Ложь;
			Строка.Изменение = Ложь;
		Иначе
			НомерНабора = Строка.НомерНабора;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для действий при изменений настроек подсистемы.

// Если необходимо, включает заполнение данных для ограничения доступа и
// обновляет некоторые данные сразу.
//
// Вызывается из обработчика ПриЗаписи константы ОграничиватьДоступаНаУровнеЗаписей.
//
Процедура ПриИзмененииОграниченияДоступаНаУровнеЗаписей(ОграничениеДоступаНаУровнеЗаписейВключено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ОграничениеДоступаНаУровнеЗаписейВключено Тогда
		
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Управление доступом.Заполнение данных для ограничения доступа'",
			     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Информация,
			,
			,
			НСтр("ru = 'Начато заполнение данных для ограничения доступа.'"),
			РежимТранзакцииЗаписиЖурналаРегистрации.Транзакционная);
		
		УстановитьЗаполнениеДанныхДляОграниченияДоступа(Истина);
	КонецЕсли;
	
	// Обновление параметров сеанса.
	// Требуется для того, чтобы администратор не выполнял перезапуск.
	УстановленныеПараметры = Новый Массив;
	УстановкаПараметровСеанса("", УстановленныеПараметры);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обслуживание таблиц ВидыДоступа и ЗначенияДоступа в формах редактирования.

// Заполняет вспомогательные данные, требуемые для работы формы,
// которые не зависят от содержания объекта или заполняются для нового объекта.
//
// Форма должна содержать реквизиты, указанные ниже.
// Реквизиты отмеченные символом * заполняются автоматически, но их нужно создать в форме.
// Реквизиты отмеченные символом # должны быть созданы в форме, если
// в форме будет создан реквизит ТекущаяГруппаДоступа (см. ниже).
// Реквизиты отмеченные символом @ будут созданы автоматически.
//
//  ТекущаяГруппаДоступа - необязательный реквизит,
//                         если не создан в форме, тогда не используется.
//
//  ВидыДоступа - Таблица с полями:
//    #ГруппаДоступа              - СправочникСсылка.ГруппыДоступа,
//    ВидДоступа                  - ОпределяемыйТип.ЗначениеДоступа,
//    Предустановленный           - Булево (только для профиля),
//    ВсеРазрешены                - Булево,
//    *ВидДоступаПредставление    - Строка - представление настройки,
//    *ВсеРазрешеныПредставление  - Строка - представление настройки,
//    @Используется               - Булево.
//
//  ЗначенияДоступа - Таблица с полями:
//    #ГруппаДоступа     - СправочникСсылка.ГруппыДоступа,
//    *ВидДоступа        - ОпределяемыйТип.ЗначениеДоступа,
//    ЗначениеДоступа    - ОпределяемыйТип.ЗначениеДоступа,
//    *НомерСтрокиПоВиду - Число.
//
//  *ИспользоватьВнешнихПользователей     - Булево - реквизит будет создан, если нет в форме.
//  *НадписьВидДоступа                    - Строка - представление текущего вида доступа в форме.
//  @ЭтоПрофильГруппДоступа               - Булево.
//  @ТекущийВидДоступа                    - ОпределяемыйТип.ЗначениеДоступа.
//  @ТекущиеТипыВыбираемыхЗначений        - СписокЗначений.
//  @ТекущийТипВыбираемыхЗначений         - ОпределяемыйТип.ЗначениеДоступа.
//  @ИмяРеквизитаХранилищаТаблиц          - Строка.
//  @ВидДоступаПользователи               - ОпределяемыйТип.ЗначениеДоступа.
//  @ВидДоступаВнешниеПользователи        - ОпределяемыйТип.ЗначениеДоступа.
//  
//  @ВсеВидыДоступа - Таблица с полями:
//    @Ссылка        - ОпределяемыйТип.ЗначениеДоступа,
//    @Представление - Строка,
//    @Используется  - Булево.
//
//  @ПредставленияВсеРазрешены - Таблица с полями:
//    @Имя           - Строка,
//    @Представление - Строка.
//
//  @ВсеТипыВыбираемыхЗначений - Таблица с полями:
//    @ВидДоступа        - ОпределяемыйТип.ЗначениеДоступа,
//    @ТипЗначений       - ОпределяемыйТип.ЗначениеДоступа,
//    @ПредставлениеТипа - Строка,
//    @ИмяТаблицы        - Строка.
//
// Параметры:
//  Форма      - УправляемаяФорма, которую требуется настроить для
//               редактирования разрешенных значений.
//
//  ЭтоПрофиль - Булево - указывает, что возможна настройка видов доступа
//               в том числе представление настройки содержит 4 значения, а не 2.
//
//  ИмяРеквизитаХранилищаТаблиц - Строка, содержащая, например, строку "Объект", которая
//               содержит таблицы ВидыДоступа и ЗначенияДоступа (см. ниже).
//               Если указана пустая строка, тогда считается,
//               что таблицы хранятся в реквизитах формы.
//
Процедура ПриСозданииНаСервереФормыРедактированияРазрешенныхЗначений(Форма, ЭтоПрофиль = Ложь, ИмяРеквизитаХранилищаТаблиц = "Объект") Экспорт
	
	ДобавитьРеквизитыВспомогательныхДанныхВФорму(Форма, ИмяРеквизитаХранилищаТаблиц);
	
	Форма.ИмяРеквизитаХранилищаТаблиц = ИмяРеквизитаХранилищаТаблиц;
	Форма.ЭтоПрофильГруппДоступа = ЭтоПрофиль;
	
	// Заполнение типов значений доступа всех видов доступа.
	Для каждого СвойстваВидаДоступа Из СвойстваВидаДоступа() Цикл
		Для каждого Тип Из СвойстваВидаДоступа.ТипыВыбираемыхЗначений Цикл
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(Тип);
			ОписаниеТипа = Новый ОписаниеТипов(МассивТипов);
			
			МетаданныеТипа = Метаданные.НайтиПоТипу(Тип);
			Если Метаданные.Перечисления.Найти(МетаданныеТипа.Имя) = МетаданныеТипа Тогда
				ПредставлениеТипа = МетаданныеТипа.Представление();
			Иначе
				ПредставлениеТипа = ?(ЗначениеЗаполнено(МетаданныеТипа.ПредставлениеОбъекта),
					МетаданныеТипа.ПредставлениеОбъекта,
					МетаданныеТипа.Представление());
			КонецЕсли;
			
			НоваяСтрока = Форма.ВсеТипыВыбираемыхЗначений.Добавить();
			НоваяСтрока.ВидДоступа        = СвойстваВидаДоступа.Ссылка;
			НоваяСтрока.ТипЗначений       = ОписаниеТипа.ПривестиЗначение(Неопределено);
			НоваяСтрока.ПредставлениеТипа = ПредставлениеТипа;
			НоваяСтрока.ИмяТаблицы        = МетаданныеТипа.ПолноеИмя();
		КонецЦикла;
	КонецЦикла;
	
	Форма.ВидДоступаПользователи           = Справочники.Пользователи.ПустаяСсылка();
	Форма.ВидДоступаВнешниеПользователи    = Справочники.ВнешниеПользователи.ПустаяСсылка();
	Форма.ИспользоватьВнешнихПользователей = ВнешниеПользователи.ИспользоватьВнешнихПользователей();
	
	ЗаполнитьТаблицуВсеВидыДоступаВФорме(Форма);
	
	ЗаполнитьТаблицуПредставленияВсеРазрешеныВФорме(Форма, ЭтоПрофиль);
	
	ОформитьТаблицуВидыДоступаВФорме(Форма);
	
	УдалитьНесуществующиеВидыИЗначенияДоступа(Форма);
	УправлениеДоступомСлужебныйКлиентСервер.ЗаполнитьСвойстваВидовДоступаВФорме(Форма);
	
	ОбновитьОтображениеНеиспользуемыхВидовДоступа(Форма, Истина);
	
	СтандартныеПодсистемыСервер.УстановитьОтображениеЗаголовковГрупп(
		Форма, "ЗначенияДоступаПоВидуДоступа");
	
	// Настройка параметров выбора значения доступа.
	ПараметрыВыбора = Новый Массив;
	ПараметрыВыбора.Добавить(Новый ПараметрВыбора("ЭтоВыборЗначенияДоступа", Истина));
	Форма.Элементы.ЗначенияДоступаЗначениеДоступа.ПараметрыВыбора = Новый ФиксированныйМассив(ПараметрыВыбора);
	
КонецПроцедуры

// При повторном чтении заполняет или обновляет вспомогательные данные,
// требуемые для работы формы, которые зависят от содержания объекта.
//
Процедура ПриПовторномЧтенииНаСервереФормыРедактированияРазрешенныхЗначений(Форма, ТекущийОбъект) Экспорт
	
	УдалитьНесуществующиеВидыИЗначенияДоступа(Форма, ТекущийОбъект);
	УдалитьНесуществующиеВидыИЗначенияДоступа(Форма);
	
	УправлениеДоступомСлужебныйКлиентСервер.ЗаполнитьСвойстваВидовДоступаВФорме(Форма);
	
	УправлениеДоступомСлужебныйКлиентСервер.ПриИзмененииТекущегоВидаДоступа(Форма);
	
КонецПроцедуры

// Удаляет лишние значения доступа перед записью.
// Лишние значения доступа могут появиться, если заменить или удалить вид доступа,
// для которого введены значения доступа.
//
Процедура ПередЗаписьюНаСервереФормыРедактированияРазрешенныхЗначений(Форма, ТекущийОбъект) Экспорт
	
	УдалитьЛишниеЗначенияДоступа(Форма, ТекущийОбъект);
	УдалитьЛишниеЗначенияДоступа(Форма);
	
КонецПроцедуры

// Обновляет свойства видов доступа.
Процедура ПослеЗаписиНаСервереФормыРедактированияРазрешенныхЗначений(Форма, ТекущийОбъект, ПараметрыЗаписи) Экспорт
	
	УправлениеДоступомСлужебныйКлиентСервер.ЗаполнитьСвойстваВидовДоступаВФорме(Форма);
	
КонецПроцедуры

// Скрывает или показывает неиспользуемые виды доступа.
Процедура ОбновитьОтображениеНеиспользуемыхВидовДоступа(Форма, ПриСозданииНаСервере = Ложь) Экспорт
	
	Элементы = Форма.Элементы;
	
	Если Не ПриСозданииНаСервере Тогда
		Элементы.ПоказыватьНеИспользуемыеВидыДоступа.Пометка =
			НЕ Элементы.ПоказыватьНеИспользуемыеВидыДоступа.Пометка;
	КонецЕсли;
	
	Отбор = УправлениеДоступомСлужебныйКлиентСервер.ОтборВТаблицахФормыРедактированияРазрешенныхЗначений(
		Форма);
	
	Если Не Элементы.ПоказыватьНеиспользуемыеВидыДоступа.Пометка Тогда
		Отбор.Вставить("Используется", Истина);
	КонецЕсли;
	
	Элементы.ВидыДоступа.ОтборСтрок = Новый ФиксированнаяСтруктура(Отбор);
	
	Элементы.ВидыДоступаВидДоступаПредставление.СписокВыбора.Очистить();
	
	Для каждого Строка Из Форма.ВсеВидыДоступа Цикл
		
		Если Не Элементы.ПоказыватьНеиспользуемыеВидыДоступа.Пометка
		   И Не Строка.Используется Тогда
			
			Продолжить;
		КонецЕсли;
		
		Элементы.ВидыДоступаВидДоступаПредставление.СписокВыбора.Добавить(Строка.Представление);
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Универсальные процедуры и функции.

// Только для внутреннего использования.
Процедура УстановитьУсловиеОтбораВЗапросе(Знач Запрос, Знач Значения, Знач ИмяПараметраЗначений, Знач ИмяПараметраУсловияОтбораИмяПоля) Экспорт
	
	Если Значения = Неопределено Тогда
		
	ИначеЕсли ТипЗнч(Значения) <> Тип("Массив")
	        И ТипЗнч(Значения) <> Тип("ФиксированныйМассив") Тогда
		
		Запрос.УстановитьПараметр(ИмяПараметраЗначений, Значения);
		
	ИначеЕсли Значения.Количество() = 1 Тогда
		Запрос.УстановитьПараметр(ИмяПараметраЗначений, Значения[0]);
	Иначе
		Запрос.УстановитьПараметр(ИмяПараметраЗначений, Значения);
	КонецЕсли;
	
	Для НомерСтроки = 1 По СтрЧислоСтрок(ИмяПараметраУсловияОтбораИмяПоля) Цикл
		ТекущаяСтрока = СтрПолучитьСтроку(ИмяПараметраУсловияОтбораИмяПоля, НомерСтроки);
		Если НЕ ЗначениеЗаполнено(ТекущаяСтрока) Тогда
			Продолжить;
		КонецЕсли;
		ИндексРазделителя = СтрНайти(ТекущаяСтрока, ":");
		Если ИндексРазделителя = 0 Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при выполнении процедуры УправлениеДоступом.УстановитьУсловиеОтбораВЗапросе().
				           |
				           |В параметре ИмяПараметраУсловияОтбораИмяПоля не найден разделитель (двоеточие)
				           |в следующей строке формата ""<Имя параметра условия>:<Имя поля>""
				           |""%1"".'"),
				ТекущаяСтрока);
		КонецЕсли;
		ИмяПараметраУсловияОтбора = Лев(ТекущаяСтрока, ИндексРазделителя-1);
		ИмяПоля = Сред(ТекущаяСтрока, ИндексРазделителя+1);
		Если Значения = Неопределено Тогда
			УсловиеОтбора = "Истина";
			
		ИначеЕсли ТипЗнч(Значения) <> Тип("Массив")
		        И ТипЗнч(Значения) <> Тип("ФиксированныйМассив") Тогда
			
			УсловиеОтбора = ИмяПоля + " = &" + ИмяПараметраЗначений;
			
		ИначеЕсли Значения.Количество() = 1 Тогда
			УсловиеОтбора = ИмяПоля + " = &" + ИмяПараметраЗначений;
		Иначе
			УсловиеОтбора = ИмяПоля + " В (&" + ИмяПараметраЗначений + ")";
		КонецЕсли;
		Запрос.Текст = СтрЗаменить(Запрос.Текст, ИмяПараметраУсловияОтбора, УсловиеОтбора);
	КонецЦикла;
	
КонецПроцедуры

// Обновляет набор записей в базе данных,
// если записи набора отличаются от записей в базе данных.
//
// Параметры:
//  Данные - Структура - со свойствами:
//    * НаборЗаписей           - НаборЗаписей пустой или прочитанный с заданным отбором или без отбора.
//                              Менеджер регистра для создания набора записей.
//
//    * НовыеЗаписи            - ТаблицаЗначений в формате регистра.
//
//    * ПоляСравнения          - Строка - содержит список полей по значениям которых требуется вычислять
//                               отличие записей набора. Например, "Измерение1, Измерение2, Ресурс1",
//                               а реквизит ДатаИзмерения не входит в список.
//
//    * ПолеОтбора             - Неопределено - записывается весь регистр или
//                                              отбор уже задан в наборе записей.
//                               Строка       - имя поля по которому нужно установить отбор.
//
//    * ЗначениеОтбора         - значение, которое будет установлено в качестве отбора по полю отбора,
//                               если поле отбора задано.
//
//    * НаборЗаписейПрочитан   - Булево, если Истина, тогда не заданный набор записей уже содержит
//                               прочитанные записи блокировка данных этих записей установлена и
//                               транзакция открыта.
//
//    * ТолькоПроверка         - Булево - если Истина, тогда не выполнять запись,
//                               а лишь выявить необходимость записи и установить
//                               свойство ЕстьИзменения.
//
//    * ДополнительныеСвойства - Неопределено, Структура. Если Структура, тогда в
//                               объекты <Регистр*>НаборЗаписей в свойство
//                               ДополнительныеСвойства будут вставлены все параметры структуры.
//
//    * ОбновлениеИБ           - Булево - если Истина, то необходимо выполнять запись данных, 
//                               не выполняя лишних, избыточных действий с данными.
//                               См. ОбновлениеИнформационнойБазы.ЗаписатьДанные.
//
//  ЕстьИзменения         - Булево (возвращаемое значение) - если производилась запись,
//                          устанавливается Истина, иначе не изменяется.
//
//  ИзмененныеЗаписи      - Неопределено - никаких действий, иначе
//                          возвращает таблицу значений в формате регистра с полем ВидИзмененияСтроки
//                          типа Число (-1 запись удалена, 1 запись добавлена).
//
//  ТранзакцияОткрыта     - Неопределено    - не открывать транзакцию.
//                          Истина          - транзакция уже открыта, ее не требуется открывать.
//                          Другое значение - требуется открыть транзакцию и
//                                            установить ТранзакцияОткрыта в Истина.
//
Процедура ОбновитьНаборЗаписей(Знач Данные, ЕстьИзменения = Неопределено,
		ИзмененныеЗаписи = Неопределено, ТранзакцияОткрыта = Неопределено) Экспорт
	
	ВсеПараметры = Новый Структура;
	ВсеПараметры.Вставить("НаборЗаписей");
	ВсеПараметры.Вставить("НовыеЗаписи");
	ВсеПараметры.Вставить("ПоляСравнения");
	ВсеПараметры.Вставить("ПолеОтбора");
	ВсеПараметры.Вставить("ЗначениеОтбора");
	ВсеПараметры.Вставить("НаборЗаписейПрочитан", Ложь);
	ВсеПараметры.Вставить("БезПерезаписи", Ложь);
	ВсеПараметры.Вставить("ТолькоПроверка", Ложь);
	ВсеПараметры.Вставить("ДополнительныеСвойства");
	ВсеПараметры.Вставить("ОбновлениеИБ", Ложь);
	ЗаполнитьПараметры(Данные, ВсеПараметры, "НаборЗаписей, НовыеЗаписи");
	
	ПолноеИмяРегистра = Метаданные.НайтиПоТипу(ТипЗнч(Данные.НаборЗаписей)).ПолноеИмя();
	МенеджерРегистра = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмяРегистра);
	Если Данные.НаборЗаписей = МенеджерРегистра Тогда
		Данные.НаборЗаписей = МенеджерРегистра.СоздатьНаборЗаписей();
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Данные.ПолеОтбора) Тогда
		УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ПолеОтбора], Данные.ЗначениеОтбора);
	КонецЕсли;
	
	Если НЕ Данные.НаборЗаписейПрочитан Тогда
		ЗаблокироватьОбластьНабораЗаписей(Данные.НаборЗаписей, ПолноеИмяРегистра);
		Данные.НаборЗаписей.Прочитать();
	КонецЕсли;
	
	Данные.ПоляСравнения = ?(Данные.ПоляСравнения = Неопределено,
		ПоляНабораЗаписей(Данные.НаборЗаписей), Данные.ПоляСравнения);
	
	Если Данные.БезПерезаписи Тогда
		НаборЗаписи = МенеджерРегистра.СоздатьНаборЗаписей();
		ОписаниеКлючаЗаписи = УправлениеДоступомСлужебныйПовтИсп.ОписаниеКлючаЗаписи(ПолноеИмяРегистра);
		ОтборЗаписи = Новый Структура(ОписаниеКлючаЗаписи.СтрокаПолей);
		ПоляОстальныхИзмерений = Новый Массив;
		Для каждого Поле Из ОписаниеКлючаЗаписи.МассивПолей Цикл
			Если Поле <> Данные.ПолеОтбора Тогда
				ПоляОстальныхИзмерений.Добавить(Поле);
			КонецЕсли;
		КонецЦикла;
		УдаляемыеЗаписи = Новый ТаблицаЗначений;
		Для каждого Поле Из ПоляОстальныхИзмерений Цикл
			УдаляемыеЗаписи.Колонки.Добавить(Поле);
		КонецЦикла;
		Данные.НовыеЗаписи = Данные.НовыеЗаписи.Скопировать();
	КонецЕсли;
	
	ЕстьТекущиеИзменения = Ложь;
	Если ИзмененныеЗаписи = Неопределено Тогда
		Если Данные.НаборЗаписей.Количество() = Данные.НовыеЗаписи.Количество() ИЛИ Данные.БезПерезаписи Тогда
			Отбор = Новый Структура(Данные.ПоляСравнения);
			Данные.НовыеЗаписи.Индексы.Добавить(Данные.ПоляСравнения);
			Для каждого Запись Из Данные.НаборЗаписей Цикл
				ЗаполнитьЗначенияСвойств(Отбор, Запись);
				НайденныеСтроки = Данные.НовыеЗаписи.НайтиСтроки(Отбор);
				Если НайденныеСтроки.Количество() = 0 Тогда
					ЕстьТекущиеИзменения = Истина;
					ЕстьИзменения = Истина;
					Если Данные.БезПерезаписи Тогда
						ЗаполнитьЗначенияСвойств(ОтборЗаписи, Запись);
						Если Данные.НовыеЗаписи.НайтиСтроки(ОтборЗаписи).Количество() = 0 Тогда
							ЗаполнитьЗначенияСвойств(УдаляемыеЗаписи.Добавить(), ОтборЗаписи);
						КонецЕсли;
					Иначе
						Прервать;
					КонецЕсли;
				ИначеЕсли Данные.БезПерезаписи Тогда
					Данные.НовыеЗаписи.Удалить(НайденныеСтроки[0]);
				КонецЕсли;
			КонецЦикла;
			Если Данные.БезПерезаписи И Данные.НовыеЗаписи.Количество() > 0 Тогда
				ЕстьТекущиеИзменения = Истина;
				ЕстьИзменения = Истина;
			КонецЕсли;
		Иначе
			ЕстьТекущиеИзменения = Истина;
			ЕстьИзменения = Истина;
		КонецЕсли;
	Иначе
		Если Данные.НаборЗаписей.Количество() <> Данные.НовыеЗаписи.Количество() Тогда
			ЕстьТекущиеИзменения = Истина;
			ЕстьИзменения = Истина;
		КонецЕсли;
		Если Данные.НаборЗаписей.Количество() > Данные.НовыеЗаписи.Количество() Тогда
			ИзмененныеЗаписи = Данные.НаборЗаписей.Выгрузить();
			ИскомыеЗаписи   = Данные.НовыеЗаписи;
			ВидИзмененияСтроки = -1;
		Иначе
			ИзмененныеЗаписи = Данные.НовыеЗаписи.Скопировать();
			ИскомыеЗаписи   = Данные.НаборЗаписей.Выгрузить();
			ВидИзмененияСтроки = 1;
		КонецЕсли;
		ИзмененныеЗаписи.Колонки.Добавить("ВидИзмененияСтроки", Новый ОписаниеТипов("Число"));
		ИзмененныеЗаписи.ЗаполнитьЗначения(ВидИзмененияСтроки, "ВидИзмененияСтроки");
		ВидИзмененияСтроки = ?(ВидИзмененияСтроки = 1, -1, 1);
		Отбор = Новый Структура(Данные.ПоляСравнения);
		
		Для каждого Строка Из ИскомыеЗаписи Цикл
			ЗаполнитьЗначенияСвойств(Отбор, Строка);
			Строки = ИзмененныеЗаписи.НайтиСтроки(Отбор);
			Если Строки.Количество() = 0 Тогда
				НоваяСтрока = ИзмененныеЗаписи.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, Отбор);
				НоваяСтрока.ВидИзмененияСтроки = ВидИзмененияСтроки;
				ЕстьТекущиеИзменения = Истина;
				ЕстьИзменения = Истина;
			Иначе
				ИзмененныеЗаписи.Удалить(Строки[0]);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если ЕстьТекущиеИзменения Тогда
		Если Данные.ТолькоПроверка Тогда
			Возврат;
		КонецЕсли;
		Если ТранзакцияОткрыта <> Неопределено // Требуется использовать внешнюю транзакцию.
		   И ТранзакцияОткрыта <> Истина Тогда // Внешняя транзакция еще не открыта.
			// Открытие внешней транзакции.
			НачатьТранзакцию();
			ТранзакцияОткрыта = Истина;
		КонецЕсли;
		Если Данные.БезПерезаписи Тогда
			УстановитьДополнительныеСвойства(НаборЗаписи, Данные.ДополнительныеСвойства);
			Для каждого Строка Из УдаляемыеЗаписи Цикл
				Если ЗначениеЗаполнено(Данные.ПолеОтбора) Тогда
					УстановитьОтбор(НаборЗаписи.Отбор[Данные.ПолеОтбора], Данные.ЗначениеОтбора);
				КонецЕсли;
				Для каждого Поле Из ПоляОстальныхИзмерений Цикл
					УстановитьОтбор(НаборЗаписи.Отбор[Поле], Строка[Поле]);
				КонецЦикла;
				ЗаписатьОбъектИлиНаборЗаписей(Данные, НаборЗаписи);
			КонецЦикла;
			НаборЗаписи.Добавить();
			Для каждого Строка Из Данные.НовыеЗаписи Цикл
				Если ЗначениеЗаполнено(Данные.ПолеОтбора) Тогда
					УстановитьОтбор(НаборЗаписи.Отбор[Данные.ПолеОтбора], Данные.ЗначениеОтбора);
				КонецЕсли;
				Для каждого Поле Из ПоляОстальныхИзмерений Цикл
					УстановитьОтбор(НаборЗаписи.Отбор[Поле], Строка[Поле]);
				КонецЦикла;
				ЗаполнитьЗначенияСвойств(НаборЗаписи[0], Строка);
				ЗаписатьОбъектИлиНаборЗаписей(Данные, НаборЗаписи);
			КонецЦикла;
		Иначе
			УстановитьДополнительныеСвойства(Данные.НаборЗаписей, Данные.ДополнительныеСвойства);
			Данные.НаборЗаписей.Загрузить(Данные.НовыеЗаписи);
			ЗаписатьОбъектИлиНаборЗаписей(Данные, Данные.НаборЗаписей);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Обновляет строки регистра с отбором по нескольким значениям для одного или
// для двух измерений регистра, выполняется проверка наличия изменений,
// если изменений нет, перезапись не производится.
//
// Параметры:
//  Данные - Структура - со свойствами:
//    * МенеджерРегистра          - Менеджер регистра для создания типа <Регистр*>НаборЗаписей.
//
//    * НовыеЗаписи               - ТаблицаЗначений в формате регистра.
//
//    * ПоляСравнения             - Строка - содержит список полей по значениям которых требуется
//                                  вычислять отличие записей набора, например, "Измерение1, Измерение2,
//                                  Ресурс1", а реквизит ДатаИзменения не входит в список.
//
//    * ИмяПервогоИзмерения       - Неопределено - нет отбора по измерению.
//                                  Строка       - содержит имя первого измерения, для которого задано
//                                                 несколько значений.
//
//    * ЗначенияПервогоИзмерения  - Неопределено - нет отбора по измерению, аналогично,
//                                                 ИмяПервогоИзмерения = Неопределено.
//                                  ЛюбаяСсылка  - содержит одно значение отбора регистра для
//                                                 обновляемых записей.
//                                  Массив       - содержит массив значений отбора регистра для
//                                                 обновляемых записей, пустой массив - значит
//                                                 действий не требуется.
//
//    * ИмяВторогоИзмерения       - аналогично ИмяПервогоИзмерения.
//    * ЗначенияВторогоИзмерения  - аналогично ЗначенияПервогоИзмерения.
//    * ИмяТретьегоИзмерения      - аналогично ИмяПервогоИзмерения.
//    * ЗначенияТретьегоИзмерения - аналогично ЗначенияПервогоИзмерения.
//
//    * ТолькоПроверка            - Булево - если Истина, тогда не выполнять запись,
//                                  а лишь выявить необходимость записи и установить
//                                  свойство ЕстьИзменения.
//
//    * ДополнительныеСвойства    - Неопределено, Структура. Если Структура, тогда в
//                                  объекты <Регистр*>НаборЗаписей в свойство
//                                  ДополнительныеСвойства будут вставлены все параметры структуры.
//
//    * ОбновлениеИБ              - Булево - если Истина, то необходимо выполнять запись данных, 
//                                  не выполняя лишних, избыточных действий с данными.
//                                  См. ОбновлениеИнформационнойБазы.ЗаписатьДанные.
//
//  ЕстьИзменения             - Булево (возвращаемое значение) - если производилась запись,
//                              устанавливается Истина, иначе не изменяется.
//
Процедура ОбновитьНаборыЗаписей(Знач Данные, ЕстьИзменения) Экспорт
	
	ВсеПараметры = Новый Структура;
	ВсеПараметры.Вставить("МенеджерРегистра");
	ВсеПараметры.Вставить("НовыеЗаписи");
	ВсеПараметры.Вставить("ПоляСравнения");
	ВсеПараметры.Вставить("ИмяПервогоИзмерения");
	ВсеПараметры.Вставить("ЗначенияПервогоИзмерения");
	ВсеПараметры.Вставить("ИмяВторогоИзмерения");
	ВсеПараметры.Вставить("ЗначенияВторогоИзмерения");
	ВсеПараметры.Вставить("ИмяТретьегоИзмерения");
	ВсеПараметры.Вставить("ЗначенияТретьегоИзмерения");
	ВсеПараметры.Вставить("НовыеЗаписиСодержатТолькоРазличия", Ложь);
	ВсеПараметры.Вставить("ФиксированныйОтбор");
	ВсеПараметры.Вставить("ТолькоПроверка", Ложь);
	ВсеПараметры.Вставить("ДополнительныеСвойства");
	ВсеПараметры.Вставить("ОбновлениеИБ", Ложь);
	ЗаполнитьПараметры(Данные, ВсеПараметры, "МенеджерРегистра, НовыеЗаписи");
	
	// Предварительная обработка параметров.
	
	Если НЕ ГруппаПараметровИзмеренияОбработана(Данные.ИмяПервогоИзмерения, Данные.ЗначенияПервогоИзмерения) Тогда
		ЕстьИзменения = Истина;
		Возврат;
	КонецЕсли;
	Если НЕ ГруппаПараметровИзмеренияОбработана(Данные.ИмяВторогоИзмерения, Данные.ЗначенияВторогоИзмерения) Тогда
		ЕстьИзменения = Истина;
		Возврат;
	КонецЕсли;
	Если НЕ ГруппаПараметровИзмеренияОбработана(Данные.ИмяТретьегоИзмерения, Данные.ЗначенияТретьегоИзмерения) Тогда
		ЕстьИзменения = Истина;
		Возврат;
	КонецЕсли;
	
	УпорядочитьГруппыПараметровИзмерений(Данные);
	
	// Проверка и обновление данных.
	Данные.Вставить("ТранзакцияОткрыта",  ?(ТранзакцияАктивна(), Неопределено, Ложь));
	Данные.Вставить("НаборЗаписей",       Данные.МенеджерРегистра.СоздатьНаборЗаписей());
	Данные.Вставить("МетаданныеРегистра", Метаданные.НайтиПоТипу(ТипЗнч(Данные.НаборЗаписей)));
	Данные.Вставить("ПолноеИмяРегистра",  Данные.МетаданныеРегистра.ПолноеИмя());
	
	Если Данные.НовыеЗаписиСодержатТолькоРазличия Тогда
		Данные.Вставить("НаборДляОднойЗаписи", Данные.МенеджерРегистра.СоздатьНаборЗаписей());
	КонецЕсли;
	
	Если Данные.ФиксированныйОтбор <> Неопределено Тогда
		Для каждого КлючИЗначение Из Данные.ФиксированныйОтбор Цикл
			УстановитьОтбор(Данные.НаборЗаписей.Отбор[КлючИЗначение.Ключ], КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Попытка
		Если Данные.НовыеЗаписиСодержатТолькоРазличия Тогда
			
			Если Данные.ИмяПервогоИзмерения = Неопределено Тогда
				ВызватьИсключение
					НСтр("ru = 'Некорректные параметры в процедуре ОбновитьНаборыЗаписей.'");
			Иначе
				Если Данные.ИмяВторогоИзмерения = Неопределено Тогда
					ЗаписьНесколькимиНаборами = Ложь;
				Иначе
					ЗаписьНесколькимиНаборами = ЗаписьНесколькимиНаборами(
						Данные, Новый Структура, Данные.ИмяПервогоИзмерения, Данные.ЗначенияПервогоИзмерения);
				КонецЕсли;
				
				Если ЗаписьНесколькимиНаборами Тогда
					СписокПолей = Данные.ИмяПервогоИзмерения + ", " + Данные.ИмяВторогоИзмерения;
					Данные.НовыеЗаписи.Индексы.Добавить(СписокПолей);
					
					КоличествоПоЗначениямПервогоИзмерения = Данные.КоличествоПоЗначениям;
					
					Для каждого ПервоеЗначение Из Данные.ЗначенияПервогоИзмерения Цикл
						Отбор = Новый Структура(Данные.ИмяПервогоИзмерения, ПервоеЗначение);
						УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ИмяПервогоИзмерения], ПервоеЗначение);
						
						Если Данные.ИмяТретьегоИзмерения = Неопределено Тогда
							ЗаписьНесколькимиНаборами = Ложь;
						Иначе
							ЗаписьНесколькимиНаборами = ЗаписьНесколькимиНаборами(
								Данные, Отбор, Данные.ИмяВторогоИзмерения, Данные.ЗначенияВторогоИзмерения);
						КонецЕсли;
						
						Если ЗаписьНесколькимиНаборами Тогда
							Для каждого ВтороеЗначение Из Данные.ЗначенияВторогоИзмерения Цикл
								Отбор.Вставить(Данные.ИмяВторогоИзмерения, ВтороеЗначение);
								УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ИмяВторогоИзмерения], ВтороеЗначение);
								
								// Обновление по трем измерениям.
								ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(Данные, Отбор, ЕстьИзменения);
							КонецЦикла;
							Данные.НаборЗаписей.Отбор[Данные.ИмяВторогоИзмерения].Использование = Ложь;
						Иначе
							// Обновление по двум измерениям.
							Данные.Вставить("КоличествоПоЗначениям", КоличествоПоЗначениямПервогоИзмерения);
							ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(Данные, Отбор, ЕстьИзменения);
						КонецЕсли;
					КонецЦикла;
				Иначе
					// Обновление по одному измерению.
					ПрочитатьКоличествоДляЧтения(Данные);
					ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(Данные, Новый Структура, ЕстьИзменения);
				КонецЕсли;
			КонецЕсли;
		Иначе
			Если Данные.ИмяПервогоИзмерения = Неопределено Тогда
				// Обновление всех записей.
				
				ТекущиеДанные = Новый Структура("НаборЗаписей, НовыеЗаписи, ПоляСравнения, ТолькоПроверка, ДополнительныеСвойства");
				ЗаполнитьЗначенияСвойств(ТекущиеДанные, Данные);
				ОбновитьНаборЗаписей(ТекущиеДанные, ЕстьИзменения, , Данные.ТранзакцияОткрыта);
				
			ИначеЕсли Данные.ИмяВторогоИзмерения = Неопределено Тогда
				// Обновление по одному измерению.
				Отбор = Новый Структура(Данные.ИмяПервогоИзмерения);
				Для каждого Значение Из Данные.ЗначенияПервогоИзмерения Цикл
					
					УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ИмяПервогоИзмерения], Значение);
					Отбор[Данные.ИмяПервогоИзмерения] = Значение;
					
					Если Данные.ЗначенияПервогоИзмерения.Количество() <> 1 Тогда
						НовыеЗаписиНабора = Данные.НовыеЗаписи;
					Иначе
						НовыеЗаписиНабора = Данные.НовыеЗаписи.Скопировать(Отбор);
					КонецЕсли;
					
					ТекущиеДанные = Новый Структура("НаборЗаписей, ПоляСравнения, ТолькоПроверка, ДополнительныеСвойства");
					ЗаполнитьЗначенияСвойств(ТекущиеДанные, Данные);
					ТекущиеДанные.Вставить("НовыеЗаписи", НовыеЗаписиНабора);
					
					ОбновитьНаборЗаписей(ТекущиеДанные, ЕстьИзменения, , Данные.ТранзакцияОткрыта);
				КонецЦикла;
				
			ИначеЕсли Данные.ИмяТретьегоИзмерения = Неопределено Тогда
				// Обновление по двум измерениям.
				СписокПолей = Данные.ИмяПервогоИзмерения + ", " + Данные.ИмяВторогоИзмерения;
				Данные.НовыеЗаписи.Индексы.Добавить(СписокПолей);
				Отбор = Новый Структура(СписокПолей);
				
				Для каждого ПервоеЗначение Из Данные.ЗначенияПервогоИзмерения Цикл
					УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ИмяПервогоИзмерения], ПервоеЗначение);
					Отбор[Данные.ИмяПервогоИзмерения] = ПервоеЗначение;
					
					ОбновитьНовыеЗаписиНабораПоВсемНовымЗаписям(
						Данные,
						Отбор,
						СписокПолей,
						Данные.ИмяВторогоИзмерения,
						Данные.ЗначенияВторогоИзмерения,
						ЕстьИзменения);
				КонецЦикла;
			Иначе
				// Обновление по трем измерениям.
				СписокПолей = Данные.ИмяПервогоИзмерения + ", " + Данные.ИмяВторогоИзмерения + ", " + Данные.ИмяТретьегоИзмерения;
				Данные.НовыеЗаписи.Индексы.Добавить(СписокПолей);
				Отбор = Новый Структура(СписокПолей);
				
				Для каждого ПервоеЗначение Из Данные.ЗначенияПервогоИзмерения Цикл
					УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ИмяПервогоИзмерения], ПервоеЗначение);
					Отбор[Данные.ИмяПервогоИзмерения] = ПервоеЗначение;
					
					Для каждого ВтороеЗначение Из Данные.ЗначенияВторогоИзмерения Цикл
						УстановитьОтбор(Данные.НаборЗаписей.Отбор[Данные.ИмяВторогоИзмерения], ВтороеЗначение);
						Отбор[Данные.ИмяВторогоИзмерения] = ВтороеЗначение;
						
						ОбновитьНовыеЗаписиНабораПоВсемНовымЗаписям(
							Данные,
							Отбор,
							СписокПолей,
							Данные.ИмяВторогоИзмерения,
							Данные.ЗначенияВторогоИзмерения,
							ЕстьИзменения);
					КонецЦикла;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		Если Данные.ТранзакцияОткрыта = Истина Тогда
			ЗафиксироватьТранзакцию();
		КонецЕсли;
	Исключение
		Если Данные.ТранзакцияОткрыта = Истина Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Обновляет регистр сведений по данным в таблице значений ИзмененияСтрок.
//
// Параметры:
//  Данные - Структура - со свойствами:
//
//  * МенеджерРегистра       - Менеджер регистра для создания типа <Регистр*>НаборЗаписей.
//
//  * ИзмененияСоставаСтрок  - ТаблицаЗначений, содержащей поля регистра и
//                             поле ВидИзмененияСтроки (Число):
//                                1 - значит, что строку нужно добавить,
//                               -1 - значит, что строку нужно удалить.
//
//  * ФиксированныйОтбор     - Структура, содержащая имя измерения в ключе и значение
//                             отбора в значении. Может быть указана, когда измерений
//                             более 3-х и заранее известно, что по измерениям сверх 3-х
//                             будет единственное значение. Измерения указанные в
//                             фиксированном отборе не используются при формировании
//                             наборов записей для выполнения обновления.
//
//  * ИзмеренияОтбора        - Строка измерений перечисленных через запятую, которые
//                             нужно использовать при формировании наборов записей
//                             для выполнения обновления (не более 3-х). Не указанные
//                             измерения будут превращены в фиксированный отбор,
//                             если по ним все значения совпадают.
//
//  * ТолькоПроверка         - Булево - если Истина, тогда не выполнять запись,
//                             а лишь выявить необходимость записи и установить
//                             свойство ЕстьИзменения.
//
//  * ДополнительныеСвойства - Неопределено, Структура. Если Структура, тогда в
//                             объекты <Регистр*>НаборЗаписей в свойство
//                             ДополнительныеСвойства будут вставлены все параметры структуры.
//
//  * ОбновлениеИБ           - Булево - если Истина, то необходимо выполнять запись данных, 
//                             не выполняя лишних, избыточных действий с данными.
//                             См. ОбновлениеИнформационнойБазы.ЗаписатьДанные.
//
//  ЕстьИзменения         - Булево (возвращаемое значение) - если производилась запись,
//                          устанавливается Истина, иначе не изменяется.
//
Процедура ОбновитьРегистрСведений(Знач Данные, ЕстьИзменения = Неопределено) Экспорт
	
	Если Данные.ИзмененияСоставаСтрок.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ВсеПараметры = Новый Структура;
	ВсеПараметры.Вставить("МенеджерРегистра");
	ВсеПараметры.Вставить("ИзмененияСоставаСтрок");
	ВсеПараметры.Вставить("ФиксированныйОтбор", Новый Структура);
	ВсеПараметры.Вставить("ИзмеренияОтбора");
	ВсеПараметры.Вставить("ТолькоПроверка", Ложь);
	ВсеПараметры.Вставить("ДополнительныеСвойства");
	ВсеПараметры.Вставить("ОбновлениеИБ", Ложь);
	ЗаполнитьПараметры(Данные, ВсеПараметры, "МенеджерРегистра, ИзмененияСоставаСтрок");
	
	МетаданныеРегистра = Метаданные.НайтиПоТипу(ТипЗнч(Данные.МенеджерРегистра.ПустойКлюч()));
	ОписаниеКлючаЗаписи = УправлениеДоступомСлужебныйПовтИсп.ОписаниеКлючаЗаписи(МетаданныеРегистра.ПолноеИмя());
	
	Если Данные.ИзмеренияОтбора <> Неопределено Тогда
		Данные.ИзмеренияОтбора = Новый Структура(Данные.ИзмеренияОтбора);
	КонецЕсли;
	
	МассивИзмеренийОтбора   = Новый Массив;
	ЗначенияИзмеренийОтбора = Новый Структура;
	
	Для каждого Поле Из ОписаниеКлючаЗаписи.МассивПолей Цикл
		Если НЕ Данные.ФиксированныйОтбор.Свойство(Поле) Тогда
			Значения = ЗначенияКолонкиТаблицы(Данные.ИзмененияСоставаСтрок, Поле);
			
			Если Данные.ИзмеренияОтбора = Неопределено
			 ИЛИ Данные.ИзмеренияОтбора.Свойство(Поле) Тогда
				
				МассивИзмеренийОтбора.Добавить(Поле);
				ЗначенияИзмеренийОтбора.Вставить(Поле, Значения);
				
			ИначеЕсли Значения.Количество() = 1 Тогда
				Данные.ФиксированныйОтбор.Вставить(Поле, Значения[0]);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Данные.Вставить("ИмяПервогоИзмерения", МассивИзмеренийОтбора[0]);
	Данные.Вставить("ЗначенияПервогоИзмерения", ЗначенияИзмеренийОтбора[Данные.ИмяПервогоИзмерения]);
	
	Если МассивИзмеренийОтбора.Количество() > 1 Тогда
		Данные.Вставить("ИмяВторогоИзмерения", МассивИзмеренийОтбора[1]);
		Данные.Вставить("ЗначенияВторогоИзмерения", ЗначенияИзмеренийОтбора[Данные.ИмяВторогоИзмерения]);
	Иначе
		Данные.Вставить("ИмяВторогоИзмерения", Неопределено);
		Данные.Вставить("ЗначенияВторогоИзмерения", Неопределено);
	КонецЕсли;
	
	Если МассивИзмеренийОтбора.Количество() > 2 Тогда
		Данные.Вставить("ИмяТретьегоИзмерения", МассивИзмеренийОтбора[2]);
		Данные.Вставить("ЗначенияТретьегоИзмерения", ЗначенияИзмеренийОтбора[Данные.ИмяТретьегоИзмерения]);
	Иначе
		Данные.Вставить("ИмяТретьегоИзмерения", Неопределено);
		Данные.Вставить("ЗначенияТретьегоИзмерения", Неопределено);
	КонецЕсли;
	
	Данные.Вставить("ПоляСравнения", ОписаниеКлючаЗаписи.СтрокаПолей);
	Данные.Вставить("НовыеЗаписиСодержатТолькоРазличия", Истина);
	Данные.Вставить("НовыеЗаписи", Данные.ИзмененияСоставаСтрок);
	Данные.Удалить("ИзмененияСоставаСтрок");
	Данные.Удалить("ИзмеренияОтбора");
	
	ОбновитьНаборыЗаписей(Данные, ЕстьИзменения);
	
КонецПроцедуры

// Возвращает пустую ссылку объекта метаданных ссылочного типа.
//
// Параметры:
//  ОписаниеОбъектаМетаданных - ОбъектМетаданных,
//                            - Тип, по которому можно найти объект метаданных,
//                            - Строка - полное имя объекта метаданных.
// Возвращаемое значение:
//  Ссылка.
//
Функция ПустаяСсылкаОбъектаМетаданных(ОписаниеОбъектаМетаданных) Экспорт
	
	Если ТипЗнч(ОписаниеОбъектаМетаданных) = Тип("ОбъектМетаданных") Тогда
		ОбъектМетаданных = ОписаниеОбъектаМетаданных;
		
	ИначеЕсли ТипЗнч(ОписаниеОбъектаМетаданных) = Тип("Тип") Тогда
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ОписаниеОбъектаМетаданных);
	Иначе
		ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ОписаниеОбъектаМетаданных);
	КонецЕсли;
	
	Если ОбъектМетаданных = Неопределено Тогда
		ВызватьИсключение
			НСтр("ru = 'Ошибка в функции ПустаяСсылкаОбъектаМетаданных
			           |общего модуля УправлениеДоступомСлужебный.
			           |
			           |Неверный параметр ОписаниеОбъектаМетаданных.'");
	КонецЕсли;
	
	ПустаяСсылка = Неопределено;
	Попытка
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ОбъектМетаданных.ПолноеИмя());
		ПустаяСсылка = МенеджерОбъекта.ПустаяСсылка();
	Исключение
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка в функции ПустаяСсылкаОбъектаМетаданных
			           |общего модуля УправлениеДоступомСлужебный.
			           |
			           |Не удалось получить пустую ссылка для объекта метаданных
			           |""%1"".'"),
			ОбъектМетаданных.ПолноеИмя());
	КонецПопытки;
	
	Возврат ПустаяСсылка;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Прочие процедуры и функции

// Создает запрос выбора различий между строками регистра в заданной области данных
// (на основе отборов в параметре ПоляИОтбор).
//
// Параметры:
//  ТекстЗапросаВыбораНовых - Строка.
//
//  ПоляИОтбор   - Массив элементов типа Структура("ИмяПоля", ИмяПараметраУсловияОтбора).
//
//  ПолноеИмяРегистра
//               - Строка       - запрос старых формируется автоматически.
//                 Неопределено - запрос старых берется из следующего параметра.
//
//  ТекстЗапросаВыбораСтарых
//               - Строка       - запрос старых, с учетом нестандартных отборов.
//               - Неопределено - когда полное имя регистра определено.
//
// Возвращаемое значение:
//  Строка - текст запрос с учетом оптимизации для СУБД PostgreSQL.
//
Функция ТекстЗапросаВыбораИзменений(ТекстЗапросаВыбораНовых,
                                    ПоляИОтбор,
                                    ПолноеИмяРегистра            = Неопределено,
                                    ТекстЗапросовВременныхТаблиц = Неопределено,
                                    ТекстЗапросаВыбораСтарых     = Неопределено) Экспорт
	
	// Подготовка текста запроса старых данных.
	Если ПолноеИмяРегистра <> Неопределено Тогда
		ТекстЗапросаВыбораСтарых =
		"ВЫБРАТЬ
		|	&ВыбираемыеПоля,
		|	&ПодстановкаПоляВидИзмененияСтроки
		|ИЗ
		|	ПолноеИмяРегистра КАК СтарыеДанные
		|ГДЕ
		|	&УсловияОтбора";
	КонецЕсли;
	
	ВыбираемыеПоля = "";
	УсловияОтбора = "Истина";
	Для каждого ОписаниеПоля Из ПоляИОтбор Цикл
		// Сборка выбираемых полей.
		ВыбираемыеПоля = ВыбираемыеПоля + СтрЗаменить(
			"
			|	СтарыеДанные.Поле,",
			"Поле",
			КлючИЗначение(ОписаниеПоля).Ключ);
			
		// Сборка условий отбора.
		Если ЗначениеЗаполнено(КлючИЗначение(ОписаниеПоля).Значение) Тогда
			УсловияОтбора = УсловияОтбора + СтрЗаменить(
				"
				|	И &ИмяПараметраУсловияОтбора", "&ИмяПараметраУсловияОтбора",
				КлючИЗначение(ОписаниеПоля).Значение);
		КонецЕсли;
	КонецЦикла;
	
	ТекстЗапросаВыбораСтарых =
		СтрЗаменить(ТекстЗапросаВыбораСтарых, "&ВыбираемыеПоля,",  ВыбираемыеПоля);
	
	ТекстЗапросаВыбораСтарых =
		СтрЗаменить(ТекстЗапросаВыбораСтарых, "&УсловияОтбора",    УсловияОтбора);
	
	ТекстЗапросаВыбораСтарых =
		СтрЗаменить(ТекстЗапросаВыбораСтарых, "ПолноеИмяРегистра", ПолноеИмяРегистра);
	
	Если СтрНайти(ТекстЗапросаВыбораНовых, "&ПодстановкаПоляВидИзмененияСтроки") = 0 Тогда
		ВызватьИсключение
			НСтр("ru = 'Ошибка в значении параметра ТекстЗапросаВыбораСтарых
			           |процедуры ТекстЗапросаВыбораИзменений модуля УправлениеДоступомСлужебный.
			           |
			           |В тексте запроса не найдена строка ""&ПодстановкаПоляВидИзмененияСтроки"".'");
	КонецЕсли;
	
	ТекстЗапросаВыбораСтарых = СтрЗаменить(
		ТекстЗапросаВыбораСтарых, "&ПодстановкаПоляВидИзмененияСтроки", "-1 КАК ВидИзмененияСтроки");
	
	Если СтрНайти(ТекстЗапросаВыбораНовых, "&ПодстановкаПоляВидИзмененияСтроки") = 0 Тогда
		ВызватьИсключение
			НСтр("ru = 'Ошибка в значении параметра ТекстЗапросаВыбораНовых
			           |процедуры ТекстЗапросаВыбораИзменений модуля УправлениеДоступомСлужебный.
			           |
			           |В тексте запроса не найдена строка ""&ПодстановкаПоляВидИзмененияСтроки"".'");
	КонецЕсли;
	
	ТекстЗапросаВыбораНовых = СтрЗаменить(
		ТекстЗапросаВыбораНовых,  "&ПодстановкаПоляВидИзмененияСтроки", "1 КАК ВидИзмененияСтроки");
	
	// Подготовка текста запроса выбора изменений.
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	&ВыбираемыеПоля,
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) КАК ВидИзмененияСтроки
	|ИЗ
	|	(ТекстЗапросаВыбораНовых
	|	
	|	ОБЪЕДИНИТЬ ВСЕ
	|	
	|	ТекстЗапросаВыбораСтарых) КАК ВсеСтроки
	|	
	|СГРУППИРОВАТЬ ПО
	|	&ПоляГруппировки
	|	
	|ИМЕЮЩИЕ
	|	СУММА(ВсеСтроки.ВидИзмененияСтроки) <> 0";
	
	ВыбираемыеПоля = "";
	ПоляГруппировки = "";
	Для каждого ОписаниеПоля Из ПоляИОтбор Цикл
		// Сборка выбираемых полей.
		ВыбираемыеПоля = ВыбираемыеПоля + СтрЗаменить(
			"
			|	ВсеСтроки.Поле,",
			"Поле",
			КлючИЗначение(ОписаниеПоля).Ключ);
		
		// Сборка полей соединения.
		ПоляГруппировки = ПоляГруппировки + СтрЗаменить(
			"
			|	ВсеСтроки.Поле,",
			"Поле",
			КлючИЗначение(ОписаниеПоля).Ключ);
	КонецЦикла;
	ПоляГруппировки = Лев(ПоляГруппировки, СтрДлина(ПоляГруппировки)-1);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ВыбираемыеПоля,",  ВыбираемыеПоля);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляГруппировки", ПоляГруппировки);
	
	ТекстЗапроса = СтрЗаменить(
		ТекстЗапроса, "ТекстЗапросаВыбораНовых",  ТекстЗапросаВыбораНовых);
	
	ТекстЗапроса = СтрЗаменить(
		ТекстЗапроса, "ТекстЗапросаВыбораСтарых", ТекстЗапросаВыбораСтарых);
	
	Если ЗначениеЗаполнено(ТекстЗапросовВременныхТаблиц) Тогда
		ТекстЗапроса = ТекстЗапросовВременныхТаблиц
		+ "
		  |;
		  |" + ТекстЗапроса;
	КонецЕсли;
	
	Возврат ТекстЗапроса;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обновление информационной базы.

// Заполняет обработчик разделенных данных, зависимый от изменения неразделенных данных.
//
// Параметры:
//   Обработчики - ТаблицаЗначений, Неопределено - см. описание
//    функции НоваяТаблицаОбработчиковОбновления общего модуля
//    ОбновлениеИнформационнойБазы.
//    В случае прямого вызова (не через механизм обновления
//    версии ИБ) передается Неопределено.
// 
Процедура ЗаполнитьОбработчикиРазделенныхДанных(Параметры = Неопределено) Экспорт
	
	Если Параметры <> Неопределено И ЕстьИзмененияПараметровОграниченияДоступа() Тогда
		Обработчики = Параметры.РазделенныеОбработчики;
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "*";
		Обработчик.Процедура = "УправлениеДоступомСлужебный.ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации";
	КонецЕсли;
	
КонецПроцедуры

// Обновляет вспомогательные данные, которые зависят только
// от конфигурации.
// Записывает изменения этих данных по версиям конфигурации
// (если изменения есть), чтобы использовать эти изменения
// при обновлении остальных вспомогательных данных, например,
// в обработчике ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации.
//
Процедура ОбновитьПараметрыОграниченияДоступа(ЕстьИзменения = Неопределено, ТолькоПроверка = Ложь) Экспорт
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("Константа.ПараметрыОграниченияДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ПраваРолей");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ЗависимостиПравДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	
	Если ТолькоПроверка ИЛИ МонопольныйРежим() Тогда
		СнятьМонопольныйРежим = Ложь;
	Иначе
		СнятьМонопольныйРежим = Истина;
		УстановитьМонопольныйРежим(Истина);
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		
		РегистрыСведений.ПраваРолей.ОбновитьДанныеРегистра(
			ЕстьИзменения, ТолькоПроверка);
		
		Если НЕ (ТолькоПроверка И ЕстьИзменения) Тогда
			РегистрыСведений.ЗависимостиПравДоступа.ОбновитьДанныеРегистра(
				ЕстьИзменения, ТолькоПроверка);
		КонецЕсли;
		
		Если НЕ (ТолькоПроверка И ЕстьИзменения) Тогда
			Менеджер = Константы["ПараметрыОграниченияДоступа"].СоздатьМенеджерЗначения();
			Менеджер.ОбновитьОписаниеСвойствВидовДоступа(ЕстьИзменения, ТолькоПроверка);
		КонецЕсли;
		
		Если НЕ (ТолькоПроверка И ЕстьИзменения) Тогда
			Справочники.ПрофилиГруппДоступа.ОбновитьОписаниеПоставляемыхПрофилей(
				ЕстьИзменения, ТолькоПроверка);
		КонецЕсли;
		
		Если НЕ (ТолькоПроверка И ЕстьИзменения) Тогда
			Справочники.ПрофилиГруппДоступа.ОбновитьСоставПредопределенныхПрофилей(
				ЕстьИзменения, ТолькоПроверка);
		КонецЕсли;
		
		Если НЕ (ТолькоПроверка И ЕстьИзменения) Тогда
			РегистрыСведений.НастройкиПравОбъектов.ОбновитьВозможныеПраваДляНастройкиПравОбъектов(
				ЕстьИзменения, ТолькоПроверка);
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		Если СнятьМонопольныйРежим Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
	Если СнятьМонопольныйРежим Тогда
		УстановитьМонопольныйРежим(Ложь);
	КонецЕсли;
	
КонецПроцедуры

// Обновляет вспомогательные данные, которые зависят от конфигурации частично.
//
// Обновляется при наличии изменений конфигурации, записанных в параметры
// ограничения доступа при обновлении базы данных на текущую версию конфигурации.
//
Процедура ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации(Параметры = Неопределено) Экспорт
	
	Если Параметры <> Неопределено
	   И НЕ Параметры.МонопольныйРежим
	   И ЕстьИзмененияПараметровОграниченияДоступа() Тогда
		
		Параметры.МонопольныйРежим = Истина;
		Возврат;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ТаблицыГруппДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.НастройкиПравОбъектов");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("Справочник.ПрофилиГруппДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	ЭлементБлокировки = Блокировка.Добавить("Справочник.ГруппыДоступа");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		
		РегистрыСведений.ТаблицыГруппДоступа.ОбновитьДанныеРегистраПоИзменениямКонфигурации();
		РегистрыСведений.ГруппыЗначенийДоступа.ОбновитьВспомогательныеДанныеРегистраПоИзменениямКонфигурации();
		РегистрыСведений.НастройкиПравОбъектов.ОбновитьВспомогательныеДанныеРегистраПоИзменениямКонфигурации();
		Справочники.ПрофилиГруппДоступа.ОбновитьПоставляемыеПрофилиПоИзменениямКонфигурации();
		Справочники.ГруппыДоступа.ПометитьНаУдалениеГруппыДоступаПомеченныхПрофилей();
		РегистрыСведений.НаборыЗначенийДоступа.ОбновитьВспомогательныеДанныеРегистраПоИзменениямКонфигурации();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Преобразует реквизит УдалитьРоль в реквизит Роль в табличной части Роли
// справочника Профили групп доступа.
//
Процедура ПреобразоватьИменаРолейВИдентификаторы() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Роли.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа.Роли КАК Роли
	|ГДЕ
	|	НЕ(Роли.Роль <> ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
	|				И Роли.УдалитьРоль = """")";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Индекс = Объект.Роли.Количество()-1;
		Пока Индекс >= 0 Цикл
			Строка = Объект.Роли[Индекс];
			Если ЗначениеЗаполнено(Строка.Роль) Тогда
				Строка.УдалитьРоль = "";
			ИначеЕсли ЗначениеЗаполнено(Строка.УдалитьРоль) Тогда
				МетаданныеРоли = Метаданные.Роли.Найти(Строка.УдалитьРоль);
				Если МетаданныеРоли <> Неопределено Тогда
					Строка.УдалитьРоль = "";
					Строка.Роль = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(
						МетаданныеРоли);
				Иначе
					Объект.Роли.Удалить(Индекс);
				КонецЕсли;
			Иначе
				Объект.Роли.Удалить(Индекс);
			КонецЕсли;
			Индекс = Индекс-1;
		КонецЦикла;
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
	КонецЦикла;
	
КонецПроцедуры

// Обновляет настройки и включает регламентное задание.
Процедура ВключитьЗаполнениеДанныхДляОграниченияДоступа() Экспорт
	
	Использование = Константы.ОграничиватьДоступНаУровнеЗаписей.Получить();
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		УстановитьЗаполнениеДанныхДляОграниченияДоступа(Использование);
	Иначе
		Расписание = Новый РасписаниеРегламентногоЗадания;
		Расписание.ПериодНедель = 1;
		Расписание.ПериодПовтораДней = 1;
		Расписание.ПериодПовтораВТечениеДня = 300;
		Расписание.ПаузаПовтора = 90;
		
		ЗаданиеМетаданные = Метаданные.РегламентныеЗадания.ЗаполнениеДанныхДляОграниченияДоступа;
		Задание = РегламентныеЗадания.НайтиПредопределенное(ЗаданиеМетаданные);
		
		Задание.Использование = Использование;
		Задание.Расписание = Расписание;
		
		Задание.ИнтервалПовтораПриАварийномЗавершении
			= ЗаданиеМетаданные.ИнтервалПовтораПриАварийномЗавершении;
		
		Задание.КоличествоПовторовПриАварийномЗавершении
			= ЗаданиеМетаданные.КоличествоПовторовПриАварийномЗавершении;
		
		Задание.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Заполняет назначение профилей групп доступа.
Процедура ЗаполнитьНазначениеПрофилейГруппДоступа() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПрофилиГруппДоступа.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа КАК ПрофилиГруппДоступа
	|ГДЕ
	|	НЕ(ПрофилиГруппДоступа.ИдентификаторПоставляемыхДанных <> &ПустойУникальныйИдентификатор
	|				И НЕ ПрофилиГруппДоступа.ПоставляемыйПрофильИзменен)
	|	И НЕ ПрофилиГруппДоступа.ЭтоГруппа
	|	И НЕ ПрофилиГруппДоступа.Ссылка В
	|				(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|					ПрофилиГруппДоступаНазначение.Ссылка
	|				ИЗ
	|					Справочник.ПрофилиГруппДоступа.Назначение КАК ПрофилиГруппДоступаНазначение)";
	
	Запрос.УстановитьПараметр("ПустойУникальныйИдентификатор",
		Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000"));
		
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		ПрофильОбъект = Выборка.Ссылка.ПолучитьОбъект();
		НоваяСтрока = ПрофильОбъект.Назначение.Добавить();
		НоваяСтрока.ТипПользователей = Справочники.Пользователи.ПустаяСсылка();
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(ПрофильОбъект);
	КонецЦикла;
	
КонецПроцедуры

// Заменят удаленные роли на новые
Процедура ЗаменитьУдаленныеРолиВПрофиляхГруппДоступа() Экспорт
	
	// Заполнение списка удаленных ролей и соответствующих новых ролей.
	МассивУдаленныхРолей = Новый Массив;
	СоответствиеРолей = Новый Соответствие;
	
	// ДобавлениеИзменениеБазовойНСИ
	ИмяРоли = "? ДобавлениеИзменениеБазовойНСИ";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.Свойства") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеДополнительныхРеквизитовИСведений"));
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.Валюты") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеКурсовВалют"));
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ГрафикиРаботы") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеГрафиковРаботы"));
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.КонтактнаяИнформация") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеВидовКонтактнойИнформации"));
	КонецЕсли;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// ДобавлениеИзменениеОбщейБазовойНСИ
	ИмяРоли = "? ДобавлениеИзменениеОбщейБазовойНСИ";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.АдресныйКлассификатор") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеАдресныхСведений"));
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.Банки") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеБанков"));
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.КалендарныеГрафики") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеКалендарныхГрафиков"));
	КонецЕсли;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// ИзменениеТекущегоПользователя
	ИмяРоли = "? ИзменениеТекущегоПользователя";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// ИзменениеТекущегоВнешнегоПользователя
	ИмяРоли = "? ИзменениеТекущегоВнешнегоПользователя";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// ЧтениеБазовойНСИ
	ИмяРоли = "? ЧтениеБазовойНСИ";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ГрафикиРаботы") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ЧтениеГрафиковРаботы"));
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.Валюты") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ЧтениеКурсовВалют"));
	КонецЕсли;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// ЧтениеОбщейБазовойНСИ
	ИмяРоли = "? ЧтениеОбщейБазовойНСИ";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// ДобавлениеИзменениеСтранМира
	ИмяРоли = "? ДобавлениеИзменениеСтранМира";
	МассивУдаленныхРолей.Добавить(ИмяРоли);
	
	МассивРолей = Новый Массив;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.КонтактнаяИнформация") Тогда
		МассивРолей.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеВидовКонтактнойИнформации"));
	КонецЕсли;
	СоответствиеРолей.Вставить(ИмяРоли, МассивРолей);
	
	// Найти профили, использующие удаленные роли
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	РолиПрофилей.Ссылка КАК Профиль,
	|	ИдентификаторыУдаленныхРолей.Ссылка КАК ИдентификаторРоли,
	|	ИдентификаторыУдаленныхРолей.Имя
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа.Роли КАК РолиПрофилей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовМетаданных КАК ИдентификаторыУдаленныхРолей
	|		ПО РолиПрофилей.Роль = ИдентификаторыУдаленныхРолей.Ссылка
	|		И ИдентификаторыУдаленныхРолей.Имя В (&МассивУдаленныхРолей)
	|ИТОГИ ПО
	|	Профиль";
	
	Запрос.УстановитьПараметр("МассивУдаленныхРолей", МассивУдаленныхРолей);
	ДеревоПрофилей = Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	Для Каждого СтрокаПрофиля Из ДеревоПрофилей.Строки Цикл
		
		ПрофильОбъект = СтрокаПрофиля.Профиль.ПолучитьОбъект();
		РолиПрофиля = ПрофильОбъект.Роли;
		
		Для Каждого СтрокаРоли Из СтрокаПрофиля.Строки Цикл
			
			// Удаляем роль из профиля
			Отбор = Новый Структура("Роль", СтрокаРоли.ИдентификаторРоли);
			СтрокаТабличнойЧасти = РолиПрофиля.НайтиСтроки(Отбор)[0];
			РолиПрофиля.Удалить(СтрокаТабличнойЧасти);
			
			// Добавляем новые роли
			ДобавляемыеРоли = СоответствиеРолей.Получить(СтрокаРоли.Имя);
			Для Каждого ДобавляемаяРоль Из ДобавляемыеРоли Цикл
				
				Отбор = Новый Структура;
				Отбор.Вставить("Роль", ДобавляемаяРоль);
				Если РолиПрофиля.НайтиСтроки(Отбор).Количество() = 0 Тогда
					НоваяСтрока = РолиПрофиля.Добавить();
					НоваяСтрока.Роль = ДобавляемаяРоль;
				КонецЕсли;
			
			КонецЦикла;
			
		КонецЦикла;
		
		Отбор = Новый Структура;
		Отбор.Вставить("Роль", ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеВидовКонтактнойИнформации"));
		НайденныеРоли = РолиПрофиля.НайтиСтроки(Отбор);
		Если НайденныеРоли.Количество() > 1 Тогда
			РолиПрофиля.Удалить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Роль.ДобавлениеИзменениеВидовКонтактнойИнформации"));
		КонецЕсли;
		
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(ПрофильОбъект,, Истина);
		
	КонецЦикла;
	
КонецПроцедуры

// Создает профиль с ролью "ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок" в случае его отсутствия.
Процедура СоздатьПрофильОткрытияВнешнихОтчетовИОбработок() Экспорт
	// В модели сервиса право открытия внешних отчетов и обработок не используется для пользователей областей данных.
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	// Создание профиля.
	СвойстваПрофиля = СвойстваПрофиляОткрытиеВнешнихОтчетовИОбработок();
	
	// Создание группы доступа.
	УпрощенныйИнтерфейс = УпрощенныйИнтерфейсНастройкиПравДоступа();
	Если Не УпрощенныйИнтерфейс Тогда
		ГруппаДоступаОткрытиеВнешнихОтчетовИОбработок(СвойстваПрофиля);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции.

Процедура ПриИзмененииНаборовЗначенийДоступа(Знач СсылкаНаОбъект, ОбновлениеИБ = Ложь)
	
	СсылкиНаЗависимыеОбъекты = Новый Массив;
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.УправлениеДоступом\ПриИзмененииНаборовЗначенийДоступа");
	Для Каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриИзмененииНаборовЗначенийДоступа(СсылкаНаОбъект, СсылкиНаЗависимыеОбъекты);
	КонецЦикла;
	
	УправлениеДоступомПереопределяемый.ПриИзмененииНаборовЗначенийДоступа(
		СсылкаНаОбъект, СсылкиНаЗависимыеОбъекты);
	
	Для каждого СсылкаНаЗависимыйОбъект Из СсылкиНаЗависимыеОбъекты Цикл
		
		Если СсылкаНаЗависимыйОбъект.Метаданные().ТабличныеЧасти.Найти("НаборыЗначенийДоступа") = Неопределено Тогда
			// Изменение объекта не требуется.
			ЗаписатьНаборыЗначенийДоступа(СсылкаНаЗависимыйОбъект, , ОбновлениеИБ);
		Иначе
			// Изменение объекта требуется.
			Объект = СсылкаНаЗависимыйОбъект.ПолучитьОбъект();
			Таблица = ПолучитьНаборыЗначенийДоступаТабличнойЧасти(Объект);
			Если НЕ НаборыЗначенийДоступаТабличнойЧастиИзменены(СсылкаНаЗависимыйОбъект, Таблица) Тогда
				Продолжить;
			КонецЕсли;
			ПодготовитьНаборыЗначенийДоступаКЗаписи(Неопределено, Таблица, Ложь);
			Попытка
				ЗаблокироватьДанныеДляРедактирования(СсылкаНаЗависимыйОбъект, Объект.ВерсияДанных);
				Объект.ДополнительныеСвойства.Вставить("ЗаписатьНаборыЗначенийДоступа");
				Объект.ДополнительныеСвойства.Вставить("ЗаписатьЗависимыеНаборыЗначенийДоступа");
				Объект.ДополнительныеСвойства.Вставить("НаборыЗначенийДоступаТабличнойЧастиЗаполнены");
				Объект.НаборыЗначенийДоступа.Загрузить(Таблица);
				Если ОбновлениеИБ Тогда
					Объект.ДополнительныеСвойства.Вставить("ЗаписьНаборовЗначенийДоступаПриОбновленииИБ");
					ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
				Иначе
					Объект.ОбменДанными.Загрузка = Истина;
					Объект.Записать();
				КонецЕсли;
				РазблокироватьДанныеДляРедактирования(СсылкаНаЗависимыйОбъект);
			Исключение
				ИнформацияОбОшибке = ИнформацияОбОшибке();
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'При обновлении зависимого набора значений доступа объекта
					           |""%1"" возникла ошибка:
					           |
					           |%2'"),
					Строка(СсылкаНаЗависимыйОбъект),
					КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция СвойстваПрофиляОткрытиеВнешнихОтчетовИОбработок()
	Результат = Новый Структура("Ссылка, УникальныйИдентификатор, Наименование, Комментарий, Роль");
	Результат.Наименование = НСтр("ru = 'Открытие внешних отчетов и обработок'", Метаданные.ОсновнойЯзык.КодЯзыка);
	Результат.Комментарий  = НСтр(
		"ru = 'Предоставляет право открытия внешних отчетов и обработок из меню ""Файл - Открыть"".
		|Состав ролей профиля не рекомендуется изменять.'",
		Метаданные.ОсновнойЯзык.КодЯзыка);
	Результат.УникальныйИдентификатор = Новый УникальныйИдентификатор("1b3472f6-4d87-11e6-8264-5404a6a6895d");
	Результат.Ссылка = Справочники.ПрофилиГруппДоступа.ПолучитьСсылку(Результат.УникальныйИдентификатор);
	Результат.Роль = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(Метаданные.Роли.ИнтерактивноеОткрытиеВнешнихОтчетовИОбработок);
	ПрофильСуществует = (ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Результат.Ссылка, "Ссылка") <> Неопределено);
	Если Не ПрофильСуществует Тогда
		// Профиль создается в случае отсутствия.
		ПрофильОбъект = Справочники.ПрофилиГруппДоступа.СоздатьЭлемент();
		ПрофильОбъект.УстановитьСсылкуНового(Результат.Ссылка);
		ПрофильОбъект.Наименование         = Результат.Наименование;
		ПрофильОбъект.Комментарий          = Результат.Комментарий;
		ПрофильОбъект.Назначение.Добавить().ТипПользователей = Справочники.Пользователи.ПустаяСсылка();
		ПрофильОбъект.Роли.Добавить().Роль = Результат.Роль;
		// При обновлении ИБ важно, чтобы изменения уехали в подчиненный узел.
		ПрофильОбъект.Записать();
	КонецЕсли;
	Возврат Результат;
КонецФункции

Функция ГруппаДоступаОткрытиеВнешнихОтчетовИОбработок(СвойстваПрофиля)
	// Поиск по идентификатору.
	УникальныйИдентификатор = Новый УникальныйИдентификатор("f6929bcb-532f-11e6-a20f-5404a6a6895d");
	Ссылка = Справочники.ГруппыДоступа.ПолучитьСсылку(УникальныйИдентификатор);
	СсылкаСуществует = (ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, "Ссылка") <> Неопределено);
	Если СсылкаСуществует Тогда
		Возврат Ссылка;
	КонецЕсли;
	
	// Поиск по профилю.
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ГруппыДоступа.Ссылка
	|ИЗ
	|	Справочник.ГруппыДоступа КАК ГруппыДоступа
	|ГДЕ
	|	ГруппыДоступа.Профиль = &Профиль
	|
	|УПОРЯДОЧИТЬ ПО
	|	ГруппыДоступа.ПометкаУдаления";
	Запрос.УстановитьПараметр("Профиль", СвойстваПрофиля.Ссылка);
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Ссылка;
	КонецЕсли;
	
	// Создание новой группы.
	ГруппаДоступаОбъект = Справочники.ГруппыДоступа.СоздатьЭлемент();
	ГруппаДоступаОбъект.УстановитьСсылкуНового(Ссылка);
	ГруппаДоступаОбъект.Наименование = СвойстваПрофиля.Наименование;
	ГруппаДоступаОбъект.Описание     = СвойстваПрофиля.Комментарий;
	ГруппаДоступаОбъект.Профиль      = СвойстваПрофиля.Ссылка;
	// При обновлении ИБ важно, чтобы изменения уехали в подчиненный узел.
	ГруппаДоступаОбъект.Записать();
	Возврат ГруппаДоступаОбъект.Ссылка;
КонецФункции

// Для процедур ВключитьПрофильПользователю и ВыключитьПрофильПользователю.
Процедура ВключитьОтключитьПрофильПользователя(Пользователь, Профиль, Включить)
	
	Если Не УпрощенныйИнтерфейсНастройкиПравДоступа() Тогда
		ВызватьИсключение
			НСтр("ru = 'Данная операция возможна только для упрощенного
			           |интерфейса настройки прав доступа.'");
	КонецЕсли;
	
	Если Включить Тогда
		ИмяПроцедурыИлиФункции = "ВключитьПрофильПользователю";
	Иначе
		ИмяПроцедурыИлиФункции = "ВыключитьПрофильПользователю";
	КонецЕсли;
	
	// Проверка типов значения параметра Пользователь.
	Если ТипЗнч(Пользователь) <> Тип("СправочникСсылка.Пользователи")
	   И ТипЗнч(Пользователь) <> Тип("СправочникСсылка.ВнешниеПользователи") Тогда
		
		ИмяПараметра = "Пользователь";
		ЗначениеПараметра = Пользователь;
		Типы = Новый Массив;
		Типы.Добавить(Тип("СправочникСсылка.Пользователи"));
		Типы.Добавить(Тип("СправочникСсылка.ВнешниеПользователи"));
		ОжидаемыеТипы = Новый ОписаниеТипов(Типы);
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			           |Ожидалось: %3; передано значение: %4 (тип %5).'"),
			ИмяПараметра,
			ИмяПроцедурыИлиФункции,
			ОжидаемыеТипы, 
			?(ЗначениеПараметра <> Неопределено, ЗначениеПараметра, НСтр("ru = 'Неопределено'")),
			ТипЗнч(ЗначениеПараметра));
	КонецЕсли;
	
	// Проверка типов значения параметра Профиль.
	Если ТипЗнч(Профиль) <> Тип("СправочникСсылка.ПрофилиГруппДоступа")
	   И ТипЗнч(Профиль) <> Тип("Строка")
	   И ТипЗнч(Профиль) <> Тип("УникальныйИдентификатор")
	   И Не (Не Включить И ТипЗнч(Профиль) = Тип("Неопределено")) Тогда
		
		ИмяПараметра = "Профиль";
		ЗначениеПараметра = Профиль;
		Типы = Новый Массив;
		Типы.Добавить(Тип("СправочникСсылка.ПрофилиГруппДоступа"));
		Типы.Добавить(Тип("Строка"));
		Типы.Добавить(Тип("УникальныйИдентификатор"));
		Если Не Включить Тогда
			Типы.Добавить(Тип("Неопределено"));
		КонецЕсли;
		ОжидаемыеТипы = Новый ОписаниеТипов(Типы);
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Недопустимое значение параметра %1 в %2.
			           |Ожидалось: %3; передано значение: %4 (тип %5).'"),
			ИмяПараметра,
			ИмяПроцедурыИлиФункции,
			ОжидаемыеТипы, 
			?(ЗначениеПараметра <> Неопределено, ЗначениеПараметра, НСтр("ru = 'Неопределено'")),
			ТипЗнч(ЗначениеПараметра));
	КонецЕсли;
	
	Если ТипЗнч(Профиль) = Тип("СправочникСсылка.ПрофилиГруппДоступа")
	 Или ТипЗнч(Профиль) = Тип("Неопределено") Тогда
		ТекущийПрофиль = Профиль;
	Иначе
		ТекущийПрофиль = Справочники.ПрофилиГруппДоступа.ПоставляемыйПрофильПоИдентификатору(Профиль);
	КонецЕсли;
	
	Если ТекущийПрофиль <> Неопределено Тогда
		СвойстваПрофиля = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ТекущийПрофиль,
			"Наименование, ВидыДоступа");
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ГруппыДоступа.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ГруппыДоступа КАК ГруппыДоступа
	|ГДЕ
	|	&УсловиеОтбора";
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	Если ТекущийПрофиль = Справочники.ПрофилиГруппДоступа.Администратор Тогда
		УсловиеОтбора = "ГруппыДоступа.Ссылка = Значение(Справочник.ГруппыДоступа.Администраторы)";
	Иначе
		УсловиеОтбора = "ГруппыДоступа.Пользователь = &Пользователь";
		Если Включить Или ТекущийПрофиль <> Неопределено Тогда
			УсловиеОтбора = УсловиеОтбора + Символы.ПС + "	И ГруппыДоступа.Профиль = &Профиль";
			Запрос.УстановитьПараметр("Профиль", ТекущийПрофиль);
		КонецЕсли;
	КонецЕсли;
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеОтбора", УсловиеОтбора);
	
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	
	Блокировка = Новый БлокировкаДанных();
	ЭлементБлокировки = Блокировка.Добавить("Справочник.ГруппыДоступа");
	ЭлементБлокировки.ИсточникДанных = РезультатЗапроса;
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		Выборка.Следующий();
		Пока Истина Цикл
			ПерсональнаяГруппаДоступа = Выборка.Ссылка;
			Если ЗначениеЗаполнено(ПерсональнаяГруппаДоступа) Тогда
				ГруппаДоступаОбъект = ПерсональнаяГруппаДоступа.ПолучитьОбъект();
				ГруппаДоступаОбъект.ПометкаУдаления = Ложь;
				
			ИначеЕсли ТекущийПрофиль <> Неопределено Тогда
				// Создание персональной группы доступа.
				ГруппаДоступаОбъект = Справочники.ГруппыДоступа.СоздатьЭлемент();
				ГруппаДоступаОбъект.Родитель     = Справочники.ГруппыДоступа.РодительПерсональныхГруппДоступа();
				ГруппаДоступаОбъект.Наименование = СвойстваПрофиля.Наименование;
				ГруппаДоступаОбъект.Пользователь = Пользователь;
				ГруппаДоступаОбъект.Профиль      = ТекущийПрофиль;
				ГруппаДоступаОбъект.ВидыДоступа.Загрузить(ВидыДоступаДляНовойГруппыДоступа(СвойстваПрофиля));
			Иначе
				ГруппаДоступаОбъект = Неопределено;
			КонецЕсли;
			
			Если ПерсональнаяГруппаДоступа = Справочники.ГруппыДоступа.Администраторы Тогда
				ОписаниеПользователя =  ГруппаДоступаОбъект.Пользователи.Найти(
					Пользователь, "Пользователь");
				
				Если Включить И ОписаниеПользователя = Неопределено Тогда
					ГруппаДоступаОбъект.Пользователи.Добавить().Пользователь = Пользователь;
				ИначеЕсли Не Включить И ОписаниеПользователя <> Неопределено Тогда
					ГруппаДоступаОбъект.Пользователи.Удалить(ОписаниеПользователя);
				КонецЕсли;
				
				Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
					// Проверка пустого списка пользователей ИБ в группе доступа Администраторы.
					ОписаниеОшибки = "";
					ПроверитьНаличиеПользователяИБВГруппеДоступаАдминистраторы(
						ГруппаДоступаОбъект.Пользователи, ОписаниеОшибки);
					
					Если ЗначениеЗаполнено(ОписаниеОшибки) Тогда
						ВызватьИсключение
							НСтр("ru = 'Профиль Администратор должен быть хотя бы у одного пользователя,
							           |которому разрешен вход в программу.'");
					КонецЕсли;
				КонецЕсли;
			ИначеЕсли ГруппаДоступаОбъект <> Неопределено Тогда
				ГруппаДоступаОбъект.Пользователи.Очистить();
				Если Включить Тогда
					ГруппаДоступаОбъект.Пользователи.Добавить().Пользователь = Пользователь;
				КонецЕсли;
			КонецЕсли;
			
			Если ГруппаДоступаОбъект <> Неопределено Тогда
				// При обновлении ИБ важно, чтобы изменения уехали в подчиненный узел.
				ГруппаДоступаОбъект.Записать();
			КонецЕсли;
			
			Если Не Выборка.Следующий() Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

Функция ВидыДоступаДляНовойГруппыДоступа(СвойстваПрофиля)
	
	ВидыДоступа = СвойстваПрофиля.ВидыДоступа.Выгрузить();
	
	Отбор = Новый Структура;
	Отбор.Вставить("Предустановленный", Истина);
	Предустановленные = ВидыДоступа.НайтиСтроки(Отбор);
	
	Для Каждого Предустановленный Из Предустановленные Цикл
		ВидыДоступа.Удалить(Предустановленный);
	КонецЦикла;
	
	Возврат ВидыДоступа;
	
КонецФункции

// Для процедур ОбновитьНаборЗаписей, ОбновитьНаборыЗаписей, ОбновитьРегистрСведений.
Процедура ЗаполнитьПараметры(ВходныеПараметры, Знач ВсеПараметры, Знач ОбязательныеПараметры = "")
	
	Если ТипЗнч(ВходныеПараметры) = Тип("Структура") Тогда
		Параметры = ВходныеПараметры;
	ИначеЕсли ВходныеПараметры = Неопределено Тогда
		Параметры = Новый Структура;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Некорректный тип набора свойств ""%1"".
			           |Допустимые типы: Структура, Неопределено.'"),
			ТипЗнч(ВходныеПараметры));
	КонецЕсли;
	
	Для каждого КлючИЗначение Из Параметры Цикл
		Если Не ВсеПараметры.Свойство(КлючИЗначение.Ключ) Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Указан несуществующий параметр %1'"),
				КлючИЗначение.Ключ);
		КонецЕсли;
		ВсеПараметры[КлючИЗначение.Ключ] = Параметры[КлючИЗначение.Ключ];
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ОбязательныеПараметры) Тогда
		ОбязательныеПараметры = Новый Структура(ОбязательныеПараметры);
		
		Для каждого КлючИЗначение Из ОбязательныеПараметры Цикл
			Если Не Параметры.Свойство(КлючИЗначение.Ключ) Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Не указан обязательный параметр %1'"),
					КлючИЗначение.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ВходныеПараметры = ВсеПараметры;
	
КонецПроцедуры

Процедура ПослеПолученияДанных(Отправитель, Отказ, ОтПодчиненного)
	
	УправлениеДоступом.ОбновитьРолиПользователей();
	
КонецПроцедуры

Функция ИмяОбъектаПодсистемыУправлениеДоступомНачинаетсяСУдалить(ЭлементДанных)
	
	Возврат ТипЗнч(ЭлементДанных) = Тип("ПланВидовХарактеристикОбъект.УдалитьВидыДоступа")
	    ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.УдалитьГруппыЗначенийДоступа")
	    ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.УдалитьНаборыЗначенийДоступа")
	    ИЛИ ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.УдалитьПраваПоЗначениямДоступа");
	
КонецФункции

// Для процедур ВключитьПользователяВГруппуДоступа, ИсключитьПользователяИзГруппыДоступа
// и функции НайтиПользователяВГруппеДоступа.

Функция ОбработатьСвязьПользователяСГруппойДоступа(Пользователь, ПоставляемыйПрофиль, Включить = Неопределено)
	
	Если ТипЗнч(Пользователь) <> Тип("СправочникСсылка.Пользователи")
	   И ТипЗнч(Пользователь) <> Тип("СправочникСсылка.ГруппыПользователей")
	   И ТипЗнч(Пользователь) <> Тип("СправочникСсылка.ВнешниеПользователи")
	   И ТипЗнч(Пользователь) <> Тип("СправочникСсылка.ГруппыВнешнихПользователей") Тогда
		
		Возврат Ложь;
	КонецЕсли;
	
	ИдентификаторПоставляемогоПрофиля = Неопределено;
	
	Если ТипЗнч(ПоставляемыйПрофиль) = Тип("Строка") Тогда
		Если СтроковыеФункцииКлиентСервер.ЭтоУникальныйИдентификатор(ПоставляемыйПрофиль) Тогда
			
			ИдентификаторПоставляемогоПрофиля = ПоставляемыйПрофиль;
			
			ПоставляемыйПрофиль = Справочники.ПрофилиГруппДоступа.ПоставляемыйПрофильПоИдентификатору(
				ИдентификаторПоставляемогоПрофиля);
		Иначе
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(ПоставляемыйПрофиль) <> Тип("СправочникСсылка.ПрофилиГруппДоступа") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ИдентификаторПоставляемогоПрофиля = Неопределено Тогда
		ИдентификаторПоставляемогоПрофиля =
			Справочники.ПрофилиГруппДоступа.ИдентификаторПоставляемогоПрофиля(ПоставляемыйПрофиль);
	КонецЕсли;
	
	Если ИдентификаторПоставляемогоПрофиля = Справочники.ПрофилиГруппДоступа.ИдентификаторПрофиляАдминистратор() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПоставляемыеПрофили = УправлениеДоступомСлужебныйПовтИсп.Параметры().ПоставляемыеПрофилиГруппДоступа;
	СвойстваПрофиля = ПоставляемыеПрофили.ОписанияПрофилей.Получить(ИдентификаторПоставляемогоПрофиля);
	
	Если СвойстваПрофиля = Неопределено
	 ИЛИ СвойстваПрофиля.ВидыДоступа.Количество() <> 0 Тогда
		
		Возврат Ложь;
	КонецЕсли;
	
	ГруппаДоступа = Неопределено;
	
	Если УпрощенныйИнтерфейсНастройкиПравДоступа() Тогда
		
		Если ТипЗнч(Пользователь) <> Тип("СправочникСсылка.Пользователи")
		   И ТипЗнч(Пользователь) <> Тип("СправочникСсылка.ВнешниеПользователи") Тогда
			
			Возврат Ложь;
		КонецЕсли;
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Профиль", ПоставляемыйПрофиль);
		Запрос.УстановитьПараметр("Пользователь", Пользователь);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ГруппыДоступа.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ГруппыДоступа КАК ГруппыДоступа
		|ГДЕ
		|	ГруппыДоступа.Профиль = &Профиль
		|	И ГруппыДоступа.Пользователь = &Пользователь";
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			ГруппаДоступа = Выборка.Ссылка;
		КонецЕсли;
		
		Если ГруппаДоступа = Неопределено Тогда
			Если Включить <> Истина Тогда
				Возврат Ложь;
			Иначе
				ГруппаДоступа = Справочники.ГруппыДоступа.СоздатьЭлемент();
				ГруппаДоступа.Наименование = СвойстваПрофиля.Наименование;
				ГруппаДоступа.Профиль      = ПоставляемыйПрофиль;
				ГруппаДоступа.Пользователь = Пользователь;
				ГруппаДоступа.Пользователи.Добавить().Пользователь = Пользователь;
				ГруппаДоступа.Записать();
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	Иначе
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ПоставляемыйПрофиль", ПоставляемыйПрофиль);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	ГруппыДоступа.Ссылка КАК Ссылка,
		|	ГруппыДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля
		|ИЗ
		|	Справочник.ГруппыДоступа КАК ГруппыДоступа
		|ГДЕ
		|	ГруппыДоступа.Профиль = &ПоставляемыйПрофиль
		|
		|УПОРЯДОЧИТЬ ПО
		|	ГруппыДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля УБЫВ";
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			ГруппаДоступа = Выборка.Ссылка;
		КонецЕсли;
		
		Если ГруппаДоступа = Неопределено Тогда
			Если Включить <> Истина Тогда
				Возврат Ложь;
			Иначе
				ГруппаДоступа = Справочники.ГруппыДоступа.СоздатьЭлемент();
				ГруппаДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля = Истина;
				ГруппаДоступа.Наименование = СвойстваПрофиля.Наименование;
				ГруппаДоступа.Профиль = ПоставляемыйПрофиль;
				ГруппаДоступа.Пользователи.Добавить().Пользователь = Пользователь;
				ГруппаДоступа.Записать();
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", ГруппаДоступа);
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИСТИНА КАК ЗначениеИстина
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК УчастникиГруппы
	|ГДЕ
	|	УчастникиГруппы.Ссылка = &Ссылка
	|	И УчастникиГруппы.Пользователь = &Пользователь";
	ПользовательНайден = НЕ Запрос.Выполнить().Пустой();
	
	Если Включить = Неопределено Тогда
		Возврат ПользовательНайден;
	КонецЕсли;
	
	Если Включить И ПользовательНайден Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если НЕ Включить И НЕ ПользовательНайден Тогда
		Возврат Истина;
	КонецЕсли;
	
	ГруппаДоступа = ГруппаДоступа.ПолучитьОбъект();
	
	Если НЕ УпрощенныйИнтерфейсНастройкиПравДоступа()
	   И НЕ ГруппаДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля Тогда
		
		ГруппаДоступа.ОсновнаяГруппаДоступаПоставляемогоПрофиля = Истина;
	КонецЕсли;
	
	Если Включить Тогда
		ГруппаДоступа.Пользователи.Добавить().Пользователь = Пользователь;
	Иначе
		Отбор = Новый Структура("Пользователь", Пользователь);
		Строки = ГруппаДоступа.Пользователи.НайтиСтроки(Отбор);
		Для каждого Строка Из Строки Цикл
			ГруппаДоступа.Пользователи.Удалить(Строка);
		КонецЦикла;
	КонецЕсли;
	
	ГруппаДоступа.Записать();
	
	Возврат Истина;
	
КонецФункции

// Для процедуры ЗаписатьНаборыЗначенийДоступаПриЗаписи.

// Перезаписывает наборы значений доступа проверяемого объекта
// в РегистрСведений.НаборыЗначенийДоступа, используя процедуру
// УправлениеДоступом.ЗаполнитьНаборыЗначенийДоступа().
//
// Процедура вызывается из УправлениеДоступомСлужебный.ЗаписатьНаборыЗначенийДоступа(),
// но может быть вызвана из любого места, например,
// при включении ограничения доступа на уровне записей.
//
// Вызывает процедуру прикладного разработчика
// УправлениеДоступомПереопределяемый.ПриИзмененииНаборовЗначенийДоступа(),
// которая используется для перезаписи зависимых наборов значений доступа.
//
// Параметры:
//  Объект       - СправочникОбъект, ДокументОбъект, ..., или СправочникСсылка, ДокументСсылка, ...
//                 В случае вызова с клиента можно передать только ссылку, а нужен объект.
//                 Если получена ссылка, то по ней будет получен объект.
//  ОбновлениеИБ - Булево - если Истина, то необходимо выполнять запись данных, 
//                 не выполняя лишних, избыточных действий с данными.
//                 См. ОбновлениеИнформационнойБазы.ЗаписатьДанные.
//
Процедура ЗаписатьНаборыЗначенийДоступа(Знач Объект, ЕстьИзменения = Неопределено, ОбновлениеИБ = Ложь)
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Если передача параметра Объект производилась с клиента на сервер,
	// то передавалась ссылка, и объект требуется получить.
	Объект = ?(Объект = Объект.Ссылка, Объект.ПолучитьОбъект(), Объект);
	СсылкаНаОбъект = Объект.Ссылка;
	ТипЗначенияОбъект = ТипЗнч(Объект);
	
	НаборыЗаписываются = УправлениеДоступомСлужебныйПовтИсп.ТипыОбъектовВПодпискахНаСобытия(
		"ЗаписатьНаборыЗначенийДоступа").Получить(ТипЗначенияОбъект) <> Неопределено;
	
	Если НЕ НаборыЗаписываются Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверные параметры.
			           |Тип объекта ""%1""
			           |не найден в подписках на события
			           |""Записать наборы значений доступа"".'"),
			ТипЗначенияОбъект);
	КонецЕсли;
	
	ВозможныеТипыОбъектов = УправлениеДоступомСлужебныйПовтИсп.ТипыПоляТаблицы(
		"РегистрСведений.НаборыЗначенийДоступа.Измерение.Объект");
	
	Если ВозможныеТипыОбъектов.Получить(ТипЗнч(СсылкаНаОбъект)) = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка при записи наборов значений доступа:
			           |в регистре сведений НаборыЗначенийДоступа в измерении Объект
			           |не задан тип ""%1"".'"),
			СсылкаНаОбъект.Метаданные().ПолноеИмя());
	КонецЕсли;
	
	Если УправлениеДоступом.ОграничиватьДоступНаУровнеЗаписей() Тогда
		
		Если Метаданные.НайтиПоТипу(ТипЗначенияОбъект).ТабличныеЧасти.Найти("НаборыЗначенийДоступа") = Неопределено Тогда
			
			Таблица = УправлениеДоступом.ТаблицаНаборыЗначенийДоступа();
			УправлениеДоступом.ЗаполнитьНаборыЗначенийДоступа(Объект, Таблица);
			
			УправлениеДоступом.ДобавитьНаборыЗначенийДоступа(
				Таблица, УправлениеДоступом.ТаблицаНаборыЗначенийДоступа(), Ложь, Истина);
		Иначе
			ТабличнаяЧастьЗаполняется = УправлениеДоступомСлужебныйПовтИсп.ТипыОбъектовВПодпискахНаСобытия(
				"ЗаполнитьНаборыЗначенийДоступаТабличныхЧастей").Получить(ТипЗначенияОбъект) <> Неопределено;
			
			Если НЕ ТабличнаяЧастьЗаполняется Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Неверные параметры.
					           |Тип объекта ""%1""
					           |не найден в подписках на события
					           |""Заполнить наборы значений доступа табличных частей"".'"),
					ТипЗначенияОбъект);
			КонецЕсли;
			// Записан объект с уже заполненной табличной частью НаборыЗначенийДоступа.
			Таблица = Объект.НаборыЗначенийДоступа.Выгрузить();
		КонецЕсли;
		
		ПодготовитьНаборыЗначенийДоступаКЗаписи(СсылкаНаОбъект, Таблица, Истина);
		
		Данные = Новый Структура;
		Данные.Вставить("МенеджерРегистра",   РегистрыСведений.НаборыЗначенийДоступа);
		Данные.Вставить("ФиксированныйОтбор", Новый Структура("Объект", СсылкаНаОбъект));
		Данные.Вставить("НовыеЗаписи",        Таблица);
		Данные.Вставить("ОбновлениеИБ",       ОбновлениеИБ);
		
		НачатьТранзакцию();
		Попытка
			ОбновитьНаборыЗаписей(Данные, ЕстьИзменения);
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		
		Если ЕстьИзменения = Истина Тогда
			ПриИзмененииНаборовЗначенийДоступа(СсылкаНаОбъект, ОбновлениеИБ);
		КонецЕсли;
	Иначе
		Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ИСТИНА КАК ЗначениеИстина
		|ИЗ
		|	РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначенийДоступа
		|ГДЕ
		|	НаборыЗначенийДоступа.Объект = &СсылкаНаОбъект");
		
		Запрос.УстановитьПараметр("СсылкаНаОбъект", СсылкаНаОбъект);
		
		Если НЕ Запрос.Выполнить().Пустой() Тогда
			// Очистка устаревшего набора.
			// Запись нового набора будет выполнена регламентным заданием,
			// после включения ограничения на уровне записей.
			НаборЗаписей = РегистрыСведений.НаборыЗначенийДоступа.СоздатьНаборЗаписей();
			НаборЗаписей.Отбор.Объект.Установить(СсылкаНаОбъект);
			НаборЗаписей.Записать();
			ЕстьИзменения = Истина;
			
			// Очистка устаревших зависимых наборов.
			ПриИзмененииНаборовЗначенийДоступа(СсылкаНаОбъект, ОбновлениеИБ);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ЗаписатьЗависимыеНаборыЗначенийДоступаПриЗаписи.

// Перезаписывает наборы значений доступа зависимых объектов.
//
//  Процедура вызывается из УправлениеДоступомСлужебный.ЗаписатьЗависимыеНаборыЗначенийДоступа(),
// состав типов подписки дополняет (без пересечения) состав типов подписки ЗаписатьНаборыЗначенийДоступа,
// теми типами, для которых выполнять запись наборов в регистр сведений НаборыЗначенийДоступа
// не требуется, но сами наборы входят в состав других наборов, например, наборы некоторых файлов
// из справочника "Файлы" могут входить в состав некоторых бизнес-процессов "Задание", созданных
// на основании файлов, при этом наборы файлов записывать в регистр не требуется.
//
// Вызывает процедуру прикладного разработчика
// УправлениеДоступомПереопределяемый.ПриИзмененииНаборовЗначенийДоступа(),
// которая используется для перезаписи зависимых наборов значений доступа,
// то есть организуется рекурсия.
//
// Параметры:
//  Объект       - СправочникОбъект, ДокументОбъект, ..., или СправочникСсылка, ДокументСсылка, ...
//                 В случае вызова с клиента можно передать только ссылку, а нужен объект.
//                 Если получена ссылка, то по ней будет получен объект.
//
//  ОбновлениеИБ - Булево - если Истина, то необходимо выполнять запись данных, 
//                 не выполняя лишних, избыточных действий с данными.
//                 См. ОбновлениеИнформационнойБазы.ЗаписатьДанные.
//
Процедура ЗаписатьЗависимыеНаборыЗначенийДоступа(Знач Объект, ОбновлениеИБ = Ложь)
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Если передача параметра Объект производилась с клиента на сервер,
	// то передавалась ссылка, и объект требуется получить.
	Объект = ?(Объект = Объект.Ссылка, Объект.ПолучитьОбъект(), Объект);
	СсылкаНаОбъект = Объект.Ссылка;
	ТипЗначенияОбъект = ТипЗнч(Объект);
	
	ЭтоВедущийОбъект = УправлениеДоступомСлужебныйПовтИсп.ТипыОбъектовВПодпискахНаСобытия(
		"ЗаписатьЗависимыеНаборыЗначенийДоступа").Получить(ТипЗначенияОбъект) <> Неопределено;
	
	Если НЕ ЭтоВедущийОбъект Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверные параметры.
			           |Тип объекта ""%1""
			           |не найден в подписке на события
			           |""Записать зависимые наборы значений доступа"".'"),
			ТипЗначенияОбъект);
	КонецЕсли;
	
	ПриИзмененииНаборовЗначенийДоступа(СсылкаНаОбъект, ОбновлениеИБ);
	
КонецПроцедуры

// Для процедур ОбновитьВспомогательныеДанныеПоИзменениямКонфигурации и
// ЗаполнитьОбработчикиРазделенныхДанных.

// Проверяет были ли изменения неразделенных данных для какой-нибудь области данных.
Функция ЕстьИзмененияПараметровОграниченияДоступа()
	
	УстановитьПривилегированныйРежим(Истина);
	
	ПроверяемыеПараметры = Новый Массив;
	ПроверяемыеПараметры.Добавить("ОбъектыМетаданныхПравРолей");
	ПроверяемыеПараметры.Добавить("ВозможныеПраваДляНастройкиПравОбъектов");
	ПроверяемыеПараметры.Добавить("ПоставляемыеПрофилиГруппДоступа");
	ПроверяемыеПараметры.Добавить("ПредопределенныеПрофилиГруппДоступа");
	ПроверяемыеПараметры.Добавить("ТипыГруппИЗначенийДоступа");
	
	Параметры = УправлениеДоступомСлужебныйПовтИсп.Параметры();
	
	Для каждого ПроверяемыйПараметр Из ПроверяемыеПараметры Цикл
		
		ПоследниеИзменения = СтандартныеПодсистемыСервер.ИзмененияПараметраРаботыПрограммы(
			Параметры, ПроверяемыйПараметр);
		
		Если ПоследниеИзменения = Неопределено
		 ИЛИ ПоследниеИзменения.Количество() > 0 Тогда
			
			Возврат Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Для процедуры ОбновитьРолиПользователей.

Функция ТекущиеСвойстваПользователей(МассивПользователей)
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ПустойИдентификатор",
		Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000"));
	
	Если МассивПользователей = Неопределено Тогда
		Запрос.Текст =
		"ВЫБРАТЬ
		|	Пользователи.Ссылка КАК Пользователь,
		|	Пользователи.ИдентификаторПользователяИБ
		|ПОМЕСТИТЬ ПроверяемыеПользователи
		|ИЗ
		|	Справочник.Пользователи КАК Пользователи
		|ГДЕ
		|	Пользователи.Служебный = ЛОЖЬ
		|	И Пользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	ВнешниеПользователи.Ссылка,
		|	ВнешниеПользователи.ИдентификаторПользователяИБ
		|ИЗ
		|	Справочник.ВнешниеПользователи КАК ВнешниеПользователи
		|ГДЕ
		|	ВнешниеПользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор";
		
	ИначеЕсли ТипЗнч(МассивПользователей) = Тип("Тип") Тогда
		Если Метаданные.НайтиПоТипу(МассивПользователей) = Метаданные.Справочники.ВнешниеПользователи Тогда
			Запрос.Текст =
			"ВЫБРАТЬ
			|	ВнешниеПользователи.Ссылка КАК Пользователь,
			|	ВнешниеПользователи.ИдентификаторПользователяИБ
			|ПОМЕСТИТЬ ПроверяемыеПользователи
			|ИЗ
			|	Справочник.ВнешниеПользователи КАК ВнешниеПользователи
			|ГДЕ
			|	ВнешниеПользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор";
		Иначе
			Запрос.Текст =
			"ВЫБРАТЬ
			|	Пользователи.Ссылка КАК Пользователь,
			|	Пользователи.ИдентификаторПользователяИБ
			|ПОМЕСТИТЬ ПроверяемыеПользователи
			|ИЗ
			|	Справочник.Пользователи КАК Пользователи
			|ГДЕ
			|	Пользователи.Служебный = ЛОЖЬ
			|	И Пользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор";
		КонецЕсли;
	Иначе
		ИсходныеПользователи = Новый ТаблицаЗначений;
		ИсходныеПользователи.Колонки.Добавить("Пользователь", Новый ОписаниеТипов(
			"СправочникСсылка.Пользователи, СправочникСсылка.ВнешниеПользователи"));
		
		Для каждого Пользователь Из МассивПользователей Цикл
			ИсходныеПользователи.Добавить().Пользователь = Пользователь;
		КонецЦикла;
		
		Запрос.УстановитьПараметр("ИсходныеПользователи", ИсходныеПользователи);
		Запрос.Текст =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ИсходныеПользователи.Пользователь
		|ПОМЕСТИТЬ ИсходныеПользователи
		|ИЗ
		|	&ИсходныеПользователи КАК ИсходныеПользователи
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	Пользователи.Ссылка КАК Пользователь,
		|	Пользователи.ИдентификаторПользователяИБ
		|ПОМЕСТИТЬ ПроверяемыеПользователи
		|ИЗ
		|	Справочник.Пользователи КАК Пользователи
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ИсходныеПользователи КАК ИсходныеПользователи
		|		ПО Пользователи.Ссылка = ИсходныеПользователи.Пользователь
		|			И (Пользователи.Служебный = ЛОЖЬ)
		|			И (Пользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор)
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	ВнешниеПользователи.Ссылка,
		|	ВнешниеПользователи.ИдентификаторПользователяИБ
		|ИЗ
		|	Справочник.ВнешниеПользователи КАК ВнешниеПользователи
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ИсходныеПользователи КАК ИсходныеПользователи
		|		ПО ВнешниеПользователи.Ссылка = ИсходныеПользователи.Пользователь
		|			И (ВнешниеПользователи.ИдентификаторПользователяИБ <> &ПустойИдентификатор)";
	КонецЕсли;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	Пользователи.Ссылка КАК Ссылка,
	|	Пользователи.ИдентификаторПользователяИБ
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Пользователи КАК Пользователи
	|		ПО (ГруппыДоступаПользователи.Ссылка = ЗНАЧЕНИЕ(Справочник.ГруппыДоступа.Администраторы))
	|			И ГруппыДоступаПользователи.Пользователь = Пользователи.Ссылка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ПроверяемыеПользователи.Пользователь,
	|	ПроверяемыеПользователи.ИдентификаторПользователяИБ
	|ИЗ
	|	ПроверяемыеПользователи КАК ПроверяемыеПользователи
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ПроверяемыеПользователи.Пользователь КАК Пользователь,
	|	ГруппыДоступаПользователи.Ссылка.Профиль КАК Профиль
	|ПОМЕСТИТЬ ВсеПрофилиПользователей
	|ИЗ
	|	ПроверяемыеПользователи КАК ПроверяемыеПользователи
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|		ПО ПроверяемыеПользователи.Пользователь = СоставыГруппПользователей.Пользователь
	|			И (СоставыГруппПользователей.Используется)
	|			И (&ИсключитьВнешнихПользователей)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ПО (СоставыГруппПользователей.ГруппаПользователей = ГруппыДоступаПользователи.Пользователь)
	|			И (НЕ ГруппыДоступаПользователи.Ссылка.ПометкаУдаления)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ПрофильныеРоли.Профиль КАК Профиль,
	|	ПрофильныеРоли.Роль КАК Роль
	|ПОМЕСТИТЬ ПрофильныеРоли
	|ИЗ
	|	&ПрофильныеРоли КАК ПрофильныеРоли
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ВсеПрофилиПользователей.Пользователь,
	|	ВсеПрофилиПользователей.Профиль,
	|	ПрофильныеРоли.Роль КАК ПрофильнаяРоль
	|ПОМЕСТИТЬ ПрофилиПользователей
	|ИЗ
	|	ВсеПрофилиПользователей КАК ВсеПрофилиПользователей
	|		ЛЕВОЕ СОЕДИНЕНИЕ ПрофильныеРоли КАК ПрофильныеРоли
	|		ПО (ПрофильныеРоли.Профиль = ВсеПрофилиПользователей.Профиль)
	|			И (НЕ ВсеПрофилиПользователей.Профиль.ПоставляемыйПрофильИзменен)
	|ГДЕ
	|	НЕ ВсеПрофилиПользователей.Профиль.ПометкаУдаления
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ПрофилиПользователей.Пользователь,
	|	Роли.Роль.Имя КАК Роль
	|ИЗ
	|	ПрофилиПользователей КАК ПрофилиПользователей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ПрофилиГруппДоступа.Роли КАК Роли
	|		ПО (Роли.Ссылка = ПрофилиПользователей.Профиль)
	|			И (ПрофилиПользователей.ПрофильнаяРоль ЕСТЬ NULL )
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	ПрофилиПользователей.Пользователь,
	|	ПрофилиПользователей.ПрофильнаяРоль
	|ИЗ
	|	ПрофилиПользователей КАК ПрофилиПользователей
	|ГДЕ
	|	НЕ ПрофилиПользователей.ПрофильнаяРоль ЕСТЬ NULL ";
	
	Запрос.Текст = Запрос.Текст + "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|" + ТекстЗапроса;
	
	ПрофильныеРоли = Новый ТаблицаЗначений;
	ПрофильныеРоли.Колонки.Добавить("Профиль", Новый ОписаниеТипов("СправочникСсылка.ПрофилиГруппДоступа"));
	ПрофильныеРоли.Колонки.Добавить("Роль", Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(255)));
	
	Если Не ОбщегоНазначенияПовтИсп.РазделениеВключено()
	   И ИспользоватьПрофильныеРоли() Тогда
		
		ОписаниеПрофильныхРолей = УправлениеДоступомСлужебныйПовтИсп.ОписаниеПрофильныхРолей();
		Для Каждого ОписаниеПрофильнойРоли Из ОписаниеПрофильныхРолей Цикл
			ЗаполнитьЗначенияСвойств(ПрофильныеРоли.Добавить(), ОписаниеПрофильнойРоли);
		КонецЦикла;
	КонецЕсли;
	
	Запрос.УстановитьПараметр("ПрофильныеРоли", ПрофильныеРоли);
	
	Если Константы.ИспользоватьВнешнихПользователей.Получить() Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИсключитьВнешнихПользователей", "Истина");
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИсключитьВнешнихПользователей",
			"ТИПЗНАЧЕНИЯ(ПроверяемыеПользователи.Пользователь) = ТИП(Справочник.Пользователи)");
	КонецЕсли;
	
	РезультатыЗапросов = Запрос.ВыполнитьПакет();
	ПоследнийРезультат = РезультатыЗапросов.Количество()-1;
	Итог = Новый Структура;
	
	Итог.Вставить("Администраторы", Новый Соответствие);
	
	Для каждого Строка Из РезультатыЗапросов[ПоследнийРезультат-5].Выгрузить() Цикл
		Итог.Администраторы.Вставить(Строка.Ссылка, Истина);
	КонецЦикла;
	
	Итог.Вставить("ИдентификаторыПользователейИБ", РезультатыЗапросов[ПоследнийРезультат-4].Выгрузить());
	Итог.ИдентификаторыПользователейИБ.Индексы.Добавить("Пользователь");
	
	Итог.Вставить("РолиПользователей", РезультатыЗапросов[ПоследнийРезультат].Выгрузить());
	Итог.РолиПользователей.Индексы.Добавить("Пользователь");
	
	Возврат Итог;
	
КонецФункции

Функция ИспользоватьПрофильныеРоли()
	
	Возврат Не ОбщегоНазначенияКлиентСервер.РежимОтладки();
КонецФункции

Функция ПрофилиПользователяСРолью(ТекущийПользователь, Роль)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ТекущийПользователь", ТекущийПользователь);
	Запрос.УстановитьПараметр("Роль", Роль);
	
	Запрос.УстановитьПараметр("ПустойИдентификатор",
		Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000"));
	
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	Роли.Ссылка КАК Профиль
	|ИЗ
	|	РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ПО (СоставыГруппПользователей.Пользователь = &ТекущийПользователь)
	|			И СоставыГруппПользователей.ГруппаПользователей = ГруппыДоступаПользователи.Пользователь
	|			И (СоставыГруппПользователей.Используется)
	|			И (НЕ ГруппыДоступаПользователи.Ссылка.ПометкаУдаления)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ПрофилиГруппДоступа.Роли КАК Роли
	|		ПО (Роли.Ссылка = ГруппыДоступаПользователи.Ссылка.Профиль)
	|			И (НЕ Роли.Ссылка.ПометкаУдаления)
	|			И (Роли.Роль.Имя = &Роль)";
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Профиль");
	
КонецФункции

Процедура ОбновитьРолиПользователейИБ(ОбновляемыеПользователиИБ, ПарольПользователяСервиса)
	
	Для каждого КлючИЗначение Из ОбновляемыеПользователиИБ Цикл
		РолиДляДобавления  = КлючИЗначение.Значение.РолиДляДобавления;
		РолиДляУдаления    = КлючИЗначение.Значение.РолиДляУдаления;
		ПользовательИБ     = КлючИЗначение.Значение.ПользовательИБ;
		ПользовательСсылка = КлючИЗначение.Значение.ПользовательСсылка;
		
		БылиПолныеПрава = ПользовательИБ.Роли.Содержит(Метаданные.Роли.ПолныеПрава);
		
		Для каждого КлючИЗначение Из РолиДляДобавления Цикл
			ПользовательИБ.Роли.Добавить(Метаданные.Роли[КлючИЗначение.Ключ]);
		КонецЦикла;
		
		Для каждого КлючИЗначение Из РолиДляУдаления Цикл
			ПользовательИБ.Роли.Удалить(Метаданные.Роли[КлючИЗначение.Ключ]);
		КонецЦикла;
		
		ЗаписатьПользователяПриОбновленииРолей(ПользовательСсылка, ПользовательИБ, БылиПолныеПрава, ПарольПользователяСервиса);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаписатьПользователяПриОбновленииРолей(ПользовательСсылка, ПользовательИБ, БылиПолныеПрава, ПарольПользователяСервиса)
	
	НачатьТранзакцию();
	
	Попытка
		ПользователиСлужебный.ЗаписатьПользователяИнформационнойБазы(ПользовательИБ, ПользовательСсылка);
		
		Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
			ЗафиксироватьТранзакцию();
			Возврат;
		КонецЕсли;
		
		ЕстьПолныеПрава = ПользовательИБ.Роли.Содержит(Метаданные.Роли.ПолныеПрава);
		Если ЕстьПолныеПрава = БылиПолныеПрава Тогда
			ЗафиксироватьТранзакцию();
			Возврат;
		КонецЕсли;
		
		Если ПарольПользователяСервиса = Неопределено Тогда
			
			Если ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
				ЗафиксироватьТранзакцию();
				Возврат;
			КонецЕсли;
			
			ВызватьИсключение
				НСтр("ru = 'Для изменения административного доступа
				           |требуется пароль пользователя сервиса.
				           |
				           |Операция может быть выполнена только интерактивно.'");
		КонецЕсли;
		
		Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса.ПользователиВМоделиСервиса") Тогда
			МодульПользователиСлужебныйВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("ПользователиСлужебныйВМоделиСервиса");
			МодульПользователиСлужебныйВМоделиСервиса.ЗаписатьПользователяСервиса(ПользовательСсылка, Ложь, ПарольПользователяСервиса);
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Для процедуры ТекстЗапросаВыбораИзменений.

Функция КлючИЗначение(Структура)
	
	Для каждого КлючИЗначение Из Структура Цикл
		Возврат КлючИЗначение;
	КонецЦикла;
	
КонецФункции

// Для процедур ОбновитьНаборЗаписей, ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям.

Процедура ЗаписатьОбъектИлиНаборЗаписей(Данные, ОбъектИлиНаборЗаписей)
	
	Если Данные.ОбновлениеИБ Тогда
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(ОбъектИлиНаборЗаписей);
	Иначе
		ОбъектИлиНаборЗаписей.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Для процедур ОбновитьНаборЗаписей и ОбновитьНаборыЗаписей.

Функция ГруппаПараметровИзмеренияОбработана(ИмяИзмерения, ЗначенияИзмерения)
	
	Если ИмяИзмерения = Неопределено Тогда
		ЗначенияИзмерения = Неопределено;
		
	ИначеЕсли ЗначенияИзмерения = Неопределено Тогда
		ИмяИзмерения = Неопределено;
		
	ИначеЕсли ТипЗнч(ЗначенияИзмерения) <> Тип("Массив")
	        И ТипЗнч(ЗначенияИзмерения) <> Тип("ФиксированныйМассив") Тогда
		
		ЗначениеИзмерения = ЗначенияИзмерения;
		ЗначенияИзмерения = Новый Массив;
		ЗначенияИзмерения.Добавить(ЗначениеИзмерения);
		
	ИначеЕсли ЗначенияИзмерения.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Процедура УпорядочитьГруппыПараметровИзмерений(Данные)
	
	Если Данные.ИмяВторогоИзмерения = Неопределено Тогда
		Данные.ИмяВторогоИзмерения       = Данные.ИмяТретьегоИзмерения;
		Данные.ЗначенияВторогоИзмерения  = Данные.ЗначенияТретьегоИзмерения;
		Данные.ИмяТретьегоИзмерения      = Неопределено;
		Данные.ЗначенияТретьегоИзмерения = Неопределено;
	КонецЕсли;
	
	Если Данные.ИмяПервогоИзмерения = Неопределено Тогда
		Данные.ИмяПервогоИзмерения       = Данные.ИмяВторогоИзмерения;
		Данные.ЗначенияПервогоИзмерения  = Данные.ЗначенияВторогоИзмерения;
		Данные.ИмяВторогоИзмерения       = Данные.ИмяТретьегоИзмерения;
		Данные.ЗначенияВторогоИзмерения  = Данные.ЗначенияТретьегоИзмерения;
		Данные.ИмяТретьегоИзмерения      = Неопределено;
		Данные.ЗначенияТретьегоИзмерения = Неопределено;
	КонецЕсли;
	
	Если Данные.ЗначенияВторогоИзмерения  <> Неопределено
	   И Данные.ЗначенияТретьегоИзмерения <> Неопределено
	   И Данные.ЗначенияВторогоИзмерения.Количество()
	   > Данные.ЗначенияТретьегоИзмерения.Количество() Тогда
		
		ИмяИзмерения      = Данные.ИмяВторогоИзмерения;
		ЗначенияИзмерения = Данные.ЗначенияВторогоИзмерения;
		
		Данные.ИмяВторогоИзмерения       = Данные.ИмяТретьегоИзмерения;
		Данные.ЗначенияВторогоИзмерения  = Данные.ЗначенияТретьегоИзмерения;
		Данные.ИмяТретьегоИзмерения      = ИмяИзмерения;
		Данные.ЗначенияТретьегоИзмерения = ЗначенияИзмерения;
	КонецЕсли;
	
	Если Данные.ЗначенияПервогоИзмерения <> Неопределено
	   И Данные.ЗначенияВторогоИзмерения <> Неопределено
	   И Данные.ЗначенияПервогоИзмерения.Количество()
	   > Данные.ЗначенияВторогоИзмерения.Количество() Тогда
		
		ИмяИзмерения      = Данные.ИмяПервогоИзмерения;
		ЗначенияИзмерения = Данные.ЗначенияПервогоИзмерения;
		
		Данные.ИмяПервогоИзмерения      = Данные.ИмяВторогоИзмерения;
		Данные.ЗначенияПервогоИзмерения = Данные.ЗначенияВторогоИзмерения;
		Данные.ИмяВторогоИзмерения      = ИмяИзмерения;
		Данные.ЗначенияВторогоИзмерения = ЗначенияИзмерения;
	КонецЕсли;
	
КонецПроцедуры

Функция ПоляНабораЗаписей(НаборЗаписей)
	
	ПоляСравнения = "";
	Таблица = НаборЗаписей.Выгрузить(Новый Массив);
	Для каждого Колонка Из Таблица.Колонки Цикл
		ПоляСравнения = ПоляСравнения + "," + Колонка.Имя;
	КонецЦикла;
	ПоляСравнения = Сред(ПоляСравнения, 2);
	
	Возврат ПоляСравнения;
	
КонецФункции

Функция ОбновитьНовыеЗаписиНабораПоВсемНовымЗаписям(Знач Данные,
                                                    Знач Отбор,
                                                    Знач СписокПолей,
                                                    Знач ИмяИзмерения,
                                                    Знач ЗначенияИзмерения,
                                                    ЕстьИзменения)
	
	// Открытие транзакции, если ее нет или она еще не открыта
	// для выполнения управляемой блокировки на читаемый набор записей.
	// Может быть ситуации, когда транзакция будет зафиксирована без
	// фактического изменения данных, т.е. если заблокированные данные совпадут.
	Если Данные.ТранзакцияОткрыта = Ложь Тогда
		Данные.ТранзакцияОткрыта = Истина;
		НачатьТранзакцию();
	КонецЕсли;
	
	ЗаблокироватьОбластьНабораЗаписей(Данные.НаборЗаписей, Данные.ПолноеИмяРегистра);
	
	Данные.НаборЗаписей.Прочитать();
	НовыеЗаписиНабора = Данные.НаборЗаписей.Выгрузить();
	НовыеЗаписиНабора.Индексы.Добавить(СписокПолей);
	
	Для каждого Значение Из ЗначенияИзмерения Цикл
		Отбор[ИмяИзмерения] = Значение;
		НайденныеЗаписи = НовыеЗаписиНабора.НайтиСтроки(Отбор);
		Для каждого НайденнаяЗапись Из НовыеЗаписиНабора.НайтиСтроки(Отбор) Цикл
			НовыеЗаписиНабора.Удалить(НайденнаяЗапись);
		КонецЦикла;
		Для каждого НайденнаяЗапись Из Данные.НовыеЗаписи.НайтиСтроки(Отбор) Цикл
			ЗаполнитьЗначенияСвойств(НовыеЗаписиНабора.Добавить(), НайденнаяЗапись);
		КонецЦикла;
	КонецЦикла;
	
	ТекущиеДанные = Новый Структура("НаборЗаписей, ПоляСравнения, ТолькоПроверка, ДополнительныеСвойства");
	ЗаполнитьЗначенияСвойств(ТекущиеДанные, Данные);
	ТекущиеДанные.Вставить("НовыеЗаписи", НовыеЗаписиНабора);
	ТекущиеДанные.Вставить("НаборЗаписейПрочитан", Истина);
	
	ОбновитьНаборЗаписей(ТекущиеДанные, ЕстьИзменения, , Данные.ТранзакцияОткрыта);
	
КонецФункции

Процедура ОбновитьНовыеЗаписиНабораПоРазличнымНовымЗаписям(Знач Данные, Знач Отбор, ЕстьИзменения)
	
	Если Данные.ТранзакцияОткрыта = Ложь Тогда
		Данные.ТранзакцияОткрыта = Истина;
		НачатьТранзакцию();
	КонецЕсли;
	
	// Получение количества записей для чтения.
	
	Если Отбор.Количество() = 0 Тогда
		ТекущиеНовыеЗаписи = Данные.НовыеЗаписи.Скопировать();
		КоличествоДляЧтения = Данные.КоличествоДляЧтения;
	Иначе
		ТекущиеНовыеЗаписи = Данные.НовыеЗаписи.Скопировать(Отбор);
		
		ИмяПоля = Данные.КоличествоПоЗначениям.Колонки[0].Имя;
		СтрокаКоличества = Данные.КоличествоПоЗначениям.Найти(Отбор[ИмяПоля], ИмяПоля);
		КоличествоДляЧтения = ?(СтрокаКоличества = Неопределено, 0, СтрокаКоличества.Количество);
	КонецЕсли;
	
	ОтборНовойЗаписи = Новый Структура("ВидИзмененияСтроки, " + Данные.ПоляСравнения, 1);
	ТекущиеНовыеЗаписи.Индексы.Добавить("ВидИзмененияСтроки, " + Данные.ПоляСравнения);

	КлючиЗаписей = ТекущиеНовыеЗаписи.Скопировать(, "ВидИзмененияСтроки, " + Данные.ПоляСравнения);
	КлючиЗаписей.Свернуть("ВидИзмененияСтроки, " + Данные.ПоляСравнения);
	КлючиЗаписей.Свернуть(Данные.ПоляСравнения, "ВидИзмененияСтроки");
	
	ОтборПоКлючуЗаписи = Новый Структура(Данные.ПоляСравнения);
	
	Если КоличествоДляЧтения < 1000
	 ИЛИ (  КоличествоДляЧтения < 100000
	      И КлючиЗаписей.Количество() * 50 > КоличествоДляЧтения) Тогда
		// Блочное обновление.
		ЗаблокироватьОбластьНабораЗаписей(Данные.НаборЗаписей, Данные.ПолноеИмяРегистра);
		Данные.НаборЗаписей.Прочитать();
		НовыеЗаписиНабора = Данные.НаборЗаписей.Выгрузить();
		НовыеЗаписиНабора.Индексы.Добавить(Данные.ПоляСравнения);
		
		Для каждого Строка Из КлючиЗаписей Цикл
			ЗаполнитьЗначенияСвойств(ОтборПоКлючуЗаписи, Строка);
			НайденныеСтроки = НовыеЗаписиНабора.НайтиСтроки(ОтборПоКлючуЗаписи);
			Если Строка.ВидИзмененияСтроки = -1 Тогда
				Если НайденныеСтроки.Количество() > 0 Тогда
					// Удаление старой строки.
					НовыеЗаписиНабора.Удалить(НайденныеСтроки[0]);
				КонецЕсли;
			Иначе
				// Добавление новой или обновление старой строки.
				Если НайденныеСтроки.Количество() = 0 Тогда
					ЗаполняемаяСтрока = НовыеЗаписиНабора.Добавить();
				Иначе
					ЗаполняемаяСтрока = НайденныеСтроки[0];
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(ОтборНовойЗаписи, ОтборПоКлючуЗаписи);
				НайденныеЗаписи = ТекущиеНовыеЗаписи.НайтиСтроки(ОтборНовойЗаписи);
				Если НайденныеЗаписи.Количество() = 1 Тогда
					НоваяЗапись = НайденныеЗаписи[0];
				Иначе // Ошибка в параметре НовыеЗаписи.
					ИсключениеПриОшибкеПоискаЗаписи(Данные);
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(ЗаполняемаяСтрока, НоваяЗапись);
			КонецЕсли;
		КонецЦикла;
		// Изменение набора записей, чтобы он отличался от новых записей набора.
		Если Данные.НаборЗаписей.Количество() = НовыеЗаписиНабора.Количество() Тогда
			Данные.НаборЗаписей.Добавить();
		КонецЕсли;
		
		ТекущиеДанные = Новый Структура("НаборЗаписей, ПоляСравнения, ТолькоПроверка, ДополнительныеСвойства");
		ЗаполнитьЗначенияСвойств(ТекущиеДанные, Данные);
		ТекущиеДанные.Вставить("НовыеЗаписи", НовыеЗаписиНабора);
		ТекущиеДанные.Вставить("НаборЗаписейПрочитан", Истина);
		
		ОбновитьНаборЗаписей(ТекущиеДанные, ЕстьИзменения, , Данные.ТранзакцияОткрыта);
	Иначе
		// Построчное обновление.
		УстановитьДополнительныеСвойства(Данные.НаборДляОднойЗаписи, Данные.ДополнительныеСвойства);
		Для каждого Строка Из КлючиЗаписей Цикл
			Данные.НаборДляОднойЗаписи.Очистить();
			ЗаполнитьЗначенияСвойств(ОтборПоКлючуЗаписи, Строка);
			Для каждого КлючИЗначение Из ОтборПоКлючуЗаписи Цикл
				УстановитьОтбор(
					Данные.НаборДляОднойЗаписи.Отбор[КлючИЗначение.Ключ], КлючИЗначение.Значение);
			КонецЦикла;
			ЗаблокироватьОбластьНабораЗаписей(Данные.НаборДляОднойЗаписи, Данные.ПолноеИмяРегистра);
			Если Строка.ВидИзмененияСтроки > -1 Тогда
				// Добавление новой или обновление существующей строки.
				ЗаполнитьЗначенияСвойств(ОтборНовойЗаписи, ОтборПоКлючуЗаписи);
				НайденныеЗаписи = ТекущиеНовыеЗаписи.НайтиСтроки(ОтборНовойЗаписи);
				Если НайденныеЗаписи.Количество() = 1 Тогда
					НоваяЗапись = НайденныеЗаписи[0];
				Иначе // Ошибка в параметре НовыеЗаписи.
					ИсключениеПриОшибкеПоискаЗаписи(Данные);
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(Данные.НаборДляОднойЗаписи.Добавить(), НоваяЗапись);
			КонецЕсли;
			ЕстьИзменения = Истина;
			Если Данные.ТолькоПроверка Тогда
				Возврат;
			КонецЕсли;
			ЗаписатьОбъектИлиНаборЗаписей(Данные, Данные.НаборДляОднойЗаписи);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ИсключениеПриОшибкеПоискаЗаписи(Параметры)
	
	Для каждого СтрокаИзменений Из Параметры.НовыеЗаписи Цикл
		Если СтрокаИзменений.ВидИзмененияСтроки <>  1
		   И СтрокаИзменений.ВидИзмененияСтроки <> -1 Тогда
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка в процедуре ОбновитьНаборыЗаписей
				           |общего модуля УправлениеДоступомСлужебный.
				           |
				           |Неверное значение параметра НовыеЗаписи - колонка
				           |ВидИзмененияСтроки содержит недопустимое значение ""%1"".
				           |
				           |Допустимо только 2 значения: ""1"" и ""-1"".'"),
				Строка(СтрокаИзменений.ВидИзмененияСтроки));
		КонецЕсли;
	КонецЦикла;
	
	ВызватьИсключение
		НСтр("ru = 'Ошибка в процедуре ОбновитьНаборыЗаписей
		           |общего модуля УправлениеДоступомСлужебный.
		           |
		           |Не удалось найти требуемую в строку
		           |в значении параметра НовыеЗаписи.'");
	
КонецПроцедуры

Процедура ЗаблокироватьОбластьНабораЗаписей(НаборЗаписей, ПолноеИмяРегистра = Неопределено)
	
	Если НЕ ТранзакцияАктивна() Тогда
		Возврат;
	КонецЕсли;
	
	Если ПолноеИмяРегистра = Неопределено Тогда
		ПолноеИмяРегистра = Метаданные.НайтиПоТипу(ТипЗнч(НаборЗаписей)).ПолноеИмя();
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить(ПолноеИмяРегистра);
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
	Для каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
		Если ЭлементОтбора.Использование Тогда
			ЭлементБлокировки.УстановитьЗначение(ЭлементОтбора.ПутьКДанным, ЭлементОтбора.Значение);
		КонецЕсли;
	КонецЦикла;
	Блокировка.Заблокировать();
	
КонецПроцедуры

Процедура УстановитьОтбор(ЭлементОтбора, ЗначениеОтбора)
	
	ЭлементОтбора.Значение = ЗначениеОтбора;
	ЭлементОтбора.Использование = Истина;
	
КонецПроцедуры

Функция ЗаписьНесколькимиНаборами(Данные, Отбор, ИмяПоля, ЗначенияПоля)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ЗначенияПоля", ЗначенияПоля);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	&УсловиеОтбора
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	ТекущаяТаблица.ИмяПоля В(&ЗначенияПоля)
	|	И &УсловиеОтбора
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТекущаяТаблица.ИмяПоля КАК ИмяПоля,
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	ТекущаяТаблица.ИмяПоля В(&ЗначенияПоля)
	|	И &УсловиеОтбора
	|
	|СГРУППИРОВАТЬ ПО
	|	ТекущаяТаблица.ИмяПоля";
	
	УсловиеОтбора = "Истина";
	Если Данные.ФиксированныйОтбор <> Неопределено Тогда
		Для каждого КлючИЗначение Из Данные.ФиксированныйОтбор Цикл
			УсловиеОтбора = УсловиеОтбора + "
			|	И ТекущаяТаблица." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
			Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	ОтборДобавляемых = Новый Структура;
	ОтборДобавляемых.Вставить("ВидИзмененияСтроки", 1);
	ОтборУдаляемых = Новый Структура;
	ОтборУдаляемых.Вставить("ВидИзмененияСтроки", -1);
	
	Для каждого КлючИЗначение Из Отбор Цикл
		УсловиеОтбора = УсловиеОтбора + "
		|	И ТекущаяТаблица." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		ОтборДобавляемых.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		ОтборУдаляемых.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяПоля", ИмяПоля);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекущаяТаблица", Данные.ПолноеИмяРегистра);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеОтбора", УсловиеОтбора);
	
	РезультатыЗапросов = Запрос.ВыполнитьПакет();
	
	// Количество всех без отбора.
	КоличествоВсех = РезультатыЗапросов[0].Выгрузить()[0].Количество;
	Данные.Вставить("КоличествоДляЧтения", КоличествоВсех);
	
	// Количество обновляемых с отбором.
	КоличествоОбновляемых = РезультатыЗапросов[1].Выгрузить()[0].Количество;
	
	КоличествоДобавляемых = Данные.НовыеЗаписи.НайтиСтроки(ОтборДобавляемых).Количество();
	Если КоличествоДобавляемых > КоличествоОбновляемых Тогда
		КоличествоОбновляемых = КоличествоДобавляемых;
	КонецЕсли;
	
	КоличествоУдаляемых = Данные.НовыеЗаписи.НайтиСтроки(ОтборУдаляемых).Количество();
	Если КоличествоУдаляемых > КоличествоОбновляемых Тогда
		КоличествоОбновляемых = КоличествоУдаляемых;
	КонецЕсли;
	
	// Количество для чтения по значениям отбора.
	КоличествоПоЗначениям = РезультатыЗапросов[2].Выгрузить();
	КоличествоПоЗначениям.Индексы.Добавить(ИмяПоля);
	Данные.Вставить("КоличествоПоЗначениям", КоличествоПоЗначениям);
	
	Возврат КоличествоВсех * 0.7 > КоличествоОбновляемых;
	
КонецФункции

Процедура ПрочитатьКоличествоДляЧтения(Данные)
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	&ТекущаяТаблица КАК ТекущаяТаблица
	|ГДЕ
	|	&УсловиеОтбора";
	
	УсловиеОтбора = "Истина";
	Если Данные.ФиксированныйОтбор <> Неопределено Тогда
		Для каждого КлючИЗначение Из Данные.ФиксированныйОтбор Цикл
			УсловиеОтбора = УсловиеОтбора + "
			|	И ТекущаяТаблица." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
			Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекущаяТаблица", Данные.ПолноеИмяРегистра);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеОтбора", УсловиеОтбора);
	
	РезультатыЗапросов = Запрос.ВыполнитьПакет();
	
	Данные.Вставить("КоличествоДляЧтения", Запрос.Выполнить().Выгрузить()[0].Количество);
	
КонецПроцедуры

Процедура УстановитьДополнительныеСвойства(НаборЗаписей, ДополнительныеСвойства)
	
	Если ТипЗнч(ДополнительныеСвойства) = Тип("Структура") Тогда
		Для каждого КлючИЗначение Из ДополнительныеСвойства Цикл
			НаборЗаписей.ДополнительныеСвойства.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Для процедуры ОбновитьРегистрСведений.

Функция ЗначенияКолонкиТаблицы(Таблица, ИмяКолонки)
	
	НоваяТаблица = Таблица.Скопировать(, ИмяКолонки);
	
	НоваяТаблица.Свернуть(ИмяКолонки);
	
	Возврат НоваяТаблица.ВыгрузитьКолонку(ИмяКолонки);
	
КонецФункции

// Обслуживание таблиц ВидыДоступа и ЗначенияДоступа в формах редактирования.

Процедура ДобавитьРеквизитыВспомогательныхДанныхВФорму(Форма, ИмяРеквизитаХранилищаТаблиц)
	
	ДобавляемыеРеквизиты = Новый Массив;
	ОписаниеТиповЗначенийДоступа = Метаданные.ОпределяемыеТипы.ЗначениеДоступа.Тип;
	
	ПутьКОбъекту = ?(ЗначениеЗаполнено(ИмяРеквизитаХранилищаТаблиц), ИмяРеквизитаХранилищаТаблиц + ".", "");
	
	// Добавление реквизитов в таблицу ВидыДоступа.
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"Используется", Новый ОписаниеТипов("Булево"), ПутьКОбъекту + "ВидыДоступа"));
	
	// Добавление отдельных реквизитов.
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ТекущийВидДоступа", ОписаниеТиповЗначенийДоступа));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ТекущиеТипыВыбираемыхЗначений", Новый ОписаниеТипов("СписокЗначений")));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ТекущийТипВыбираемыхЗначений", ОписаниеТиповЗначенийДоступа));
	
	Если НЕ РеквизитФормыСуществует(Форма, "ИспользоватьВнешнихПользователей") Тогда
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
			"ИспользоватьВнешнихПользователей", Новый ОписаниеТипов("Булево")));
	КонецЕсли;
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ИмяРеквизитаХранилищаТаблиц", Новый ОписаниеТипов("Строка")));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ЭтоПрофильГруппДоступа", Новый ОписаниеТипов("Булево")));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ВидДоступаПользователи", ОписаниеТиповЗначенийДоступа));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ВидДоступаВнешниеПользователи", ОписаниеТиповЗначенийДоступа));
	
	// Добавление таблицы ВсеВидыДоступа.
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ВсеВидыДоступа", Новый ОписаниеТипов("ТаблицаЗначений")));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"Ссылка", ОписаниеТиповЗначенийДоступа, "ВсеВидыДоступа"));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"Представление", Новый ОписаниеТипов("Строка"), "ВсеВидыДоступа"));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"Используется", Новый ОписаниеТипов("Булево"), "ВсеВидыДоступа"));
	
	// Добавление таблицы ПредставленияВсеРазрешены.
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ПредставленияВсеРазрешены", Новый ОписаниеТипов("ТаблицаЗначений")));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"Имя", Новый ОписаниеТипов("Строка"), "ПредставленияВсеРазрешены"));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"Представление", Новый ОписаниеТипов("Строка"), "ПредставленияВсеРазрешены"));
	
	// Добавление таблицы ВсеТипыВыбираемыхЗначений.
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ВсеТипыВыбираемыхЗначений", Новый ОписаниеТипов("ТаблицаЗначений")));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ВидДоступа", ОписаниеТиповЗначенийДоступа, "ВсеТипыВыбираемыхЗначений"));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ТипЗначений", ОписаниеТиповЗначенийДоступа, "ВсеТипыВыбираемыхЗначений"));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ПредставлениеТипа", Новый ОписаниеТипов("Строка"), "ВсеТипыВыбираемыхЗначений"));
	
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(
		"ИмяТаблицы", Новый ОписаниеТипов("Строка"), "ВсеТипыВыбираемыхЗначений"));
	
	Форма.ИзменитьРеквизиты(ДобавляемыеРеквизиты);
	
КонецПроцедуры

Процедура ЗаполнитьТаблицуВсеВидыДоступаВФорме(Форма)
	
	Для каждого СвойстваВидаДоступа Из СвойстваВидаДоступа() Цикл
		Строка = Форма.ВсеВидыДоступа.Добавить();
		Строка.Ссылка        = СвойстваВидаДоступа.Ссылка;
		Строка.Используется  = ВидДоступаИспользуется(Строка.Ссылка);
		// Обеспечение уникальности представлений.
		Представление = СвойстваВидаДоступа.Представление;
		Отбор = Новый Структура("Представление", Представление);
		Пока Форма.ВсеВидыДоступа.НайтиСтроки(Отбор).Количество() > 0 Цикл
			Отбор.Представление = Отбор.Представление + " ";
		КонецЦикла;
		Строка.Представление = Представление;
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьТаблицуПредставленияВсеРазрешеныВФорме(Форма, ЭтоПрофиль)
	
	Если ЭтоПрофиль Тогда
		Строка = Форма.ПредставленияВсеРазрешены.Добавить();
		Строка.Имя = "ВначалеВсеЗапрещены";
		Строка.Представление = НСтр("ru = 'Все запрещены, исключения назначаются в группах доступа'");
		
		Строка = Форма.ПредставленияВсеРазрешены.Добавить();
		Строка.Имя = "ВначалеВсеРазрешены";
		Строка.Представление = НСтр("ru = 'Все разрешены, исключения назначаются в группах доступа'");
		
		Строка = Форма.ПредставленияВсеРазрешены.Добавить();
		Строка.Имя = "ВсеЗапрещены";
		Строка.Представление = НСтр("ru = 'Все запрещены, исключения назначаются в профиле'");
		
		Строка = Форма.ПредставленияВсеРазрешены.Добавить();
		Строка.Имя = "ВсеРазрешены";
		Строка.Представление = НСтр("ru = 'Все разрешены, исключения назначаются в профиле'");
	Иначе
		Строка = Форма.ПредставленияВсеРазрешены.Добавить();
		Строка.Имя = "ВсеЗапрещены";
		Строка.Представление = НСтр("ru = 'Все запрещены'");
		
		Строка = Форма.ПредставленияВсеРазрешены.Добавить();
		Строка.Имя = "ВсеРазрешены";
		Строка.Представление = НСтр("ru = 'Все разрешены'");
	КонецЕсли;
	
	СписокВыбора = Форма.Элементы.ВидыДоступаВсеРазрешеныПредставление.СписокВыбора;
	
	Для каждого Строка Из Форма.ПредставленияВсеРазрешены Цикл
		СписокВыбора.Добавить(Строка.Представление);
	КонецЦикла;
	
КонецПроцедуры

Процедура ОформитьТаблицуВидыДоступаВФорме(Форма)
	
	Параметры = ПараметрыФормыРедактированияРазрешенныхЗначений(Форма);
	
	// Оформление отображения неиспользуемых видов доступа.
	ЭлементУсловногоОформления = Форма.УсловноеОформление.Элементы.Добавить();
	
	ЭлементЦветаОформления = ЭлементУсловногоОформления.Оформление.Элементы.Найти("TextColor");
	ЭлементЦветаОформления.Значение = WebЦвета.Серый;
	ЭлементЦветаОформления.Использование = Истина;
	
	ГруппаЭлементовОтбораДанных = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
	ГруппаЭлементовОтбораДанных.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
	ГруппаЭлементовОтбораДанных.Использование = Истина;
	
	ЭлементОтбораДанных = ГруппаЭлементовОтбораДанных.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных(Параметры.ПутьКТаблицам + "ВидыДоступа.ВидДоступа");
	ЭлементОтбораДанных.ВидСравнения   = ВидСравненияКомпоновкиДанных.НеРавно;
	ЭлементОтбораДанных.ПравоеЗначение = Неопределено;
	ЭлементОтбораДанных.Использование  = Истина;
	
	ЭлементОтбораДанных = ГруппаЭлементовОтбораДанных.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных(Параметры.ПутьКТаблицам + "ВидыДоступа.Используется");
	ЭлементОтбораДанных.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ЭлементОтбораДанных.ПравоеЗначение = Ложь;
	ЭлементОтбораДанных.Использование  = Истина;
	
	ЭлементОформляемогоПоля = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ЭлементОформляемогоПоля.Поле = Новый ПолеКомпоновкиДанных("ВидыДоступа");
	ЭлементОформляемогоПоля.Использование = Истина;
	
КонецПроцедуры

Процедура УдалитьЛишниеЗначенияДоступа(Форма, ТекущийОбъект = Неопределено)
	
	Параметры = ПараметрыФормыРедактированияРазрешенныхЗначений(Форма, ТекущийОбъект);
	
	СвойстваВидовДоступа = УправлениеДоступомСлужебныйПовтИсп.Параметры().СвойстваВидовДоступа;
	ПоТипамГруппИЗначений = СвойстваВидовДоступа.ПоТипамГруппИЗначений;
	
	Отбор = УправлениеДоступомСлужебныйКлиентСервер.ОтборВТаблицахФормыРедактированияРазрешенныхЗначений(
		Форма, "");
	
	Индекс = Параметры.ЗначенияДоступа.Количество()-1;
	Пока Индекс >= 0 Цикл
		ЗначениеДоступа = Параметры.ЗначенияДоступа[Индекс].ЗначениеДоступа;
		
		СвойстваВидаДоступа = ПоТипамГруппИЗначений.Получить(ТипЗнч(ЗначениеДоступа));
		Если СвойстваВидаДоступа <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(Отбор, Параметры.ЗначенияДоступа[Индекс]);
			Отбор.Вставить("ВидДоступа", СвойстваВидаДоступа.Ссылка);
		КонецЕсли;
		
		Если СвойстваВидаДоступа = Неопределено
		 ИЛИ Параметры.ЗначенияДоступа[Индекс].ВидДоступа <> Отбор.ВидДоступа
		 ИЛИ Параметры.ВидыДоступа.НайтиСтроки(Отбор).Количество() = 0 Тогда
			
			Параметры.ЗначенияДоступа.Удалить(Индекс);
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла;
	
КонецПроцедуры

Процедура УдалитьНесуществующиеВидыИЗначенияДоступа(Форма, ТекущийОбъект = Неопределено)
	
	Параметры = ПараметрыФормыРедактированияРазрешенныхЗначений(Форма, ТекущийОбъект);
	
	Индекс = Параметры.ВидыДоступа.Количество()-1;
	Пока Индекс >= 0 Цикл
		ВидДоступа = Параметры.ВидыДоступа[Индекс].ВидДоступа;
		Если СвойстваВидаДоступа(ВидДоступа) = Неопределено Тогда
			Параметры.ВидыДоступа.Удалить(Индекс);
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла;
	
	УдалитьЛишниеЗначенияДоступа(Форма, ТекущийОбъект);
	
КонецПроцедуры

Функция ПараметрыФормыРедактированияРазрешенныхЗначений(Форма, ТекущийОбъект = Неопределено)
	
	Возврат УправлениеДоступомСлужебныйКлиентСервер.ПараметрыФормыРедактированияРазрешенныхЗначений(
		Форма, ТекущийОбъект);
	
КонецФункции

Функция РеквизитФормыСуществует(Форма, ИмяРеквизита)
	
	Структура = Новый Структура(ИмяРеквизита, Null);
	
	ЗаполнитьЗначенияСвойств(Структура, Форма);
	
	Возврат Структура[ИмяРеквизита] <> Null;
	
КонецФункции

// Для процедуры УстановкаПараметровСеанса.

Функция ВсеКомбинацииВидовДоступа(НеупорядоченныйМассивИмен)
	
	// Ограничение на максимальную длину комбинации, чтобы не допустить
	// перегрузку параметров сеанса и препроцессора шаблонов ОДД.
	МаксимальнаяДлинаКомбинации = 4;
	
	Список = Новый СписокЗначений;
	Если ТипЗнч(НеупорядоченныйМассивИмен) = Тип("ФиксированныйМассив") Тогда
		Список.ЗагрузитьЗначения(Новый Массив(НеупорядоченныйМассивИмен));
	Иначе
		Список.ЗагрузитьЗначения(НеупорядоченныйМассивИмен);
	КонецЕсли;
	Список.СортироватьПоЗначению();
	МассивИмен = Список.ВыгрузитьЗначения();
	
	ИтогСтроки = Новый Массив;
	ИтогСтрока = Новый Массив;
	
	// Полный список поддерживается всегда.
	Для каждого Имя Из МассивИмен Цикл
		ИтогСтрока.Добавить(Имя);
	КонецЦикла;
	
	ИтогСтроки.Добавить(ИтогСтрока);
	
	Если МассивИмен.Количество() < 3 Тогда
		Возврат ГруппыСтрокВСтроку(ИтогСтроки);
	КонецЕсли;
	
	ПервоеИмя = МассивИмен[0];
	МассивИмен.Удалить(0);
	
	ПоследнееИмя = МассивИмен[МассивИмен.Количество()-1];
	МассивИмен.Удалить(МассивИмен.Количество()-1);
	
	КоличествоИменВКомбинации = МассивИмен.Количество();
	
	Если КоличествоИменВКомбинации > 1 Тогда
		
		Если (КоличествоИменВКомбинации-1) <= МаксимальнаяДлинаКомбинации Тогда
			ДлинаКомбинации = КоличествоИменВКомбинации-1;
		Иначе
			ДлинаКомбинации = МаксимальнаяДлинаКомбинации;
		КонецЕсли;
		
		ПозицииИменВКомбинации = Новый Массив;
		Для Счетчик = 1 По ДлинаКомбинации Цикл
			ПозицииИменВКомбинации.Добавить(Счетчик);
		КонецЦикла;
		
		Пока ДлинаКомбинации > 0 Цикл
			Пока Истина Цикл
				// Добавление комбинации из текущих позиций.
				ИтогСтрока = Новый Массив;
				ИтогСтрока.Добавить(ПервоеИмя);
				Для Индекс = 0 По ДлинаКомбинации-1 Цикл
					ИтогСтрока.Добавить(МассивИмен[ПозицииИменВКомбинации[Индекс]-1]);
				КонецЦикла;
				ИтогСтрока.Добавить(ПоследнееИмя);
				ИтогСтроки.Добавить(ИтогСтрока);
				// Продвижение позиции в комбинации.
				Индекс = ДлинаКомбинации-1;
				Пока Индекс >= 0 Цикл
					Если ПозицииИменВКомбинации[Индекс] < КоличествоИменВКомбинации - (ДлинаКомбинации - (Индекс+1)) Тогда
						ПозицииИменВКомбинации[Индекс] = ПозицииИменВКомбинации[Индекс] + 1;
						// Заполнение старших позиций начальными значениями.
						Для ИндексСтаршейПозиции = Индекс+1 По ДлинаКомбинации-1 Цикл
							ПозицииИменВКомбинации[ИндексСтаршейПозиции] =
								ПозицииИменВКомбинации[Индекс] + ИндексСтаршейПозиции - Индекс;
						КонецЦикла;
						Прервать;
					Иначе
						Индекс = Индекс - 1;
					КонецЕсли;
				КонецЦикла;
				Если Индекс < 0 Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
			ДлинаКомбинации = ДлинаКомбинации - 1;
			Для Индекс = 0 По ДлинаКомбинации - 1 Цикл
				ПозицииИменВКомбинации[Индекс] = Индекс + 1;
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	ИтогСтрока = Новый Массив;
	ИтогСтрока.Добавить(ПервоеИмя);
	ИтогСтрока.Добавить(ПоследнееИмя);
	ИтогСтроки.Добавить(ИтогСтрока);
	
	Возврат ГруппыСтрокВСтроку(ИтогСтроки);
	
КонецФункции

Функция ГруппыСтрокВСтроку(ГруппыСтрок)
	
	ИтогСтроки = Новый Массив;
	
	Для Каждого ИтогСтрока Из ГруппыСтрок Цикл
		ИтогСтроки.Добавить(СтрСоединить(ИтогСтрока, ","));
	КонецЦикла;
	
	Строки = СтрСоединить(
		ИтогСтроки,
		",
		|,");
	
	Шаблон =
		"%2%1%2
		|";
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Шаблон, Строки, ",");
	
КонецФункции

// Для процедур ОбновитьНаборыЗначенийДоступа, ПриИзмененииНаборовЗначенийДоступа.

// Проверяет, что наборы в табличной части отличаются от новых наборов.
Функция НаборыЗначенийДоступаТабличнойЧастиИзменены(СсылкаНаОбъект, НовыеНаборы)
	
	СтарыеНаборы = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(
		СсылкаНаОбъект, "НаборыЗначенийДоступа").Выгрузить();
	
	Если СтарыеНаборы.Количество() <> НовыеНаборы.Количество() Тогда
		Возврат Истина;
	КонецЕсли;
	
	СтарыеНаборы.Колонки.Добавить("ВидДоступа", Новый ОписаниеТипов("Строка"));
	УправлениеДоступом.ДобавитьНаборыЗначенийДоступа(
		СтарыеНаборы, УправлениеДоступом.ТаблицаНаборыЗначенийДоступа(), Ложь, Истина);
	
	ПоляПоиска = "НомерНабора, ЗначениеДоступа, Уточнение, Чтение, Изменение";
	
	НовыеНаборы.Индексы.Добавить(ПоляПоиска);
	Отбор = Новый Структура(ПоляПоиска);
	
	Для каждого Строка Из СтарыеНаборы Цикл
		ЗаполнитьЗначенияСвойств(Отбор, Строка);
		Если НовыеНаборы.НайтиСтроки(Отбор).Количество() <> 1 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

#КонецОбласти
