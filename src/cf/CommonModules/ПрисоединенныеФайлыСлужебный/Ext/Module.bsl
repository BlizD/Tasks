////////////////////////////////////////////////////////////////////////////////
// Подсистема "Присоединенные файлы".
//
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

// Объявляет события подсистемы ПрисоединенныеФайлы:
//
// Серверные события:
//   ПриОпределенииСправочниковХраненияФайлов.
//
// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииСлужебныхСобытий(КлиентскиеСобытия, СерверныеСобытия) Экспорт
	
	// СЕРВЕРНЫЕ СОБЫТИЯ.
	
	// Позволяет переопределить справочники хранения файлов по типам владельцев.
	// 
	// Параметры:
	//  ТипВладелецФайла  - Тип ссылки объекта, к которому добавляется файл.
	//
	//  ИменаСправочников - Соответствие, содержащее в ключах имена справочников.
	//                      При вызове содержит имя одного стандартного справочника.
	//                      Если в значении соответствия разместить Истина только
	//                      один раз, тогда в случаях, когда требуется один справочник,
	//                      будет выбран такой справочник.
	//                      Если же справочников несколько, и не один в значении не содержит.
	//                      Истина или более одного содержат Истина, тогда будет ошибка.
	//
	// Синтаксис:
	// Процедура ПриОпределенииСправочниковХраненияФайлов(ТипВладелецФайла, ИменаСправочников) Экспорт
	//
	СерверныеСобытия.Добавить("СтандартныеПодсистемы.ПрисоединенныеФайлы\ПриОпределенииСправочниковХраненияФайлов");
	
КонецПроцедуры

// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииОбработчиковСлужебныхСобытий(КлиентскиеОбработчики, СерверныеОбработчики) Экспорт
	
	// СЕРВЕРНЫЕ ОБРАБОТЧИКИ.
	
	СерверныеОбработчики["СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления"].Добавить(
		"ПрисоединенныеФайлыСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииИсключенийПоискаСсылок"].Добавить(
		"ПрисоединенныеФайлыСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриОтправкеДанныхПодчиненному"].Добавить(
		"ПрисоединенныеФайлыСлужебный");
	
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриОтправкеДанныхГлавному"].Добавить(
		"ПрисоединенныеФайлыСлужебный");
		
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриПолученииДанныхОтПодчиненного"].Добавить(
		"ПрисоединенныеФайлыСлужебный");
		
	СерверныеОбработчики["СтандартныеПодсистемы.БазоваяФункциональность\ПриПолученииДанныхОтГлавного"].Добавить(
		"ПрисоединенныеФайлыСлужебный");
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ФайловыеФункции") Тогда
		СерверныеОбработчики["СтандартныеПодсистемы.ФайловыеФункции\ПриДобавленииФайловВТомаПриРазмещении"].Добавить(
			"ПрисоединенныеФайлыСлужебный");
		
		СерверныеОбработчики["СтандартныеПодсистемы.ФайловыеФункции\ПриУдаленииРегистрацииИзменений"].Добавить(
			"ПрисоединенныеФайлыСлужебный");
		
		СерверныеОбработчики["СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииТекстаЗапросаДляИзвлеченияТекста"].Добавить(
			"ПрисоединенныеФайлыСлужебный");
		
		СерверныеОбработчики["СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииКоличестваВерсийСНеизвлеченнымТекстом"].Добавить(
			"ПрисоединенныеФайлыСлужебный");
		
		СерверныеОбработчики["СтандартныеПодсистемы.ФайловыеФункции\ПриЗаписиИзвлеченногоТекста"].Добавить(
			"ПрисоединенныеФайлыСлужебный");
		
		СерверныеОбработчики["СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииКоличестваФайловВТомах"].Добавить(
			"ПрисоединенныеФайлыСлужебный");
		
		СерверныеОбработчики["СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииНаличияХранимыхФайлов"].Добавить(
			"ПрисоединенныеФайлыСлужебный");
		
		СерверныеОбработчики["СтандартныеПодсистемы.ФайловыеФункции\ПриПолученииХранимыхФайлов"].Добавить(
			"ПрисоединенныеФайлыСлужебный");
		
		СерверныеОбработчики["СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииНавигационнойСсылкиФайла"].Добавить(
			"ПрисоединенныеФайлыСлужебный");
		
		СерверныеОбработчики["СтандартныеПодсистемы.ФайловыеФункции\ПриОпределенииИмениФайлаСПутемКДвоичнымДанным"].Добавить(
			"ПрисоединенныеФайлыСлужебный");
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.РаботаВМоделиСервиса.ФайловыеФункцииВМоделиСервиса") Тогда
		
		СерверныеОбработчики["ТехнологияСервиса.РаботаВМоделиСервиса.ФайловыеФункцииВМоделиСервиса\ПриЗаполненииОбработчиковИнтеграцииФайловыхФункцийВМоделиСервиса"].Добавить(
			"ПрисоединенныеФайлыСлужебный");
		
	КонецЕсли;
	
КонецПроцедуры

// Размещает файлы из сформированного образа.
Процедура ДобавитьФайлыВТомаПриРазмещении(Знач СоответствиеПутейФайлов,
                                          Знач ТипХраненияФайлов,
                                          Знач Файлы)
	
	Для Каждого ЭлементСоответствия Из СоответствиеПутейФайлов Цикл
		
		Позиция = СтрНайти(ЭлементСоответствия.Ключ, "CatalogRef");
		
		Если Позиция = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ПолныйПутьФайлаНаДиске = СоответствиеПутейФайлов.Получить(ЭлементСоответствия.Ключ);
		
		Если ПолныйПутьФайлаНаДиске = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		УникальныйИдентификатор = Новый УникальныйИдентификатор(Лев(ЭлементСоответствия.Ключ, Позиция - 1));
		
		ИмяСправочника = Прав(ЭлементСоответствия.Ключ, СтрДлина(ЭлементСоответствия.Ключ) - Позиция -10);
		Ссылка = Справочники[ИмяСправочника].ПолучитьСсылку(УникальныйИдентификатор);
		
		Если Ссылка.Пустая() Тогда
			Продолжить;
		КонецЕсли;
		
		Объект = Ссылка.ПолучитьОбъект();
		
		Если Объект.ТипХраненияФайла <> Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
			Продолжить;
		КонецЕсли;
		
		Если Файлы.Найти(ТипЗнч(Объект)) = Неопределено Тогда
			Файлы.Добавить(ТипЗнч(Объект));
		КонецЕсли;
		
		// Размещение файлов в базе-приемнике внутри базы, независимо от хранения в базе-источнике.
		Если ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			
			Объект.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
			Объект.ПутьКФайлу = "";
			Объект.Том = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
			
			ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПутьФайлаНаДиске);
			ОбновитьДвоичныеДанныеФайлаНаСервере(Объект, ПоместитьВоВременноеХранилище(ДвоичныеДанные));
			
		Иначе // Размещение файлов в базе-приемнике внутри тома, независимо от хранения в базе-источнике.
			ФайлИсходный = Новый Файл(ПолныйПутьФайлаНаДиске);
			ПолныйПутьНовый = ФайлИсходный.Путь + Объект.Наименование + "." + Объект.Расширение;
			ПереместитьФайл(ПолныйПутьФайлаНаДиске, ПолныйПутьНовый);
			
			// Добавление файла в один из томов (где есть свободное место).
			СведенияОФайле = ФайловыеФункцииСлужебный.ДобавитьФайлВТом(ПолныйПутьНовый, Объект.ДатаМодификацииУниверсальная,
				Объект.Наименование, Объект.Расширение,, Объект.Зашифрован);
			Объект.Том = СведенияОФайле.Том;
			Объект.ПутьКФайлу = СведенияОФайле.ПутьКФайлу;
			Объект.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске;
			
		КонецЕсли;
		
		Объект.Записать();
		
		Если НЕ ПустаяСтрока(ПолныйПутьНовый) Тогда
			УдалитьФайлы(ПолныйПутьНовый);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет регистрацию в плане обмена при обмене файлами.
//
// Параметры:
//  ПланОбменаСсылка - Ссылка на план обмена.
//  ТипыФайлов       - Массив Типов справочников с присоединенными файлами.
//
Процедура УдалитьРегистрациюИзменений(ПланОбменаСсылка, ТипыФайлов)
	
	Для Каждого Тип Из ТипыФайлов Цикл
		ПланыОбмена.УдалитьРегистрациюИзменений(ПланОбменаСсылка, Метаданные.НайтиПоТипу(Тип));
	КонецЦикла;
	
КонецПроцедуры

// Проверяет, что переданный элемент данных - это объект присоединенного файла.
Функция ЭтоЭлементПрисоединенныеФайлы(ЭлементДанных)
	
	Если ТипЗнч(ЭлементДанных) = Тип("УдалениеОбъекта") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	МетаданныеЭлемента = ЭлементДанных.Метаданные();
	
	Возврат ОбщегоНазначения.ЭтоСправочник(МетаданныеЭлемента)
	      И ВРег(Прав(МетаданныеЭлемента.Имя, СтрДлина("ПрисоединенныеФайлы"))) = ВРег("ПрисоединенныеФайлы");
	
КонецФункции

// Возвращает количество версий с неизвлеченным текстом.
Функция ПолучитьКоличествоВерсийСНеизвлеченнымТекстом()
	
	КоличествоФайлов = 0;
	
	ТипыВладельцев = Метаданные.РегистрыСведений.НаличиеПрисоединенныхФайлов.Измерения.ОбъектСФайлами.Тип.Типы();
	ВсеИменаСправочников = Новый Соответствие;
	
	Для Каждого Тип Из ТипыВладельцев Цикл
		
		Если Тип = Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных") Тогда
			Продолжить;
		КонецЕсли;
		
		ИменаСправочников = ИменаСправочниковХраненияФайлов(Тип);
		
		Для каждого КлючИЗначение Из ИменаСправочников Цикл
			Если ВсеИменаСправочников[КлючИЗначение.Ключ] <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ИмяСправочникаПрисоединенныхФайлов = КлючИЗначение.Ключ;
			ВсеИменаСправочников.Вставить(КлючИЗначение.Ключ, Истина);
			
			Запрос = Новый Запрос;
			Запрос.Текст = ТекстЗапросаДляЧислаФайловСНеизвлеченнымТекстом(ИмяСправочникаПрисоединенныхФайлов);
			
			Выборка = Запрос.Выполнить().Выбрать();
			Если Выборка.Следующий() Тогда
				КоличествоФайлов = КоличествоФайлов + Выборка.КоличествоФайлов;
			КонецЕсли
		КонецЦикла;
	КонецЦикла;
	
	Возврат КоличествоФайлов;
	
КонецФункции

// Возвращает путь к файлу на диске. Если файл хранится в информационной базе,
// предварительно сохраняет его.
//
// Параметры:
//  ПрисоединенныйФайл - Ссылка на присоединенный файл.
//
// Возвращаемое значение:
//  Строка - полный путь к файлу на диске.
//
Функция ПолучитьИмяФайлаСПутемКДвоичнымДанным(Знач ПрисоединенныйФайл, ПустойПутьДляПустыхДанных = Ложь)
	
	ИмяФайлаСПутем = ПолучитьИмяВременногоФайла(ПрисоединенныйФайл.Расширение);
	
	Если ПрисоединенныйФайл.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	ПрисоединенныеФайлы.ПрисоединенныйФайл,
		|	ПрисоединенныеФайлы.ХранимыйФайл
		|ИЗ
		|	РегистрСведений.ПрисоединенныеФайлы КАК ПрисоединенныеФайлы
		|ГДЕ
		|	ПрисоединенныеФайлы.ПрисоединенныйФайл = &ПрисоединенныйФайл";
		
		Запрос.УстановитьПараметр("ПрисоединенныйФайл", ПрисоединенныйФайл.Ссылка);
		Выборка = Запрос.Выполнить().Выбрать();
		
		Если Выборка.Следующий() Тогда
			ДвоичныеДанные = Выборка.ХранимыйФайл.Получить();
			
			Если ПустойПутьДляПустыхДанных И ТипЗнч(ДвоичныеДанные) <> Тип("ДвоичныеДанные") Тогда
				Возврат "";
			КонецЕсли;
			
			ДвоичныеДанные.Записать(ИмяФайлаСПутем);
			
		ИначеЕсли ПустойПутьДляПустыхДанных Тогда
			Возврат "";
		Иначе
			ВызватьИсключение ФайловыеФункцииСлужебныйКлиентСервер.ОшибкаФайлНеНайденВХранилищеФайлов(
				ПрисоединенныйФайл.Наименование + "." + ПрисоединенныйФайл.Расширение);
		КонецЕсли;
	Иначе
		Если НЕ ПрисоединенныйФайл.Том.Пустая() Тогда
			ИмяФайлаСПутем = ФайловыеФункцииСлужебный.ПолныйПутьТома(ПрисоединенныйФайл.Том) + ПрисоединенныйФайл.ПутьКФайлу;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ИмяФайлаСПутем;
	
КонецФункции

// Заполняет параметр КоличествоФайловВТомах.
Процедура ОпределитьКоличествоФайловВТомах(КоличествоФайловВТомах)
	
	ТипыВладельцев = Метаданные.РегистрыСведений.НаличиеПрисоединенныхФайлов.Измерения.ОбъектСФайлами.Тип.Типы();
	ВсеИменаСправочников = Новый Соответствие;
	
	Запрос = Новый Запрос;
	
	Для Каждого Тип Из ТипыВладельцев Цикл
		
		Если Тип = Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных") Тогда
			Продолжить;
		КонецЕсли;
		
		ИменаСправочников = ИменаСправочниковХраненияФайлов(Тип);
		
		Для каждого КлючИЗначение Из ИменаСправочников Цикл
			Если ВсеИменаСправочников[КлючИЗначение.Ключ] <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ИмяСправочникаПрисоединенныхФайлов = КлючИЗначение.Ключ;
			ВсеИменаСправочников.Вставить(КлючИЗначение.Ключ, Истина);
		
			Запрос.Текст =
			"ВЫБРАТЬ
			|	ЕСТЬNULL(КОЛИЧЕСТВО(ПрисоединенныеФайлы.Ссылка), 0) КАК КоличествоФайлов
			|ИЗ
			|	&ИмяСправочника КАК ПрисоединенныеФайлы
			|ГДЕ
			|	ПрисоединенныеФайлы.ТипХраненияФайла = ЗНАЧЕНИЕ(Перечисление.ТипыХраненияФайлов.ВТомахНаДиске)";
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИмяСправочника",
				"Справочник." + ИмяСправочникаПрисоединенныхФайлов);
			
			Выборка = Запрос.Выполнить().Выбрать();
			Если Выборка.Следующий() Тогда
				КоличествоФайловВТомах = КоличествоФайловВТомах + Выборка.КоличествоФайлов;
			КонецЕсли
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Возвращает размер файлов на томе (в байтах).
Функция ПодсчитатьРазмерФайловНаТоме(СсылкаТома) Экспорт
	
	ТипыВладельцев = Метаданные.РегистрыСведений.НаличиеПрисоединенныхФайлов.Измерения.ОбъектСФайлами.Тип.Типы();
	ВсеИменаСправочников = Новый Соответствие;
	
	Запрос = Новый Запрос;
	Запрос.Параметры.Вставить("Том", СсылкаТома);
	
	РазмерФайловВТоме = 0;
	
	Для Каждого Тип Из ТипыВладельцев Цикл
		
		Если Тип = Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных") Тогда
			Продолжить;
		КонецЕсли;
		
		ИменаСправочников = ИменаСправочниковХраненияФайлов(Тип);
		
		Для каждого КлючИЗначение Из ИменаСправочников Цикл
			Если ВсеИменаСправочников[КлючИЗначение.Ключ] <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ИмяСправочникаПрисоединенныхФайлов = КлючИЗначение.Ключ;
			ВсеИменаСправочников.Вставить(КлючИЗначение.Ключ, Истина);
		
			Запрос.Текст =
			"ВЫБРАТЬ
			|	ЕСТЬNULL(СУММА(ПрисоединенныеФайлы.Размер), 0) КАК РазмерФайлов
			|ИЗ
			|	&ИмяСправочника КАК ПрисоединенныеФайлы
			|ГДЕ
			|	ПрисоединенныеФайлы.Том = &Том";
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИмяСправочника",
				"Справочник." + ИмяСправочникаПрисоединенныхФайлов);
			
			Выборка = Запрос.Выполнить().Выбрать();
			Если Выборка.Следующий() Тогда
				РазмерФайловВТоме = РазмерФайловВТоме + Выборка.РазмерФайлов;
			КонецЕсли
		КонецЦикла;
	КонецЦикла;
	
	Возврат РазмерФайловВТоме;
	
КонецФункции

// Возвращает Истина в параметре ЕстьХранимыеФайлы, если есть хранимые файлы к объекту ВнешнийОбъект.
// Определяет есть ли хранимые файлы у внешнего объекта.
// 
// Параметры:
//  ВнешнийОбъект     - Ссылка на внешний объект.
//  ЕстьХранимыеФайлы - Булево (возвращаемое значение), варианты значений параметра:
//                        Истина - возврат,
//                        Ложь   - устанавливает Истина, если объект имеет хранимые файлы.
//
Процедура ОпределитьНаличиеХранимыхФайлов(Знач ВнешнийОбъект, ЕстьХранимыеФайлы)
	
	Если ЕстьХранимыеФайлы = Истина Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ВнешнийОбъект) = Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных") Тогда
		Возврат;
	КонецЕсли;
	
	ТипыВладельцев = Метаданные.РегистрыСведений.НаличиеПрисоединенныхФайлов.Измерения.ОбъектСФайлами.Тип.Типы();
	Если ТипыВладельцев.Найти(ТипЗнч(ВнешнийОбъект)) <> Неопределено Тогда
		ЕстьХранимыеФайлы = ОбъектИмеетФайлы(ВнешнийОбъект);
	КонецЕсли;
	
КонецПроцедуры

// Заполняет массив ХранимыеФайлы данными хранимых файлов объекта ВнешнийОбъект.
Процедура ПолучитьХранимыеФайлы(Знач ВнешнийОбъект, Знач ХранимыеФайлы)
	
	Если ТипЗнч(ВнешнийОбъект) = Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных") Тогда
		Возврат;
	КонецЕсли;
	
	ТипыВладельцев = Метаданные.РегистрыСведений.НаличиеПрисоединенныхФайлов.Измерения.ОбъектСФайлами.Тип.Типы();
	Если ТипыВладельцев.Найти(ТипЗнч(ВнешнийОбъект)) = Неопределено Тогда
		Возврат;
	КонецЕсли;
		
	МассивФайлов = ПолучитьВсеПодчиненныеФайлы(ВнешнийОбъект);
	Для Каждого Файл Из МассивФайлов Цикл
		
		ДанныеФайла = Новый Структура;
		ДанныеФайла.Вставить("ДатаМодификацииУниверсальная", Файл.ДатаМодификацииУниверсальная);
		ДанныеФайла.Вставить("Размер",                       Файл.Размер);
		ДанныеФайла.Вставить("Наименование",                 Файл.Наименование);
		ДанныеФайла.Вставить("Расширение",                   Файл.Расширение);
		
		ДанныеФайла.Вставить("ДвоичныеДанныеФайла",          ПрисоединенныеФайлы.ПолучитьДанныеФайла(
			Файл, Неопределено).СсылкаНаДвоичныеДанныеФайла);
		
		ДанныеФайла.Вставить("Текст",                        Файл.ТекстХранилище.Получить());
		
		ХранимыеФайлы.Добавить(ДанныеФайла);
	КонецЦикла;
		
КонецПроцедуры

// Добавляет процедуры-обработчики обновления, необходимые данной подсистеме.
//
// Параметры:
//  Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
//                                  общего модуля ОбновлениеИнформационнойБазы.
// 
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.2.1.5";
	Обработчик.Процедура = "ПрисоединенныеФайлыСлужебный.ОчиститьНекорректныеЗаписиРегистраСведенийНаличиеПрисоединенныхФайлов";
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры используемые при обмене данными и выгрузке / загрузке данных.

// Возвращает массив справочников, выступающих в роли владельцев файлов.
//
// Возвращаемое значение: Массив(ОбъектМетаданных).
//
Функция СправочникиФайлов() Экспорт
	
	Результат = Новый Массив();
	
	КоллекцииМетаданных = Новый Массив();
	КоллекцииМетаданных.Добавить(Метаданные.Справочники);
	КоллекцииМетаданных.Добавить(Метаданные.Документы);
	КоллекцииМетаданных.Добавить(Метаданные.БизнесПроцессы);
	КоллекцииМетаданных.Добавить(Метаданные.Задачи);
	КоллекцииМетаданных.Добавить(Метаданные.ПланыСчетов);
	КоллекцииМетаданных.Добавить(Метаданные.ПланыОбмена);
	КоллекцииМетаданных.Добавить(Метаданные.ПланыВидовХарактеристик);
	КоллекцииМетаданных.Добавить(Метаданные.ПланыВидовРасчета);
	
	Для Каждого КоллекцияМетаданных Из КоллекцииМетаданных Цикл
		
		Для Каждого ОбъектМетаданных Из КоллекцияМетаданных Цикл
			
			МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ОбъектМетаданных.ПолноеИмя());
			ПустаяСсылка = МенеджерОбъекта.ПустаяСсылка();
			ИменаСправочниковХраненияФайлов = ИменаСправочниковХраненияФайлов(ПустаяСсылка, Истина);
			
			Для Каждого ИмяСправочникаХраненияФайлов Из ИменаСправочниковХраненияФайлов Цикл
				
				Результат.Добавить(Метаданные.Справочники[ИмяСправочникаХраненияФайлов.Ключ]);
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает массив объектов метаданных, которые используются для хранения
// двоичных данных файлов в информационной базе.
//
// Возвращаемое значение: Массив(ОбъектМетаданных).
//
Функция ОбъектыХраненияФайловИнформационнойБазе() Экспорт
	
	Результат = Новый Массив();
	Результат.Добавить(Метаданные.РегистрыСведений.ПрисоединенныеФайлы);
	Возврат Результат;
	
КонецФункции

// Возвращает расширение файла.
//
// Объект - СправочникОбъект.
//
Функция РасширениеФайла(Объект) Экспорт
	
	Возврат Объект.Расширение;
	
КонецФункции

// Для служебного использования.
Процедура ПриОтправкеФайла(ЭлементДанных,
                           ОтправкаЭлемента,
                           Знач СозданиеНачальногоОбраза = Ложь,
                           Получатель = Неопределено)
	
	// Для обменов не РИБ используется алгоритм обычного сеанса обмена, а не создания начального образа,
	// т.к. параметра СозданиеНачальногоОбраза равный Истина означает начальную выгрузку данных.
	Если СозданиеНачальногоОбраза И Получатель <> Неопределено 
		И Не ОбщегоНазначения.ЭтоУзелРаспределеннойИнформационнойБазы(Получатель.Ссылка) Тогда
		СозданиеНачальногоОбраза = Ложь;
	КонецЕсли;
	
	Если ОтправкаЭлемента = ОтправкаЭлементаДанных.Удалить
		ИЛИ ОтправкаЭлемента = ОтправкаЭлементаДанных.Игнорировать Тогда
		
		// Стандартную обработку не переопределяем.
		
	ИначеЕсли ЭтоЭлементПрисоединенныеФайлы(ЭлементДанных) Тогда
		
		Если СозданиеНачальногоОбраза Тогда
			
			Если ЭлементДанных.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
				
				Если Получатель <> Неопределено
					И Получатель.ДополнительныеСвойства.Свойство("РазмещатьФайлыВНачальномОбразе") Тогда
					
					// Помещаем данные файла из тома на диске в служебный реквизит справочника.
					ПоместитьФайлВРеквизитСправочника(ЭлементДанных);
					
				Иначе
					
					// Копируем файл из тома на диске в каталог создания начального образа.
					ИмяКаталогаФайлов = ХранилищеОбщихНастроек.Загрузить("ОбменФайлами", "ВременныйКаталог");
					
					ПолныйПуть = ФайловыеФункцииСлужебный.ПолныйПутьТома(ЭлементДанных.Том) + ЭлементДанных.ПутьКФайлу;
					УникальныйИдентификатор = ЭлементДанных.Ссылка.УникальныйИдентификатор();
					
					НовыйПутьФайла = ОбщегоНазначенияКлиентСервер.ПолучитьПолноеИмяФайла(
							ИмяКаталогаФайлов,
							Строка(УникальныйИдентификатор) + "CatalogRef_" + ЭлементДанных.Метаданные().Имя);
					
					ФайловыеФункцииСлужебный.СкопироватьФайлПриСозданииНачальногоОбраза(ПолныйПуть, НовыйПутьФайла);
					
				КонецЕсли;
				
			Иначе
				
				// Если файл хранится в ИБ, то при создании начального образа
				// он будет выгружен в составе регистра сведений ПрисоединенныеФайлы.
				
			КонецЕсли;
			
		Иначе
			
			Если ЭлементДанных.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
				
				// Помещаем данные файла из тома на диске в служебный реквизит справочника.
				ПоместитьФайлВРеквизитСправочника(ЭлементДанных);
				
			Иначе // Перечисления.ТипыХраненияФайлов.ВИнформационнойБаза
				
				Попытка
					// Помещаем данные файла из информационной базы в служебный реквизит справочника.
					АдресВоВременномХранилище = ПрисоединенныеФайлы.ПолучитьДанныеФайла(ЭлементДанных.Ссылка).СсылкаНаДвоичныеДанныеФайла;
					ЭлементДанных.ФайлХранилище = Новый ХранилищеЗначения(ПолучитьИзВременногоХранилища(АдресВоВременномХранилище), Новый СжатиеДанных(9));
				Исключение
					// Возможно, файл не был найден. Отправку данных не прерываем.
					ЗаписьЖурналаРегистрации(
						НСтр("ru = 'Файлы.Не удалось отправить файл при обмене данными'",
						     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
						УровеньЖурналаРегистрации.Ошибка,
						,
						,
						ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()) );
					
					ЭлементДанных.ФайлХранилище = Новый ХранилищеЗначения(Неопределено);
				КонецПопытки;
				
				ЭлементДанных.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
				ЭлементДанных.ПутьКФайлу = "";
				ЭлементДанных.Том = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
				
			КонецЕсли;
			
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.НаличиеПрисоединенныхФайлов") Тогда
		
		// В каждом узле свои идентификаторы объекта. Сброс перед отправкой.
		Для каждого Запись Из ЭлементДанных Цикл
			Запись.ИдентификаторОбъекта = "";
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.ПрисоединенныеФайлы")
		И Не СозданиеНачальногоОбраза Тогда
		
		// Выгрузку регистра выполняем только при создании начального образа.
		ОтправкаЭлемента = ОтправкаЭлементаДанных.Игнорировать;
		
	КонецЕсли;
	
КонецПроцедуры

// Только для внутреннего использования.
//
Процедура ВыгрузитьФайл(Знач ОбъектФайла, Знач ИмяНовогоФайла) Экспорт
	
	Если ОбъектФайла.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
		
		ПолныйПуть = ФайловыеФункцииСлужебный.ПолныйПутьТома(ОбъектФайла.Том) + ОбъектФайла.ПутьКФайлу;
		КопироватьФайл(ПолныйПуть, ИмяНовогоФайла);
		
	Иначе // Перечисления.ТипыХраненияФайлов.ВИнформационнойБаза
		
		АдресВоВременномХранилище = ПрисоединенныеФайлы.ПолучитьДанныеФайла(ОбъектФайла.Ссылка).СсылкаНаДвоичныеДанныеФайла;
		ПолучитьИзВременногоХранилища(АдресВоВременномХранилище).Записать(ИмяНовогоФайла);
		
	КонецЕсли;
	
КонецПроцедуры

// Для служебного использования.
Процедура ПриПолученииФайла(ЭлементДанных, ПолучениеЭлемента)
	
	Если ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать Тогда
		
		// Стандартную обработку не переопределяем.
		
	ИначеЕсли ЭтоЭлементПрисоединенныеФайлы(ЭлементДанных) Тогда
		
		Если ПолучениеФайлаЗапрещено(ЭлементДанных) Тогда
			
			ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать;
			Возврат;
		КонецЕсли;
		
		// Для существующих файлов, размещенных в томах, выполняем их удаление из томов,
		// т.к. при получении нового файла он будет заново размещен в томе или информационной базе.
		Если НЕ ЭлементДанных.ЭтоНовый() Тогда
			
			ВерсияФайла = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ЭлементДанных.Ссылка, "ТипХраненияФайла, Том, ПутьКФайлу");
			
			Если ВерсияФайла.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
				
				ПрежнийПутьНаТоме = ФайловыеФункцииСлужебный.ПолныйПутьТома(ВерсияФайла.Том) + ВерсияФайла.ПутьКФайлу;
				
				ФайловыеФункцииСлужебный.УдалитьФайлыНаСервере(ПрежнийПутьНаТоме);
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если ФайловыеФункцииСлужебный.ТипХраненияФайлов() = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
			
			// По обмену пришел элемент с хранением в базе - но в базе приемнике принято хранить в томах.
			// Из служебного реквизита файл размещаем на томе и меняем ТипХраненияФайла на ВТомахНаДиске.
			СведенияОФайле = ФайловыеФункцииСлужебный.ДобавитьФайлВТом(ЭлементДанных.ФайлХранилище.Получить(), 
				ЭлементДанных.ДатаМодификацииУниверсальная, ЭлементДанных.Наименование, ЭлементДанных.Расширение,, 
				ЭлементДанных.Зашифрован);
			ЭлементДанных.ПутьКФайлу = СведенияОФайле.ПутьКФайлу;
			ЭлементДанных.Том        = СведенияОФайле.Том;
			
			ЭлементДанных.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске;
			ЭлементДанных.ФайлХранилище = Новый ХранилищеЗначения(Неопределено);
			
		Иначе
			
			ДвоичныеДанные = ЭлементДанных.ФайлХранилище.Получить();
			
			Если ТипЗнч(ДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
				ЭлементДанных.ДополнительныеСвойства.Вставить("ДвоичныеДанныеФайла", ДвоичныеДанные);
			КонецЕсли;
			
			ЭлементДанных.ФайлХранилище = Новый ХранилищеЗначения(Неопределено);
			ЭлементДанных.Том = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
			ЭлементДанных.ПутьКФайлу = "";
			ЭлементДанных.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
			
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(ЭлементДанных) = Тип("РегистрСведенийНаборЗаписей.НаличиеПрисоединенныхФайлов") Тогда
		
		Набор = РегистрыСведений.НаличиеПрисоединенныхФайлов.СоздатьНаборЗаписей();
		Если ЭлементДанных.Отбор.ОбъектСФайлами.Использование Тогда
			Набор.Отбор.ОбъектСФайлами.Установить(ЭлементДанных.Отбор.ОбъектСФайлами.Значение);
		КонецЕсли;
		Набор.Прочитать();
		
		СтарыеДанные = Набор.Выгрузить();
		СтарыеДанные.Индексы.Добавить("ОбъектСФайлами");
		
		// В каждом узле свои идентификаторы объекта. Восстановление перед загрузкой.
		Для каждого Запись Из ЭлементДанных Цикл
			Строка = СтарыеДанные.Найти(Запись.ОбъектСФайлами, "ОбъектСФайлами");
			Если Строка <> Неопределено Тогда
				Запись.ИдентификаторОбъекта = Строка.ИдентификаторОбъекта;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Только для внутреннего использования.
//
Процедура ЗагрузитьФайл(Знач ОбъектФайла, Знач ПутьКФайлу) Экспорт
	
	ДвоичныеДанные = Новый ДвоичныеДанные(ПутьКФайлу);
	
	Если ФайловыеФункцииСлужебный.ТипХраненияФайлов() = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
		
		// Добавление файла в один из томов (где есть свободное место).
		СведенияОФайле = ФайловыеФункцииСлужебный.ДобавитьФайлВТом(ДвоичныеДанные, ОбъектФайла.ДатаМодификацииУниверсальная,
			ОбъектФайла.Наименование, ОбъектФайла.Расширение, ОбъектФайла.НомерВерсии, ОбъектФайла.Зашифрован);
		ОбъектФайла.ПутьКФайлу = СведенияОФайле.ПутьКФайлу;
		ОбъектФайла.Том        = СведенияОФайле.Том;
		ОбъектФайла.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске;
		ОбъектФайла.ФайлХранилище = Новый ХранилищеЗначения(Неопределено);
		
	Иначе
		
		ОбъектФайла.ДополнительныеСвойства.Вставить("ДвоичныеДанныеФайла", ДвоичныеДанные);
		ОбъектФайла.ФайлХранилище = Новый ХранилищеЗначения(Неопределено);
		ОбъектФайла.Том = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
		ОбъектФайла.ПутьКФайлу = "";
		ОбъектФайла.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
		
	КонецЕсли;
	
КонецПроцедуры

// Отменяет редактирование файла.
//
// Параметры:
//  ПрисоединенныйФайл - Ссылка или Объект присоединенного файла, который требуется освободить.
//
Процедура ОсвободитьФайл(Знач ПрисоединенныйФайл) Экспорт
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(ПрисоединенныйФайл)) Тогда
		ФайлОбъект = ПрисоединенныйФайл.ПолучитьОбъект();
		ФайлОбъект.Заблокировать();
	Иначе
		ФайлОбъект = ПрисоединенныйФайл;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ФайлОбъект.Редактирует) Тогда
		ФайлОбъект.Редактирует = Справочники.Пользователи.ПустаяСсылка();
		ФайлОбъект.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Отмечает файл, как редактируемый.
//
// Параметры:
//  ПрисоединенныйФайл - Ссылка или Объект присоединенного файла, который требуется отметить.
//
Процедура ЗанятьФайлДляРедактированияСервер(Знач ПрисоединенныйФайл, Пользователь = Неопределено) Экспорт
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(ПрисоединенныйФайл)) Тогда
		ФайлОбъект = ПрисоединенныйФайл.ПолучитьОбъект();
		ФайлОбъект.Заблокировать();
	Иначе
		ФайлОбъект = ПрисоединенныйФайл;
	КонецЕсли;
	
	Если Пользователь = Неопределено Тогда
		ФайлОбъект.Редактирует = Пользователи.АвторизованныйПользователь();
	Иначе
		ФайлОбъект.Редактирует = Пользователь;
	КонецЕсли;
	ФайлОбъект.Записать();
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Очистка ненужных файлов

Функция ТекстЗапросаДляОчисткиФайлов(ВладелецФайла, Настройка, МассивИсключений, ЭлементИсключение, ДанныеДляОтчета = Ложь) Экспорт
	
	Если Настройка.ПериодОчистки <> Перечисления.ПериодОчисткиФайлов.ПоПравилу Тогда
		Если ДанныеДляОтчета Тогда
			ТекстЗапроса = 
				"ВЫБРАТЬ
				|	ТИПЗНАЧЕНИЯ(СправочникПрисоединенныеФайлы.ВладелецФайла) КАК ВладелецФайла,
				|	СправочникПрисоединенныеФайлы.Размер /1024 /1024 КАК ОбъемНенужныхФайлов";
		Иначе
			ТекстЗапроса = 
				"ВЫБРАТЬ
				|	СправочникПрисоединенныеФайлы.Ссылка КАК ФайлСсылка";
		КонецЕсли;
		ТекстЗапроса = ТекстЗапроса + "
			|ИЗ
			|	Справочник." + Настройка.ТипВладельцаФайла.Имя + " КАК СправочникПрисоединенныеФайлы
			|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ " + ВладелецФайла.ПолноеИмя + " КАК СправочникФайлы
			|		ПО СправочникПрисоединенныеФайлы.ВладелецФайла = СправочникФайлы.Ссылка
			|ГДЕ
			|	НЕ СправочникПрисоединенныеФайлы.ПометкаУдаления
			|	И ВЫБОР
			|			КОГДА СправочникПрисоединенныеФайлы.ТипХраненияФайла = ЗНАЧЕНИЕ(Перечисление.ТипыХраненияФайлов.ВТомахНаДиске)
			|				ТОГДА (ВЫРАЗИТЬ(СправочникПрисоединенныеФайлы.ПутьКФайлу КАК СТРОКА(100))) <> """"
			|						ИЛИ НЕ СправочникПрисоединенныеФайлы.Том = ЗНАЧЕНИЕ(Справочник.ТомаХраненияФайлов.ПустаяСсылка)
			|			ИНАЧЕ ИСТИНА
			|		КОНЕЦ
			|	И ТИПЗНАЧЕНИЯ(СправочникПрисоединенныеФайлы.ВладелецФайла) = &ТипВладельца
			|	И СправочникПрисоединенныеФайлы.ДатаСоздания <= &ПериодОчистки";
	Иначе
		МассивРеквизитовСТипомДата = Новый Массив;
		
		ТипОбъекта = ВладелецФайла;
		ВсеСправочники = Справочники.ТипВсеСсылки();
		ВсеДокументы = Документы.ТипВсеСсылки();
		ЕстьТипДата = Ложь;
		ТекстЗапроса = 
			"ВЫБРАТЬ
			|	СправочникФайлы.Ссылка,
			|	ТИПЗНАЧЕНИЯ(СправочникПрисоединенныеФайлы.ВладелецФайла) КАК ВладелецФайла,
			|	СправочникПрисоединенныеФайлы.Размер /1024 /1024 КАК ОбъемНенужныхФайлов,";
		Если ВсеСправочники.СодержитТип(ТипЗнч(ТипОбъекта.ЗначениеПустойСсылки)) Тогда
			Справочник = Метаданные.Справочники[ТипОбъекта.Имя];
			Для Каждого Реквизит Из Справочник.Реквизиты Цикл
				ТекстЗапроса = ТекстЗапроса + Символы.ПС + "СправочникФайлы." + Реквизит.Имя + ",";
			КонецЦикла;
		ИначеЕсли ВсеДокументы.СодержитТип(ТипЗнч(ТипОбъекта.ЗначениеПустойСсылки)) Тогда
			Документ = Метаданные.Документы[ТипОбъекта.Имя];
			Для Каждого Реквизит Из Документ.Реквизиты Цикл
				Если Реквизит.Тип = Новый ОписаниеТипов("Дата") Тогда
					ТекстЗапроса = ТекстЗапроса + Символы.ПС + "РАЗНОСТЬДАТ(" + Реквизит.Имя + ", &ТекущаяДата, ДЕНЬ) Как ДнейДоУдаленияОт" + Реквизит.Имя + ",";
				КонецЕсли;
				ТекстЗапроса = ТекстЗапроса + Символы.ПС + "СправочникФайлы." + Реквизит.Имя + ",";
			КонецЦикла;
		КонецЕсли;
		ТекстЗапроса = ТекстЗапроса + "
			|	СправочникПрисоединенныеФайлы.Ссылка КАК ФайлСсылка
			|ИЗ
			|	Справочник." + Настройка.ТипВладельцаФайла.Имя + " КАК СправочникПрисоединенныеФайлы
			|		ЛЕВОЕ СОЕДИНЕНИЕ " + ВладелецФайла.ПолноеИмя + " КАК СправочникФайлы
			|		ПО СправочникПрисоединенныеФайлы.ВладелецФайла = СправочникФайлы.Ссылка
			|ГДЕ
			|	НЕ СправочникПрисоединенныеФайлы.ПометкаУдаления
			|	И ВЫБОР
			|			КОГДА СправочникПрисоединенныеФайлы.ТипХраненияФайла = ЗНАЧЕНИЕ(Перечисление.ТипыХраненияФайлов.ВТомахНаДиске)
			|				ТОГДА (ВЫРАЗИТЬ(СправочникПрисоединенныеФайлы.ПутьКФайлу КАК СТРОКА(100))) <> """"
			|						ИЛИ НЕ СправочникПрисоединенныеФайлы.Том = ЗНАЧЕНИЕ(Справочник.ТомаХраненияФайлов.ПустаяСсылка)
			|			ИНАЧЕ ИСТИНА
			|		КОНЕЦ
			|	И ТИПЗНАЧЕНИЯ(СправочникПрисоединенныеФайлы.ВладелецФайла) = &ТипВладельца";
	КонецЕсли;
	Если МассивИсключений.Количество() > 0 Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|	И НЕ СправочникПрисоединенныеФайлы.ВладелецФайла В ИЕРАРХИИ (&МассивИсключений)";
	КонецЕсли;
	Если ЭлементИсключение <> Неопределено Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|	И СправочникПрисоединенныеФайлы.ВладелецФайла В ИЕРАРХИИ (&ЭлементИсключение)";
	КонецЕсли;
	
	Возврат ТекстЗапроса;
	
КонецФункции

Процедура СформироватьТекстЗапросаПолногоОбъемаФайлов(ТекстЗапроса, ДобавитьПсевдонимПоля) Экспорт
	
	МетаданныеСправочники = Метаданные.Справочники;
	
	Для Каждого Справочник Из МетаданныеСправочники Цикл
		Если Справочник.Реквизиты.Найти("ВладелецФайла") <> Неопределено Тогда
			
			Если Не СтрЗаканчиваетсяНа(Справочник.Имя, "ПрисоединенныеФайлы") Тогда
				Продолжить;
			КонецЕсли;
			
			ТипыВладельцевФайлов = Справочник.Реквизиты.ВладелецФайла.Тип.Типы();
			
			Для Каждого ТипВладельца Из ТипыВладельцевФайлов Цикл
				
				ТекстЗапроса = ТекстЗапроса + ?(ПустаяСтрока(ТекстЗапроса),"", " ОБЪЕДИНИТЬ ВСЕ") + "
					|
					|ВЫБРАТЬ
					|	ТИПЗНАЧЕНИЯ(СправочникПрисоединенныеФайлы.ВладелецФайла) " + ?(ДобавитьПсевдонимПоля, "КАК ВладелецФайла,",",") + "
					|	СправочникПрисоединенныеФайлы.Размер / 1024 / 1024 " + ?(ДобавитьПсевдонимПоля, "КАК ОбъемВсего","") + "
					|ИЗ
					|	Справочник." + Справочник.Имя + " КАК СправочникПрисоединенныеФайлы
					|ГДЕ
					|	НЕ СправочникПрисоединенныеФайлы.ПометкаУдаления";
				
				Если ДобавитьПсевдонимПоля Тогда
					ДобавитьПсевдонимПоля = Ложь;
				КонецЕсли;
				
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ПроверитьЦелостностьФайлов(ТаблицаФайловНаДиске, Том) Экспорт
	
	МетаданныеСправочники = Метаданные.Справочники;
	Запрос = Новый Запрос;
	
	ДобавитьПсевдонимПоля = Истина;
	
	Для Каждого Справочник Из МетаданныеСправочники Цикл
		Если Справочник.Реквизиты.Найти("ВладелецФайла") <> Неопределено Тогда
			ТипыВладельцевФайлов = Справочник.Реквизиты.ВладелецФайла.Тип.Типы();
			
			Если Не СтрЗаканчиваетсяНа(Справочник.Имя, "ПрисоединенныеФайлы") Тогда
				Продолжить;
			КонецЕсли;
			
			Для Каждого ТипВладельца Из ТипыВладельцевФайлов Цикл
				
				Запрос.Текст = Запрос.Текст + ?(ПустаяСтрока(Запрос.Текст),"", " ОБЪЕДИНИТЬ ВСЕ") + "
					|
					|ВЫБРАТЬ
					|	СправочникПрисоединенныеФайлы.Ссылка " + ?(ДобавитьПсевдонимПоля, "КАК Ссылка,",",") + "
					|	СправочникПрисоединенныеФайлы.Расширение " + ?(ДобавитьПсевдонимПоля, "КАК Расширение,",",") + "
					|	СправочникПрисоединенныеФайлы.Наименование " + ?(ДобавитьПсевдонимПоля, "КАК Наименование,",",") + "
					|	СправочникПрисоединенныеФайлы.Том " + ?(ДобавитьПсевдонимПоля, "КАК Том,",",") + "
					|	СправочникПрисоединенныеФайлы.Изменил " + ?(ДобавитьПсевдонимПоля, "КАК Отредактировал,",",") + "
					|	СправочникПрисоединенныеФайлы.ДатаМодификацииУниверсальная " + ?(ДобавитьПсевдонимПоля, "КАК ДатаМодификацииФайла,",",") + "
					|	СправочникПрисоединенныеФайлы.ПутьКФайлу " + ?(ДобавитьПсевдонимПоля, "КАК ПутьКФайлу","") + "
					|ИЗ
					|	Справочник." + Справочник.Имя + " КАК СправочникПрисоединенныеФайлы
					|ГДЕ
					|	СправочникПрисоединенныеФайлы.Том = &Том
					|	И СправочникПрисоединенныеФайлы.ТипХраненияФайла = ЗНАЧЕНИЕ(Перечисление.ТипыХраненияФайлов.ВТомахНаДиске)
					|	И НЕ СправочникПрисоединенныеФайлы.ПометкаУдаления";
				
				Если ДобавитьПсевдонимПоля Тогда
					ДобавитьПсевдонимПоля = Ложь;
				КонецЕсли;
				
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	Запрос.УстановитьПараметр("Том", Том);
	РезультатЗапроса = Запрос.Выполнить();
	
	Выборка = РезультатЗапроса.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		ВерсияСсылка = Выборка.Ссылка;
		ПутьКФайлу   = Выборка.ПутьКФайлу;
		
		Если ЗначениеЗаполнено(Выборка.ПутьКФайлу) И ЗначениеЗаполнено(Выборка.Том) Тогда
			
			// Удаляем лишнюю точку, если у файла нет расширения.
			Если ВерсияСсылка.Расширение = "" И СтрЗаканчиваетсяНа(ПутьКФайлу, ".") Тогда
				ПутьКФайлу = Лев(ПутьКФайлу, СтрДлина(ПутьКФайлу) - 1);
			КонецЕсли;
			
			ПолныйПутьФайла = ФайловыеФункцииСлужебный.ПолныйПутьТома(Выборка.Том) + ПутьКФайлу;
			
			Файл = Новый Файл(ПолныйПутьФайла);
			Если Не Файл.Существует() Тогда
				НесуществующийФайл = ТаблицаФайловНаДиске.Добавить();
				НесуществующийФайл.СтатусПроверки = НСтр("ru = 'Отсутствуют данные в томе на диске'");
				НесуществующийФайл.Файл = ВерсияСсылка;
				НесуществующийФайл.ПолноеИмя = ПолныйПутьФайла;
				НесуществующийФайл.Расширение = ВерсияСсылка.Расширение;
				НесуществующийФайл.Отредактировал = Выборка.Отредактировал;
				НесуществующийФайл.Том = Том;
				НесуществующийФайл.ДатаРедактирования = Выборка.ДатаМодификацииФайла;
				НесуществующийФайл.Имя = ВерсияСсылка.ПутьКФайлу;
				НесуществующийФайл.Количество = 1;
			Иначе
				
				СуществующийФайл = ТаблицаФайловНаДиске.НайтиСтроки(Новый Структура("ПолноеИмя",ПолныйПутьФайла));
				СуществующийФайл[0].Файл = ВерсияСсылка;
				СуществующийФайл[0].СтатусПроверки = НСтр("ru = 'Целостные данные'");
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецФункции

Процедура ВыполнитьОчисткуДанныхОФайле(ФайлСсылка) Экспорт
	
	ФайлОбъект = ФайлСсылка.ПолучитьОбъект();
	Если ЗначениеЗаполнено(ФайлОбъект.Редактирует) Тогда
		Возврат;
	КонецЕсли;
	ИмяФайлаСПутем = "";
	ИмяФайлаСПутемДляУдаления = "";
	
	НачатьТранзакцию();
		
	Попытка
		
		Если ФайлОбъект.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
			ИмяФайлаСПутем = ФайловыеФункцииСлужебный.ПолныйПутьТома(ФайлОбъект.Том) + ФайлОбъект.ПутьКФайлу;
			ИмяФайлаСПутемДляУдаления = ИмяФайлаСПутем + ".del";
			ФайлНаДиске = Новый Файл(ИмяФайлаСПутем);
			Если ФайлНаДиске.Существует() Тогда
				ФайлНаДиске.УстановитьТолькоЧтение(Ложь);
				// Переместим файл во временный
				ПереместитьФайл(ИмяФайлаСПутем, ИмяФайлаСПутемДляУдаления);
				ФайлОбъект.Том = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
				ФайлОбъект.ПутьКФайлу = "";
				ТекстОписания = НСтр("ru = 'Файл удален при очистке ненужных файлов.'")
					+ " " + Формат(ТекущаяДатаСеанса(),"ДЛФ=D") + Символы.ПС;
				ФайлОбъект.Описание = ТекстОписания + ФайлОбъект.Описание;
				ФайлОбъект.Записать();
				ФайлОбъект.УстановитьПометкуУдаления(Истина);
				// Удалим временный файл, т.к. успешно обновили данные о файле
				УдалитьФайлы(ИмяФайлаСПутемДляУдаления);
			КонецЕсли;
		Иначе
			УдалитьЗаписьИзРегистраПрисоединенныеФайлы(ФайлСсылка);
			ФайлОбъект.УстановитьПометкуУдаления(Истина);
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		
		Если Не ПустаяСтрока(ИмяФайлаСПутем) Тогда
			
			// Записать ошибку в журнал регистрации
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Очистка ненужных файлов'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,, ФайлСсылка, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			
			// Вернем файл на прежнее место в случае ошибки
			ПереместитьФайл(ИмяФайлаСПутемДляУдаления, ИмяФайлаСПутем);
			
		КонецЕсли;
		
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Синхронизация файлов с облачным сервисом

Функция ТекстЗапросаДляСинхронизацииФайлов(ВладелецФайла, НастройкаСинхронизации, МассивИсключений, ЭлементИсключение) Экспорт
	
	ТипОбъекта = ВладелецФайла;
	ПредставлениеТипаВладельца = ОбщегоНазначения.ВидОбъектаПоТипу(ТипЗнч(ТипОбъекта.ЗначениеПустойСсылки));
	ЕстьТипДата = Ложь;
	
	ТекстЗапроса = "";
	
	СправочникФайлов = ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору(НастройкаСинхронизации.ТипВладельцаФайла);
	Если ТипЗнч(ВладелецФайла) <> Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных") Тогда
		СправочникПапок = ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору(НастройкаСинхронизации.ИдентификаторВладельца);
	Иначе
		СправочникПапок = ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору(ВладелецФайла);
	КонецЕсли;
	
	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
		ТекстЗапроса= ТекстЗапроса + "
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|";
	КонецЕсли;
	ТекстЗапроса = ТекстЗапроса + "ВЫБРАТЬ
	|	СправочникПапок.Ссылка,";
	
	ФайловыеФункцииСлужебный.ДобавитьДоступныеПоляОтбора(ТекстЗапроса, ТипОбъекта);
	
	ТекстЗапроса = ТекстЗапроса + "
	|	СправочникФайлов.Ссылка КАК ФайлСсылка,
	|	СправочникФайлов.Наименование + ""."" + СправочникФайлов.Расширение КАК Наименование,
	|	СправочникФайлов.ПометкаУдаления КАК ПометкаУдаления,
	|	СправочникФайлов.ВладелецФайла КАК Родитель,
	|	ЛОЖЬ КАК ЭтоПапка,
	|	ИСТИНА КАК ЕстьВБазе,
	|	ЛОЖЬ КАК ЕстьНаСервере,
	|	НЕОПРЕДЕЛЕНО КАК Изменения,
	|	ЕСТЬNULL(СтатусыСинхронизацииФайловСОблачнымСервисом.Href, """") КАК Href,
	|	ЕСТЬNULL(СтатусыСинхронизацииФайловСОблачнымСервисом.Etag, """") КАК Etag,
	|	ЛОЖЬ КАК Обработан,
	|	ВЫРАЗИТЬ("""" КАК СТРОКА(36)) КАК UID1C,
	|	"""" КАК ToHref,
	|	"""" КАК ToEtag,
	|	"""" КАК РодительСервер,
	|	"""" КАК НаименованиеСервер,
	|	ЛОЖЬ КАК ИзмененНаСервере,
	|	НЕОПРЕДЕЛЕНО КАК Уровень,
	|	"""" КАК РодительСортировка,
	|	ЛОЖЬ КАК ЭтоФайл
	|ИЗ
	|	Справочник." + СправочникФайлов.Имя + " КАК СправочникФайлов
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.СтатусыСинхронизацииФайловСОблачнымСервисом КАК СтатусыСинхронизацииФайловСОблачнымСервисом
	|		ПО (СтатусыСинхронизацииФайловСОблачнымСервисом.Файл = СправочникФайлов.Ссылка)
	|		ЛЕВОЕ СОЕДИНЕНИЕ " + ПредставлениеТипаВладельца + "." + СправочникПапок.Имя + " КАК СправочникПапок
	|		ПО (СправочникФайлов.ВладелецФайла = СправочникПапок.Ссылка)
	|		ГДЕ
	|			ИСТИНА";
	
	Если МассивИсключений.Количество() > 0 Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|	И НЕ СправочникПапок.Ссылка В ИЕРАРХИИ (&МассивИсключений)";
	КонецЕсли;
	Если ЭлементИсключение <> Неопределено Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|	И СправочникПапок.Ссылка В ИЕРАРХИИ (&ЭлементИсключение)";
	КонецЕсли;
	
	ТекстЗапроса = ТекстЗапроса + "
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	СправочникПапок.Ссылка,";
	
	ФайловыеФункцииСлужебный.ДобавитьДоступныеПоляОтбора(ТекстЗапроса, ТипОбъекта);
	
	ТекстЗапроса = ТекстЗапроса + "
	|	СправочникПапок.Ссылка,
	|	" + ?(ПредставлениеТипаВладельца = "Документ",
		"СправочникПапок.Представление", "СправочникПапок.Наименование") + ",
	|	СправочникПапок.ПометкаУдаления,";
	Если ОбщегоНазначения.ЭтоСправочник(СправочникПапок) И СправочникПапок.Иерархический Тогда
		ТекстЗапроса = ТекстЗапроса + "
		|	ВЫБОР
		|		КОГДА СправочникПапок.Родитель = ЗНАЧЕНИЕ(Справочник." + СправочникПапок.Имя + ".ПустаяСсылка)
		|			ТОГДА НЕОПРЕДЕЛЕНО
		|		ИНАЧЕ СправочникПапок.Родитель
		|	КОНЕЦ,";
	Иначе
		ТекстЗапроса = ТекстЗапроса + "Неопределено,";
	КонецЕсли;
	ТекстЗапроса = ТекстЗапроса + "
	|	ИСТИНА,
	|	ИСТИНА,
	|	ЛОЖЬ,
	|	НЕОПРЕДЕЛЕНО,
	|	ЕСТЬNULL(СтатусыСинхронизацииФайловСОблачнымСервисом.Href, """"),
	|	"""",
	|	ЛОЖЬ,
	|	"""",
	|	"""",
	|	"""",
	|	"""",
	|	"""",
	|	ЛОЖЬ, 
	|	НЕОПРЕДЕЛЕНО,
	|	"""",
	|	ЛОЖЬ
	|ИЗ
	|	" + ПредставлениеТипаВладельца + "." + СправочникПапок.Имя + " КАК СправочникПапок
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.СтатусыСинхронизацииФайловСОблачнымСервисом КАК СтатусыСинхронизацииФайловСОблачнымСервисом
	|		ПО (СтатусыСинхронизацииФайловСОблачнымСервисом.Файл = СправочникПапок.Ссылка
	|			И СтатусыСинхронизацииФайловСОблачнымСервисом.УчетнаяЗапись = &УчетнаяЗапись)
	|		ГДЕ
	|			ИСТИНА";
	
	Если МассивИсключений.Количество() > 0 Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|	И НЕ СправочникПапок.Ссылка В ИЕРАРХИИ (&МассивИсключений)";
	КонецЕсли;
	Если ЭлементИсключение <> Неопределено Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|	И СправочникПапок.Ссылка В ИЕРАРХИИ (&ЭлементИсключение)";
	КонецЕсли;
		
	Возврат ТекстЗапроса;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Обновляет свойства файла при окончании редактирования.
//
// Параметры:
//  ПрисоединенныйФайл - Ссылка на присоединенный файл.
//  ИнформацияОФайле   - Структура со свойствами:
//                       <обязательные>
//                         АдресФайлаВоВременномХранилище - Строка - адрес новых двоичных данных файла.
//                         АдресВременногоХранилищаТекста - Строка - адрес новых двоичных данных текста,
//                                                          извлеченного из файла.
//                       <необязательные>
//                         ДатаМодификацииУниверсальная   - Дата - дата последнего изменения файла, если
//                                                          свойство не указано или не заполнено, тогда будет
//                                                          установлена текущая дата сеанса.
//                         Расширение                     - Строка - новое расширение файла.
//
Процедура ПоместитьФайлВХранилищеИОсвободить(Знач ПрисоединенныйФайл, Знач ИнформацияОФайле) Экспорт
	
	ИнформацияОФайле.Вставить("Редактирует", Справочники.Пользователи.ПустаяСсылка());
	
	ПрисоединенныеФайлы.ОбновитьПрисоединенныйФайл(ПрисоединенныйФайл, ИнформацияОФайле)
	
КонецПроцедуры

// Помещает зашифрованные данные файла в хранилище и устанавливает файлу признак Зашифрован.
//
// Параметры:
//  ПрисоединенныйФайл  - Ссылка на присоединенный файл.
//  ЗашифрованныеДанные - Структура со свойством:
//                          АдресВременногоХранилища - Строка - адрес зашифрованных двоичных данных.
//  МассивОтпечатков    - Массив Структур отпечатков по сертификатам.
// 
Процедура Зашифровать(Знач ПрисоединенныйФайл, Знач ЗашифрованныеДанные, Знач МассивОтпечатков) Экспорт
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(ПрисоединенныйФайл)) Тогда
		ПрисоединенныйФайлОбъект = ПрисоединенныйФайл.ПолучитьОбъект();
		ПрисоединенныйФайлОбъект.Заблокировать();
	Иначе
		ПрисоединенныйФайлОбъект = ПрисоединенныйФайл;
	КонецЕсли;
	
	Для Каждого ОтпечатокСтруктура Из МассивОтпечатков Цикл
		НоваяСтрока = ПрисоединенныйФайлОбъект.СертификатыШифрования.Добавить();
		НоваяСтрока.Отпечаток = ОтпечатокСтруктура.Отпечаток;
		НоваяСтрока.Представление = ОтпечатокСтруктура.Представление;
		НоваяСтрока.Сертификат = Новый ХранилищеЗначения(ОтпечатокСтруктура.Сертификат);
	КонецЦикла;
	
	РеквизитыЗначения = Новый Структура;
	РеквизитыЗначения.Вставить("Зашифрован", Истина);
	РеквизитыЗначения.Вставить("ТекстХранилище", Новый ХранилищеЗначения(""));
	ОбновитьДвоичныеДанныеФайлаНаСервере(ПрисоединенныйФайлОбъект, ЗашифрованныеДанные.АдресВременногоХранилища, РеквизитыЗначения);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(ПрисоединенныйФайл)) Тогда
		ПрисоединенныйФайлОбъект.Записать();
		ПрисоединенныйФайлОбъект.Разблокировать();
	КонецЕсли;
	
КонецПроцедуры

// Помещает расшифрованные данные файла в хранилище и снимает файлу признак Зашифрован.
// 
// Параметры:
//  ПрисоединенныйФайл  - Ссылка на присоединенный файл.
//  ЗашифрованныеДанные - Структура со свойством:
//                          АдресВременногоХранилища - Строка - адрес расшифрованных двоичных данных.
//
Процедура Расшифровать(Знач ПрисоединенныйФайл, Знач РасшифрованныеДанные) Экспорт
	
	Перем Отказ;
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(ПрисоединенныйФайл)) Тогда
		ПрисоединенныйФайлОбъект = ПрисоединенныйФайл.ПолучитьОбъект();
		ПрисоединенныйФайлОбъект.Заблокировать();
	Иначе
		ПрисоединенныйФайлОбъект = ПрисоединенныйФайл;
	КонецЕсли;
	
	ПрисоединенныйФайлОбъект.СертификатыШифрования.Очистить();
	
	РеквизитыЗначения = Новый Структура;
	РеквизитыЗначения.Вставить("Зашифрован", Ложь);
	
	ДвоичныеДанные = ПолучитьИзВременногоХранилища(РасшифрованныеДанные.АдресВременногоХранилища);
	СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен;
	ИзвлеченныйТекст = "";
	
	Если ЭтоАдресВременногоХранилища(РасшифрованныеДанные.АдресВременногоХранилищаТекста) Тогда
		ИзвлеченныйТекст = ФайловыеФункцииСлужебный.ПолучитьСтрокуИзВременногоХранилища(РасшифрованныеДанные.АдресВременногоХранилищаТекста);
		СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
		
	ИначеЕсли НЕ ФайловыеФункцииСлужебный.ИзвлекатьТекстыФайловНаСервере() Тогда
		// Тексты извлекаются сразу, а не в фоновом задании.
		СтатусИзвлеченияТекста = ИзвлечьТекст(ДвоичныеДанные, ПрисоединенныйФайл.Расширение, ИзвлеченныйТекст);
	КонецЕсли;
	
	ПрисоединенныйФайлОбъект.СтатусИзвлеченияТекста = СтатусИзвлеченияТекста;
	
	РеквизитыЗначения.Вставить("ТекстХранилище", Новый ХранилищеЗначения(ИзвлеченныйТекст, Новый СжатиеДанных(9)));
	
	ОбновитьДвоичныеДанныеФайлаНаСервере(ПрисоединенныйФайлОбъект, ДвоичныеДанные, РеквизитыЗначения);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(ПрисоединенныйФайл)) Тогда
		ПрисоединенныйФайлОбъект.Записать();
		ПрисоединенныйФайлОбъект.Разблокировать();
	КонецЕсли;
	
КонецПроцедуры

// Заменяет двоичные данные файла в ИБ на данные во временном хранилище.
Процедура ОбновитьДвоичныеДанныеФайлаНаСервере(Знач ПрисоединенныйФайл,
                                               Знач АдресФайлаВоВременномХранилищеДвоичныеДанные,
                                               Знач РеквизитыЗначения = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(ПрисоединенныйФайл)) Тогда
		ФайлОбъект = ПрисоединенныйФайл.ПолучитьОбъект();
		ФайлОбъект.Заблокировать();
		ФайлСсылка = ПрисоединенныйФайл;
	Иначе
		ФайлОбъект = ПрисоединенныйФайл;
		ФайлСсылка = ФайлОбъект.Ссылка;
	КонецЕсли;
	
	Если ТипЗнч(АдресФайлаВоВременномХранилищеДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
		ДвоичныеДанные = АдресФайлаВоВременномХранилищеДвоичныеДанные;
	Иначе
		ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресФайлаВоВременномХранилищеДвоичныеДанные);
	КонецЕсли;
	
	ФайлОбъект.Изменил = Пользователи.АвторизованныйПользователь();
	
	Если ТипЗнч(РеквизитыЗначения) = Тип("Структура") Тогда
		ЗаполнитьЗначенияСвойств(ФайлОбъект, РеквизитыЗначения);
	КонецЕсли;
	
	ТранзакцияАктивна = Ложь;
	
	Попытка
		Если ФайлОбъект.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			НачатьТранзакцию();
			ТранзакцияАктивна = Истина;
			МенеджерЗаписи = РегистрыСведений.ПрисоединенныеФайлы.СоздатьМенеджерЗаписи();
			МенеджерЗаписи.ПрисоединенныйФайл = ФайлСсылка;
			МенеджерЗаписи.Прочитать();
			МенеджерЗаписи.ПрисоединенныйФайл = ФайлСсылка;
			МенеджерЗаписи.ХранимыйФайл = Новый ХранилищеЗначения(ДвоичныеДанные, Новый СжатиеДанных(9));
			МенеджерЗаписи.Записать();
		Иначе
			ПолныйПуть = ФайловыеФункцииСлужебный.ПолныйПутьТома(ФайлОбъект.Том) + ФайлОбъект.ПутьКФайлу;
			
			Попытка
				ФайлНаДиске = Новый Файл(ПолныйПуть);
				ФайлНаДиске.УстановитьТолькоЧтение(Ложь);
				УдалитьФайлы(ПолныйПуть);
				
				СведенияОФайле = ФайловыеФункцииСлужебный.ДобавитьФайлВТом(ДвоичныеДанные, ФайлОбъект.ДатаМодификацииУниверсальная,
					ФайлОбъект.Наименование, ФайлОбъект.Расширение,, ФайлОбъект.Зашифрован);
				ФайлОбъект.ПутьКФайлу = СведенияОФайле.ПутьКФайлу;
				ФайлОбъект.Том = СведенияОФайле.Том;
			Исключение
				ИнформацияОбОшибке = ИнформацияОбОшибке();
				ЗаписьЖурналаРегистрации(
					НСтр("ru = 'Файлы.Запись файла на диск'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					УровеньЖурналаРегистрации.Ошибка,
					Метаданные.Справочники[ФайлСсылка.Метаданные().Имя],
					ФайлСсылка,
					ТекстОшибкиПриСохраненииФайлаВТоме(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке), ФайлСсылка));
				
				ВызватьИсключение ТекстОшибкиПриСохраненииФайлаВТоме(КраткоеПредставлениеОшибки(ИнформацияОбОшибке), ФайлСсылка);
			КонецПопытки;
			
		КонецЕсли;
		
		ФайлОбъект.Размер = ДвоичныеДанные.Размер();
		
		ФайлОбъект.Записать();
		
		Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(ПрисоединенныйФайл)) Тогда
			ФайлОбъект.Разблокировать();
		КонецЕсли;
		
		Если ТранзакцияАктивна Тогда
			ЗафиксироватьТранзакцию();
		КонецЕсли;
		
	Исключение
		Если ТранзакцияАктивна Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Файлы.Обновление данных присоединенного файла в хранилище файлов'",
			     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Записывает двоичные данные файла в информационную базу.
//
// Параметры:
//  ПрисоединенныйФайл - Ссылка на присоединенный файл.
//  ДвоичныеДанные     - ДвоичныеДанные, которые требуется записать.
//
Процедура ЗаписатьФайлВИнформационнуюБазу(Знач ПрисоединенныйФайл, Знач ДвоичныеДанные) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерЗаписи = РегистрыСведений.ПрисоединенныеФайлы.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.ПрисоединенныйФайл = ПрисоединенныйФайл;
	МенеджерЗаписи.ХранимыйФайл = Новый ХранилищеЗначения(ДвоичныеДанные, Новый СжатиеДанных(9));
	МенеджерЗаписи.Записать(Истина);
	
КонецПроцедуры

// Определяет, что к объекту присоединен по крайней мере один файл.
Функция ОбъектИмеетФайлы(Знач ВладелецФайлов, Знач ФайлИсключение = Неопределено)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Параметры.Вставить("ВладелецФайлов", ВладелецФайлов);
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ПрисоединенныеФайлы.Ссылка
	|ИЗ
	|	&ИмяСправочника КАК ПрисоединенныеФайлы
	|ГДЕ
	|	ПрисоединенныеФайлы.ВладелецФайла = &ВладелецФайлов";
	
	Если ФайлИсключение <> Неопределено Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|	И ПрисоединенныеФайлы.Ссылка <> &Ссылка";
		
		Запрос.Параметры.Вставить("Ссылка", ФайлИсключение);
	КонецЕсли;
	
	ИменаСправочников = ИменаСправочниковХраненияФайлов(ВладелецФайлов);
	
	Для каждого КлючИЗначение Из ИменаСправочников Цикл
		Запрос.Текст = СтрЗаменить(
			ТекстЗапроса, "&ИмяСправочника", "Справочник." + КлючИЗначение.Ключ);
		
		Если НЕ Запрос.Выполнить().Пустой() Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Возвращает массив присоединенных файлов для указанного владельца.
//
// Параметры:
//  ВладелецФайлов - Ссылка на владельца присоединенных файлов.
//
// Возвращаемое значение:
//  Массив ссылок на присоединенные файлы.
//
Функция ПолучитьВсеПодчиненныеФайлы(Знач ВладелецФайлов) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ИменаСправочников = ИменаСправочниковХраненияФайлов(ВладелецФайлов);
	ТекстЗапросов = "";
	
	Для каждого КлючИЗначение Из ИменаСправочников Цикл
		Если ЗначениеЗаполнено(ТекстЗапросов) Тогда
			ТекстЗапросов = ТекстЗапросов + "
				|ОБЪЕДИНИТЬ ВСЕ
				|
				|";
		КонецЕсли;
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ПрисоединенныеФайлы.Ссылка
		|ИЗ
		|	&ИмяСправочника КАК ПрисоединенныеФайлы
		|ГДЕ
		|	ПрисоединенныеФайлы.ВладелецФайла = &ВладелецФайлов";
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяСправочника", "Справочник." + КлючИЗначение.Ключ);
		ТекстЗапросов = ТекстЗапросов + ТекстЗапроса;
	КонецЦикла;
	
	Запрос = Новый Запрос(ТекстЗапросов);
	Запрос.УстановитьПараметр("ВладелецФайлов", ВладелецФайлов);
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции

// Обработчик подписки на событие "Перед удалением" присоединенного файла.
Процедура ПередУдалениемПрисоединенногоФайлаСервер(Знач Ссылка,
                                                   Знач ВладелецФайлов,
                                                   Знач Том,
                                                   Знач ТипХраненияФайла,
                                                   Знач ПутьКФайлу) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если НЕ ОбъектИмеетФайлы(ВладелецФайлов, Ссылка) Тогда
		МенеджерЗаписи = РегистрыСведений.НаличиеПрисоединенныхФайлов.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.ОбъектСФайлами = ВладелецФайлов;
		МенеджерЗаписи.Прочитать();
		Если МенеджерЗаписи.Выбран() Тогда
			МенеджерЗаписи.ЕстьФайлы = Ложь;
			МенеджерЗаписи.Записать();
		КонецЕсли;
	КонецЕсли;
	
	Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
		Если НЕ Том.Пустая() Тогда
			ПолныйПуть = ФайловыеФункцииСлужебный.ПолныйПутьТома(Том) + ПутьКФайлу;
			Попытка
				Файл = Новый Файл(ПолныйПуть);
				Файл.УстановитьТолькоЧтение(Ложь);
				УдалитьФайлы(ПолныйПуть);
				ПутьСПодкаталогом = Файл.Путь;
				МассивФайловВКаталоге = НайтиФайлы(ПутьСПодкаталогом, "*.*");
				Если МассивФайловВКаталоге.Количество() = 0 Тогда
					УдалитьФайлы(ПутьСПодкаталогом);
				КонецЕсли;
			Исключение
				// Если файл не удален - ошибки не было.
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Обработчик подписки "при записи" присоединенного файла.
//
Процедура ПриЗаписиПрисоединенногоФайлаСервер(ВладелецФайлов) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ЗаписьИзменилась = Ложь;
	
	МенеджерЗаписи = РегистрыСведений.НаличиеПрисоединенныхФайлов.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.ОбъектСФайлами = ВладелецФайлов;
	МенеджерЗаписи.Прочитать();
	
	Если НЕ ЗначениеЗаполнено(МенеджерЗаписи.ОбъектСФайлами) Тогда
		МенеджерЗаписи.ОбъектСФайлами = ВладелецФайлов;
		ЗаписьИзменилась = Истина;
	КонецЕсли;
	
	Если НЕ МенеджерЗаписи.ЕстьФайлы Тогда
		МенеджерЗаписи.ЕстьФайлы = Истина;
		ЗаписьИзменилась = Истина;
	КонецЕсли;
	
	Если ПустаяСтрока(МенеджерЗаписи.ИдентификаторОбъекта) Тогда
		МенеджерЗаписи.ИдентификаторОбъекта = ПолучитьОчереднойИдентификаторОбъекта();
		ЗаписьИзменилась = Истина;
	КонецЕсли;
	
	Если ЗаписьИзменилась Тогда
		МенеджерЗаписи.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Создает у Получателя копии всех присоединенных файлов Источника.
// Источник и Получатель должны быть объектами одного типа.
//
// Параметры:
//  Источник   - Ссылка - объект, имеющий присоединенные файлы для копирования.
//  Получатель - Ссылка - объект, к которому копируются присоединенные файлы.
//
Процедура СкопироватьПрисоединенныеФайлы(Знач Источник, Знач Получатель) Экспорт
	
	КопируемыеФайлы = ПолучитьВсеПодчиненныеФайлы(Источник.Ссылка);
	Для Каждого КопируемыйФайл Из КопируемыеФайлы Цикл
		Если КопируемыйФайл.ПометкаУдаления Тогда
			Продолжить;
		КонецЕсли;
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(КопируемыйФайл);
		КопияФайла = КопируемыйФайл.Скопировать();
		КопияФайлаСсылка = МенеджерОбъекта.ПолучитьСсылку();
		КопияФайла.УстановитьСсылкуНового(КопияФайлаСсылка);
		КопияФайла.ВладелецФайла = Получатель.Ссылка;
		КопияФайла.Редактирует = Справочники.Пользователи.ПустаяСсылка();
		
		КопияФайла.ТекстХранилище = Новый ХранилищеЗначения(КопируемыйФайл.ТекстХранилище.Получить());
		КопияФайла.ФайлХранилище = Новый ХранилищеЗначения(КопируемыйФайл.ФайлХранилище.Получить());
		
		КопияФайла.ЭлектронныеПодписи.Очистить();
		Для Каждого КопируемаяСтрокаТаблицы Из КопируемыйФайл.ЭлектронныеПодписи Цикл
			КопияСтрокиТаблицы = КопияФайла.ЭлектронныеПодписи.Добавить();
			ЗаполнитьЗначенияСвойств(КопияСтрокиТаблицы, КопируемаяСтрокаТаблицы);
			КопияСтрокиТаблицы.Подпись = КопируемаяСтрокаТаблицы.Подпись;
			КопияСтрокиТаблицы.Сертификат = КопируемаяСтрокаТаблицы.Сертификат;
		КонецЦикла;
		
		КопияФайла.СертификатыШифрования.Очистить();
		Для Каждого КопируемаяСтрокаТаблицы Из КопируемыйФайл.СертификатыШифрования Цикл
			КопияСтрокиТаблицы = КопияФайла.СертификатыШифрования.Добавить();
			ЗаполнитьЗначенияСвойств(КопияСтрокиТаблицы, КопируемаяСтрокаТаблицы);
			КопияСтрокиТаблицы.Сертификат = КопируемаяСтрокаТаблицы.Сертификат;
		КонецЦикла;
		
		ДвоичныеДанные = ПрисоединенныеФайлы.ПолучитьДвоичныеДанныеФайла(КопируемыйФайл);
		КопияФайла.ТипХраненияФайла = ФайловыеФункцииСлужебный.ТипХраненияФайлов();
		Если ФайловыеФункцииСлужебный.ТипХраненияФайлов() = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			ЗаписатьФайлВИнформационнуюБазу(КопияФайлаСсылка, ДвоичныеДанные);
		Иначе
			// Добавить в один из томов (где есть свободное место).
			СведенияОФайле = ФайловыеФункцииСлужебный.ДобавитьФайлВТом(ДвоичныеДанные, КопияФайла.ДатаМодификацииУниверсальная,
				КопияФайла.Наименование, КопияФайла.Расширение);
			КопияФайла.ПутьКФайлу = СведенияОФайле.ПутьКФайлу;
			КопияФайла.Том = СведенияОФайле.Том;
		КонецЕсли;
		КопияФайла.Записать();
	КонецЦикла;
	
КонецПроцедуры

// Извлекает текст из двоичных данных, возвращает статус извлечения.
Функция ИзвлечьТекст(Знач ДвоичныеДанные, Знач Расширение, ИзвлеченныйТекст) Экспорт
	
	Если ФайловыеФункцииСлужебный.ЭтоПлатформаWindows()
	   И ФайловыеФункцииСлужебный.ИзвлекатьТекстыФайловНаСервере() Тогда
		
		ИмяВременногоФайла = ПолучитьИмяВременногоФайла(Расширение);
		ДвоичныеДанные.Записать(ИмяВременногоФайла);
		
		Отказ = Ложь;
		ИзвлеченныйТекст = ФайловыеФункцииСлужебныйКлиентСервер.ИзвлечьТекстВоВременноеХранилище(ИмяВременногоФайла, , Отказ);
		
		Попытка
			УдалитьФайлы(ИмяВременногоФайла);
		Исключение
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Файлы.Извлечение текста'",
				     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,
				,
				,
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		Если Отказ Тогда
			Возврат Перечисления.СтатусыИзвлеченияТекстаФайлов.ИзвлечьНеУдалось;
		Иначе
			Возврат Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
		КонецЕсли;
	Иначе
		ИзвлеченныйТекст = "";
		Возврат Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен;
	КонецЕсли;
	
КонецФункции

// Очищает реквизит ИдентификаторОбъекта, если он содержит некорректные символы.
Процедура ОчиститьНекорректныеЗаписиРегистраСведенийНаличиеПрисоединенныхФайлов() Экспорт
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	НаличиеПрисоединенныхФайлов.ОбъектСФайлами,
	|	НаличиеПрисоединенныхФайлов.ИдентификаторОбъекта
	|ИЗ
	|	РегистрСведений.НаличиеПрисоединенныхФайлов КАК НаличиеПрисоединенныхФайлов";
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Выборка = Запрос.Выполнить().Выбрать();
	
	НаборЗаписей = РегистрыСведений.НаличиеПрисоединенныхФайлов.СоздатьНаборЗаписей();
	Пока Выборка.Следующий() Цикл
		Если ЕстьПосторонниеСимволыВИдентификаторе(Выборка.ИдентификаторОбъекта) Тогда
			НаборЗаписей.Отбор.ОбъектСФайлами.Установить(Выборка.ОбъектСФайлами);
			НаборЗаписей.Прочитать();
			Для Каждого Запись Из НаборЗаписей Цикл
				Запись.ИдентификаторОбъекта = "";
			КонецЦикла;
			ОбновлениеИнформационнойБазы.ЗаписатьДанные(НаборЗаписей);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Возвращает соответствие имен справочников и значения Булево
// для указанного владельца.
// 
// Параметры:
//  ВладелецФайлов - Ссылка - объект, к которому добавляется файл.
// 
Функция ИменаСправочниковХраненияФайлов(ВладелецФайлов, НеВызыватьИсключение = Ложь) Экспорт
	
	Если ТипЗнч(ВладелецФайлов) = Тип("Тип") Тогда
		ТипВладельцаФайлов = ВладелецФайлов;
	Иначе
		ТипВладельцаФайлов = ТипЗнч(ВладелецФайлов);
	КонецЕсли;
	
	МетаданныеВладельца = Метаданные.НайтиПоТипу(ТипВладельцаФайлов);
	
	ИменаСправочников = Новый Соответствие;
	ИмяСтандартногоОсновногоСправочника = МетаданныеВладельца.Имя + "ПрисоединенныеФайлы";
	Если Метаданные.Справочники.Найти(ИмяСтандартногоОсновногоСправочника) <> Неопределено Тогда
		ИменаСправочников.Вставить(ИмяСтандартногоОсновногоСправочника, Истина);
	КонецЕсли;
	
	// Переопределение стандартного справочника хранения присоединенных файлов.
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.ПрисоединенныеФайлы\ПриОпределенииСправочниковХраненияФайлов");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриОпределенииСправочниковХраненияФайлов(
			ТипВладельцаФайлов, ИменаСправочников);
	КонецЦикла;
	
	ПрисоединенныеФайлыПереопределяемый.ПриОпределенииСправочниковХраненияФайлов(
		ТипВладельцаФайлов, ИменаСправочников);
	
	ОсновнойСправочникУказан = Ложь;
	
	Для каждого КлючИЗначение Из ИменаСправочников Цикл
		
		Если Метаданные.Справочники.Найти(КлючИЗначение.Ключ) = Неопределено Тогда
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при определении имен справочников для хранения файлов.
				           |У владельца файлов типа ""%1""
				           |указан несуществующий справочник ""%2"".'"),
				Строка(ТипВладельцаФайлов),
				Строка(КлючИЗначение.Ключ));
				
		ИначеЕсли Не СтрЗаканчиваетсяНа(КлючИЗначение.Ключ, "ПрисоединенныеФайлы") Тогда
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Ошибка при определении имен справочников для хранения файлов.
				           |У владельца файлов типа ""%1""
				           |указано имя справочника ""%2""
				           |без окончания ""ПрисоединенныеФайлы"".'"),
				Строка(ТипВладельцаФайлов),
				Строка(КлючИЗначение.Ключ));
			
		ИначеЕсли КлючИЗначение.Значение = Неопределено Тогда
			ИменаСправочников.Вставить(КлючИЗначение.Ключ, Ложь);
			
		ИначеЕсли КлючИЗначение.Значение = Истина Тогда
			Если ОсновнойСправочникУказан Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Ошибка при определении имен справочников для хранения файлов.
					           |У владельца файлов типа ""%1""
					           |основной справочник указан более одного раза.'"),
					Строка(ТипВладельцаФайлов),
					Строка(КлючИЗначение.Ключ));
			КонецЕсли;
			ОсновнойСправочникУказан = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Если ИменаСправочников.Количество() = 0 Тогда
		
		Если НеВызыватьИсключение Тогда
			Возврат ИменаСправочников;
		КонецЕсли;
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Ошибка при определении имен справочников для хранения файлов.
			           |У владельца файлов типа ""%1""
			           |не имеется справочников для хранения файлов.'"),
			Строка(ТипВладельцаФайлов));
	КонецЕсли;
	
	Возврат ИменаСправочников;
	
КонецФункции

// Возвращает имя справочника для указанного владельца или вызывает исключение,
// если их более одного.
// 
// Параметры:
//  ВладелецФайлов  - Ссылка - объект, к которому добавляется файл.
//  ИмяСправочника  - Строка, если заполнено, то выполняется проверка
//                    наличия справочника среди справочников владельца для хранения файлов.
//                    Если не заполнено, возвращает имя основного справочника.
//  ЗаголовокОшибки - Строка - заголовок ошибки.
//                  - Неопределено - не вызывать исключение, а вернуть пустую строку.
//  ИмяПараметра    - Строка - имя требуемого параметра для определения имени справочника.
//  ОкончаниеОшибки - Строка - окончание ошибки (только для случая, когда ИмяПараметра = Неопределено).
// 
Функция ИмяСправочникаХраненияФайлов(ВладелецФайлов, ИмяСправочника = "",
	ЗаголовокОшибки = Неопределено, ОкончаниеОшибки = Неопределено) Экспорт
	
	НеВызыватьИсключение = (ЗаголовокОшибки = Неопределено);
	ИменаСправочников = ИменаСправочниковХраненияФайлов(ВладелецФайлов, НеВызыватьИсключение);
	
	Если ИменаСправочников.Количество() = 0 Тогда
		Если НеВызыватьИсключение Тогда
			Возврат "";
		КонецЕсли;
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ЗаголовокОшибки + Символы.ПС
			+ НСтр("ru = 'У владельца файлов ""%1"" типа ""%2""
			             |нет справочников для хранения файлов.'"),
			Строка(ВладелецФайлов),
			Строка(ТипЗнч(ВладелецФайлов)));
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИмяСправочника) Тогда
		Если ИменаСправочников[ИмяСправочника] <> Неопределено Тогда
			Возврат ИмяСправочника;
		КонецЕсли;
	
		Если НеВызыватьИсключение Тогда
			Возврат "";
		КонецЕсли;
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ЗаголовокОшибки + Символы.ПС
			+ НСтр("ru = 'У владельца файлов ""%1"" типа ""%2""
			             |нет справочника ""%3"" для хранения файлов.'"),
			Строка(ВладелецФайлов),
			Строка(ТипЗнч(ВладелецФайлов)),
			Строка(ИмяСправочника));
	КонецЕсли;
	
	ОсновнойСправочник = "";
	Для каждого КлючИЗначение Из ИменаСправочников Цикл
		Если КлючИЗначение.Значение = Истина Тогда
			ОсновнойСправочник = КлючИЗначение.Ключ;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ОсновнойСправочник) Тогда
		Возврат ОсновнойСправочник;
	КонецЕсли;
		
	Если НеВызыватьИсключение Тогда
		Возврат "";
	КонецЕсли;
	
	ШаблонПричиныОшибки = 
		НСтр("ru = 'У владельца файлов ""%1"" типа ""%2""
			|не указан основной справочник для хранения файлов.'") + Символы.ПС;
			
	ПричинаОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		ШаблонПричиныОшибки, Строка(ВладелецФайлов), Строка(ТипЗнч(ВладелецФайлов)));
		
	ТекстОшибки = ЗаголовокОшибки + Символы.ПС
		+ ПричинаОшибки + Символы.ПС
		+ ОкончаниеОшибки;
		
	ВызватьИсключение СокрЛП(ТекстОшибки);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики событий подсистем БСП.

// Процедура является обработчиком одноименного события, возникающего при обмене данными в распределенной
// информационной базе.
//
// Параметры:
// см. описание обработчика события ПриОтправкеДанныхПодчиненному() в синтаксис-помощнике.
// 
Процедура ПриОтправкеДанныхПодчиненному(ЭлементДанных, ОтправкаЭлемента, СозданиеНачальногоОбраза, Получатель) Экспорт
	
	ПриОтправкеФайла(ЭлементДанных, ОтправкаЭлемента, СозданиеНачальногоОбраза, Получатель);
	
КонецПроцедуры

// Процедура является обработчиком одноименного события, возникающего при обмене данными в распределенной
// информационной базе.
//
// Параметры:
// см. описание обработчика события ПриОтправкеДанныхГлавному() в синтаксис-помощнике.
// 
Процедура ПриОтправкеДанныхГлавному(ЭлементДанных, ОтправкаЭлемента, Получатель) Экспорт
	
	ПриОтправкеФайла(ЭлементДанных, ОтправкаЭлемента);
	
КонецПроцедуры

// Процедура является обработчиком одноименного события, возникающего при обмене данными в распределенной
// информационной базе.
//
// Параметры:
// см. описание обработчика события ПриПолученииДанныхОтПодчиненного() в синтаксис-помощнике.
// 
Процедура ПриПолученииДанныхОтПодчиненного(ЭлементДанных, ПолучениеЭлемента, ОтправкаНазад, Отправитель) Экспорт
	
	ПриПолученииФайла(ЭлементДанных, ПолучениеЭлемента);
	
КонецПроцедуры

// Процедура является обработчиком одноименного события, возникающего при обмене данными в распределенной
// информационной базе.
//
// Параметры:
// см. описание обработчика события ПриПолученииДанныхОтГлавного() в синтаксис-помощнике.
// 
Процедура ПриПолученииДанныхОтГлавного(ЭлементДанных, ПолучениеЭлемента, ОтправкаНазад, Отправитель) Экспорт
	
	ПриПолученииФайла(ЭлементДанных, ПолучениеЭлемента);
	
КонецПроцедуры

// Заполняет массив списком имен объектов метаданных, данные которых могут содержать ссылки на различные объекты
// метаданных, но при этом эти ссылки не должны учитываться в бизнес-логике приложения.
//
// Параметры:
//  Массив       - массив строк, например, "РегистрСведений.ВерсииОбъектов".
//
Процедура ПриДобавленииИсключенийПоискаСсылок(Массив) Экспорт
	
	Массив.Добавить(Метаданные.РегистрыСведений.НаличиеПрисоединенныхФайлов.ПолноеИмя());
	
КонецПроцедуры

// Добавляет файл на том при "Разместить файлы начального образа".
//
Процедура ПриДобавленииФайловВТомаПриРазмещении(СоответствиеПутейФайлов, ХранитьФайлыВТомахНаДиске, ПрисоединяемыеФайлы) Экспорт
	
	ДобавитьФайлыВТомаПриРазмещении(СоответствиеПутейФайлов, ХранитьФайлыВТомахНаДиске, ПрисоединяемыеФайлы);
	
КонецПроцедуры

// Удаляет регистрацию изменений после "Разместить файлы начального образа".
//
Процедура ПриУдаленииРегистрацииИзменений(ПланОбменаСсылка, ПрисоединяемыеФайлы) Экспорт
	
	УдалитьРегистрациюИзменений(ПланОбменаСсылка, ПрисоединяемыеФайлы);
	
КонецПроцедуры

// Заполняет текст запроса для получения файлов у которых не извлечен текст.
// В качестве параметра может прийти другой запрос, с которым следует сделать объединение.
//
// Параметры:
//  ТекстЗапроса - Строка (возвращаемое значение), варианты передаваемых значений:
//                   Пустая строка   - будет возвращен требуемый текст запроса.
//                   Непустая строка - будет возвращен требуемый текст запроса, добавленный
//                                     к переданному тексту посредством "ОБЪЕДИНИТЬ ВСЕ".
// 
//  ПолучитьВсеФайлы - Булево - начальное значение Ложь. Позволяет отключить выборку
//                     файлов по частям, если передать Истина.
//
Процедура ПриОпределенииТекстаЗапросаДляИзвлеченияТекста(ТекстЗапроса, ПолучитьВсеФайлы = Ложь) Экспорт
	
	// Текст запроса формируется по всем справочникам присоединенных файлов.
	
	ТипыВладельцев = Метаданные.РегистрыСведений.НаличиеПрисоединенныхФайлов.Измерения.ОбъектСФайлами.Тип.Типы();
	
	КоличествоТипов = ТипыВладельцев.Количество();
	Если КоличествоТипов = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ВсеИменаСправочников = Новый Соответствие;
	
	Для каждого Тип Из ТипыВладельцев Цикл
		
		Если Тип = Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных") Тогда
			Продолжить;
		КонецЕсли;
		
		ИменаСправочников = ИменаСправочниковХраненияФайлов(Тип);
		
		Для каждого КлючИЗначение Из ИменаСправочников Цикл
			Если ВсеИменаСправочников[КлючИЗначение.Ключ] <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ВсеИменаСправочников.Вставить(КлючИЗначение.Ключ, Истина);
		КонецЦикла;
	КонецЦикла;
	
	ЧислоФайловВВыборке = Цел(100 / ВсеИменаСправочников.Количество());
	ЧислоФайловВВыборке = ?(ЧислоФайловВВыборке < 10, 10, ЧислоФайловВВыборке);
	
	Для каждого КлючИЗначение Из ВсеИменаСправочников Цикл
	
		Если НЕ ПустаяСтрока(ТекстЗапроса) Тогда
			ТекстЗапроса = ТекстЗапроса + "
				|
				|ОБЪЕДИНИТЬ ВСЕ
				|
				|";
		КонецЕсли;
		
		ТекстЗапроса = ТекстЗапроса + ТекстЗапросаДляФайловСНеизвлеченнымТекстом(
			КлючИЗначение.Ключ,
			ЧислоФайловВВыборке,
			ПолучитьВсеФайлы);
	КонецЦикла;
	
КонецПроцедуры

// Возвращает число файлов с неизвлеченным текстом.
//
Процедура ПриОпределенииКоличестваВерсийСНеизвлеченнымТекстом(ЧислоВерсий) Экспорт
	
	ЧислоВерсий = 0;
	ЧислоВерсий = ЧислоВерсий + ПолучитьКоличествоВерсийСНеизвлеченнымТекстом();
	
КонецПроцедуры

// Записывает извлеченный текст.
//
Процедура ПриЗаписиИзвлеченногоТекста(ФайлОбъект) Экспорт
	
	Если Не ЭтоЭлементПрисоединенныеФайлы(ФайлОбъект) Тогда
		Возврат;
	КонецЕсли;
	
	ФайлОбъект.ОбменДанными.Загрузка = Истина;
	ФайлОбъект.Записать();
	
КонецПроцедуры

// Возвращает в параметре КоличествоФайловВТомах количество файлов в томах.
//
Процедура ПриОпределенииКоличестваФайловВТомах(КоличествоФайловВТомах) Экспорт
	
	ОпределитьКоличествоФайловВТомах(КоличествоФайловВТомах);
	
КонецПроцедуры

// Возвращает Истина в параметре ЕстьХранимыеФайлы, если есть хранимые файлы к объекту ВнешнийОбъект.
//
Процедура ПриОпределенииНаличияХранимыхФайлов(ВнешнийОбъект, ЕстьХранимыеФайлы) Экспорт
	
	ОпределитьНаличиеХранимыхФайлов(ВнешнийОбъект, ЕстьХранимыеФайлы);
	
КонецПроцедуры

// Возвращает в параметре ХранимыеФайлы массив хранимых файлов к объекту ВнешнийОбъект.
//
Процедура ПриПолученииХранимыхФайлов(ВнешнийОбъект, ХранимыеФайлы) Экспорт
	
	ПолучитьХранимыеФайлы(ВнешнийОбъект, ХранимыеФайлы);
	
КонецПроцедуры

// Возвращает навигационную ссылку на файл (на реквизит или во временное хранилище).
//
Процедура ПриОпределенииНавигационнойСсылкиФайла(ФайлСсылка, УникальныйИдентификатор, НавигационнаяСсылка) Экспорт
	
	Если ЭтоЭлементПрисоединенныеФайлы(ФайлСсылка) Тогда
		НавигационнаяСсылка = ПрисоединенныеФайлы.ПолучитьДанныеФайла(ФайлСсылка, УникальныйИдентификатор).СсылкаНаДвоичныеДанныеФайла;
	КонецЕсли;
	
КонецПроцедуры

// Получает полный путь к файлу на диске.
//
Процедура ПриОпределенииИмениФайлаСПутемКДвоичнымДанным(ФайлСсылка, ПутьКФайлу, ПустойПутьДляПустыхДанных = Ложь) Экспорт
	
	Если ЭтоЭлементПрисоединенныеФайлы(ФайлСсылка) Тогда
		ПутьКФайлу = ПолучитьИмяФайлаСПутемКДвоичнымДанным(ФайлСсылка, ПустойПутьДляПустыхДанных);
	КонецЕсли;
	
КонецПроцедуры

// Заполняет перечень обработчиков интеграции подсистемы.
// "ТехнологияСервиса.РаботаВМоделиСервиса.ФайловыеФункцииВМоделиСервиса".
//
// Параметры:
//  Обработчики - Массив(Строка), имя общего модуля обработчика.
//
Процедура ПриЗаполненииОбработчиковИнтеграцииФайловыхФункцийВМоделиСервиса(Обработчики) Экспорт
	
	Обработчики.Добавить("ПрисоединенныеФайлыСлужебный");
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в другие подсистемы.

// Добавляет и удаляет записи в регистр сведений ОчередьИзвлеченияТекста при изменении
// состояние извлечения текста версий файлов.
//
// Параметры:
//	ИсточникТекста - СправочникСсылка.ВерсииФайлов, СправочникСсылка.*ПрисоединенныеФайлы,
//		файл, у которого изменилось состояние извлечения текста.
//	СостояниеИзвлеченияТекста - ПеречислениеСсылка.СтатусыИзвлеченияТекстаФайлов, новый
//		статус извлечения текста у файла.
//
Процедура ПриОбновленииСостоянияОчередиИзвлеченияТекста(ИсточникТекста, СостояниеИзвлеченияТекста) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса.ФайловыеФункцииВМоделиСервиса") Тогда
		
		Если ОбщегоНазначения.ИспользованиеРазделителяСеанса() Тогда
			МодульФайловыеФункцииСлужебныйВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("ФайловыеФункцииСлужебныйВМоделиСервиса");
			МодульФайловыеФункцииСлужебныйВМоделиСервиса.ОбновитьСостояниеОчередиИзвлеченияТекста(ИсточникТекста, СостояниеИзвлеченияТекста);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции.

Функция ПолучениеФайлаЗапрещено(ЭлементДанных)
	
	Возврат ЭлементДанных.ЭтоНовый()
	   И НЕ ФайловыеФункцииСлужебныйКлиентСервер.ПроверитьРасширениеФайлаДляЗагрузки(
	          ЭлементДанных.Расширение, Ложь);
	
КонецФункции

Процедура ПоместитьФайлВРеквизитСправочника(ЭлементДанных)
	
	Попытка
		// Помещаем данные файла из тома на диске в служебный реквизит справочника.
		ЭлементДанных.ФайлХранилище = ФайловыеФункцииСлужебный.ПоместитьДвоичныеДанныеВХранилище(ЭлементДанных.Том, ЭлементДанных.ПутьКФайлу, ЭлементДанных.Ссылка.УникальныйИдентификатор());
	Исключение
		// Возможно, файл не был найден. Отправку данных не прерываем.
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Файлы.Не удалось отправить файл при обмене данными'",
			     ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()) );
		
		ЭлементДанных.ФайлХранилище = Новый ХранилищеЗначения(Неопределено);
	КонецПопытки;
	
	ЭлементДанных.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
	ЭлементДанных.ПутьКФайлу = "";
	ЭлементДанных.Том = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
	
КонецПроцедуры

// Возвращает новый идентификатор объекта.
//  Для получения нового идентификатора выбирает последний идентификатор объекта
// из регистра НаличиеПрисоединенныхФайлов увеличивает его значение
// на одну единицу и возвращает полученный результат.
//
// Возвращаемое значение:
//  Строка (10) - новый идентификатор объекта.
//
Функция ПолучитьОчереднойИдентификаторОбъекта()
	
	// Вычисление нового идентификатора объекта.
	Результат = "0000000000"; // По длине ресурса ИдентификаторОбъекта.
	
	ТекстЗапроса =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	НаличиеПрисоединенныхФайлов.ИдентификаторОбъекта КАК ИдентификаторОбъекта
	|ИЗ
	|	РегистрСведений.НаличиеПрисоединенныхФайлов КАК НаличиеПрисоединенныхФайлов
	|
	|УПОРЯДОЧИТЬ ПО
	|	ИдентификаторОбъекта УБЫВ";
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Идентификатор = Выборка.ИдентификаторОбъекта;
		
		Если ПустаяСтрока(Идентификатор) Тогда
			Возврат Результат;
		КонецЕсли;
		
		// Правила вычисления, как в обычном сложении: при 
		// заполнении текущего разряда следующий разряд увеличивается
		// на единицу, при этом, в текущем разряде значение становится
		// равным нулю. Значениями разрядов выступают символы
		// [0..9] и [a..z]. Таким образом один разряд может содержать
		// 36 значений.
		
		Позиция = 10; // 9- индекс 10-го символа
		Пока Позиция > 0 Цикл
			
			Символ = Сред(Идентификатор, Позиция, 1);
			
			Если Символ = "z" Тогда
				Идентификатор = Лев(Идентификатор, Позиция-1) + "0" + Прав(Идентификатор, 10 - Позиция);
				Позиция = Позиция - 1;
				Продолжить;
				
			ИначеЕсли Символ = "9" Тогда
				НовыйСимвол = "a";
			Иначе
				НовыйСимвол = Символ(КодСимвола(Символ)+1);
			КонецЕсли;
			
			Идентификатор = Лев(Идентификатор, Позиция-1) + НовыйСимвол + Прав(Идентификатор, 10 - Позиция);
			Прервать;
		КонецЦикла;
		
		Результат = Идентификатор;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ТекстЗапросаДляФайловСНеизвлеченнымТекстом(Знач ИмяСправочника, Знач ЧислоФайловВВыборке, Знач ПолучитьВсеФайлы = Ложь)
	
	ТекстЗапроса = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ПрисоединенныеФайлы.Ссылка КАК Ссылка,
	|	ПрисоединенныеФайлы.СтатусИзвлеченияТекста КАК СтатусИзвлеченияТекста,
	|	ПрисоединенныеФайлы.ТипХраненияФайла КАК ТипХраненияФайла,
	|	ПрисоединенныеФайлы.Расширение КАК Расширение,
	|	ПрисоединенныеФайлы.Наименование КАК Наименование
	|ИЗ
	|	&ИмяСправочника КАК ПрисоединенныеФайлы
	|ГДЕ
	|	ПрисоединенныеФайлы.СтатусИзвлеченияТекста В (ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен), ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.ПустаяСсылка))";
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяПодпись") Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|	И НЕ ПрисоединенныеФайлы.Зашифрован";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ПЕРВЫЕ 1", ?(
		ПолучитьВсеФайлы,
		"",
		"ПЕРВЫЕ " + Формат(ЧислоФайловВВыборке, "ЧГ=; ЧН=")) );
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяСправочника", "Справочник." + ИмяСправочника);
	
	Возврат ТекстЗапроса;
	
КонецФункции

Функция ТекстЗапросаДляЧислаФайловСНеизвлеченнымТекстом(Знач ИмяСправочника)
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	ЕСТЬNULL(КОЛИЧЕСТВО(ПрисоединенныеФайлы.Ссылка), 0) КАК КоличествоФайлов
	|ИЗ
	|	&ИмяСправочника КАК ПрисоединенныеФайлы
	|ГДЕ
	|	ПрисоединенныеФайлы.СтатусИзвлеченияТекста В (ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен), ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.ПустаяСсылка))";
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЭлектроннаяПодпись") Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|	И НЕ ПрисоединенныеФайлы.Зашифрован";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяСправочника", "Справочник." + ИмяСправочника);
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Возвращает текст сообщения об ошибке, добавляя к нему ссылку на элемент
// справочника хранимого файла.
//
Функция ТекстОшибкиПриСохраненииФайлаВТоме(Знач СообщениеОбОшибке, Знач Файл)
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Ошибка, при сохранении файла в томе:
		           |""%1"".
		           |
		           |Ссылка на файл: ""%2"".'"),
		СообщениеОбОшибке,
		ПолучитьНавигационнуюСсылку(Файл) );
	
КонецФункции

Функция ЕстьПосторонниеСимволыВИдентификаторе(Идентификатор)
	
	Для Позиция = 1 По СтрДлина(Идентификатор) Цикл
		Символ = Сред(Идентификатор, Позиция, 1);
		Если (КодСимвола(Символ) < КодСимвола("a") Или КодСимвола(Символ) > КодСимвола("z"))
			И (КодСимвола(Символ) < КодСимвола("0") Или КодСимвола(Символ) > КодСимвола("9")) Тогда
				Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Очистка ненужных файлов

// Удаляет запись в регистре ПрисоединенныеФайлы.
//
// Параметры:
// ФайлСсылка - ссылка на файл.
//
Процедура УдалитьЗаписьИзРегистраПрисоединенныеФайлы(ФайлСсылка)
	
	УстановитьПривилегированныйРежим(Истина);
	
	НаборЗаписей = РегистрыСведений.ПрисоединенныеФайлы.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.ПрисоединенныйФайл.Установить(ФайлСсылка);
	НаборЗаписей.Записать();
	
КонецПроцедуры

#КонецОбласти
