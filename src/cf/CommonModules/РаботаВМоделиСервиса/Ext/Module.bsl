///////////////////////////////////////////////////////////////////////////////////
// РаботаВМоделиСервиса.
//
///////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Возвращает имя общего реквизита, который является разделителем основных данных.
//
// Возвращаемое значение: Строка.
//
Функция РазделительОсновныхДанных() Экспорт
	
	Возврат Метаданные.ОбщиеРеквизиты.ОбластьДанныхОсновныеДанные.Имя;
	
КонецФункции

// Возвращает имя общего реквизита, который является разделителем вспомогательных данных.
//
// Возвращаемое значение: Строка.
//
Функция РазделительВспомогательныхДанных() Экспорт
	
	Возврат Метаданные.ОбщиеРеквизиты.ОбластьДанныхВспомогательныеДанные.Имя;
	
КонецФункции

// Очищает все параметры сеанса, кроме связанных с общим 
// реквизитом ОбластьДанных.
//
Процедура ОчиститьВсеПараметрыСеансаКромеРазделителей() Экспорт
	
	ОбщегоНазначения.ОчиститьПараметрыСеанса(, "ОбластьДанныхЗначение,ОбластьДанныхИспользование");
	
КонецПроцедуры

// Устанавливает блокировку области данных.
// 
// Параметры: 
// ПроверитьОтсутствиеДругихСеансов - Булево - проверить отсутствие других
// пользовательских сеансов со значением разделителя равным текущему.
// В случае обнаружения других сеансов будет выдано исключение.
// РазделяемаяБлокировка - Булево - установить разделяемую блокировку
// вместо исключительной.
// 
Процедура ЗаблокироватьТекущуюОбластьДанных(Знач ПроверитьОтсутствиеДругихСеансов = Ложь, Знач РазделяемаяБлокировка = Ложь) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		ВызватьИсключение(НСтр("ru = 'Блокировка области может быть установлена только при включенном использовании разделителей'"));
	КонецЕсли;
	
	Ключ = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ОбщегоНазначения.ЗначениеРазделителяСеанса()));
	
	КоличествоПопыток = 5;
	ТекущаяПопытка = 0;
	Пока Истина Цикл
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Ключ);
			Прервать;
		Исключение
			ТекущаяПопытка = ТекущаяПопытка + 1;
			
			Если ТекущаяПопытка = КоличествоПопыток Тогда
				ШаблонКомментария = НСтр("ru = 'Не удалось установить блокировку области данных по причине:
					|%1'");
				ТекстКомментария = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонКомментария, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииБлокировкаОбластиДанных(),
					УровеньЖурналаРегистрации.Ошибка,
					,
					,
					ТекстКомментария);
					
				ШаблонТекста = НСтр("ru = 'Не удалось установить блокировку области данных по причине:
					|%1'");
				Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонТекста, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
					
				ВызватьИсключение(Текст);
			КонецЕсли;
		КонецПопытки;
	КонецЦикла;
	
	Если ПроверитьОтсутствиеДругихСеансов Тогда
		
		КонфликтующиеСеансы = Новый Массив();
		
		Для каждого Сеанс Из ПолучитьСеансыИнформационнойБазы() Цикл
			Если Сеанс.НомерСеанса = НомерСеансаИнформационнойБазы() Тогда
				Продолжить;
			КонецЕсли;
			
			КлиентскиеПриложения = Новый Массив;
			КлиентскиеПриложения.Добавить(ВРег("1CV8"));
			КлиентскиеПриложения.Добавить(ВРег("1CV8C"));
			КлиентскиеПриложения.Добавить(ВРег("WebClient"));
			КлиентскиеПриложения.Добавить(ВРег("COMConnection"));
			КлиентскиеПриложения.Добавить(ВРег("WSConnection"));
			КлиентскиеПриложения.Добавить(ВРег("BackgroundJob"));
			Если КлиентскиеПриложения.Найти(ВРег(Сеанс.ИмяПриложения)) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			КонфликтующиеСеансы.Добавить(Сеанс);
			
		КонецЦикла;
		
		Если КонфликтующиеСеансы.Количество() > 0 Тогда
			
			РазблокироватьДанныеДляРедактирования(Ключ);
			
			ТекстСеансы = "";
			Для Каждого КонфликтующийСеанс Из КонфликтующиеСеансы Цикл
				
				Если Не ПустаяСтрока(ТекстСеансы) Тогда
					ТекстСеансы = ТекстСеансы + ", ";
				КонецЕсли;
				
				ТекстСеансы = ТекстСеансы + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = '%1 (сеанс - %2)'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					КонфликтующийСеанс.Пользователь.Имя,
					Формат(КонфликтующийСеанс.НомерСеанса, "ЧГ=0"));
				
			КонецЦикла;
			
			ТекстИсключения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Операция не может быть выполнена, т.к. в приложении работают другие пользователи: %1'",
					ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				ТекстСеансы);
			ВызватьИсключение ТекстИсключения;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если НЕ РазделяемаяБлокировка Тогда
		УстановитьМонопольныйРежим(Истина);
		Возврат;
	КонецЕсли;
	
	МодельДанных = РаботаВМоделиСервисаПовтИсп.ПолучитьМодельДанныхОбласти();
	
	Если РазделяемаяБлокировка Тогда
		РежимБлокировки = РежимБлокировкиДанных.Разделяемый;
	Иначе
		РежимБлокировки = РежимБлокировкиДанных.Исключительный;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	
	Для Каждого ЭлементМодели Из МодельДанных Цикл
		
		ПолноеИмяОбъектаМетаданных = ЭлементМодели.Ключ;
		ОписаниеОбъектаМетаданных = ЭлементМодели.Значение;
		
		ПространствоБлокировки = ПолноеИмяОбъектаМетаданных;
		
		Если ЭтоПолноеИмяРегистра(ПолноеИмяОбъектаМетаданных) Тогда
			
			БлокироватьНаборы = Истина;
			Если ЭтоПолноеИмяРегистраСведений(ПолноеИмяОбъектаМетаданных) Тогда
				ОбъектМетаданныхОбласти = Метаданные.РегистрыСведений.Найти(ОписаниеОбъектаМетаданных.Имя);
				Если ОбъектМетаданныхОбласти.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.Независимый Тогда
					БлокироватьНаборы = Ложь;
				КонецЕсли;
			КонецЕсли;
			
			Если БлокироватьНаборы Тогда
				ПространствоБлокировки = ПространствоБлокировки + ".НаборЗаписей";
			КонецЕсли;
			
		ИначеЕсли ЭтоПолноеИмяПоследовательности(ПолноеИмяОбъектаМетаданных) Тогда
			
			ПространствоБлокировки = ПространствоБлокировки + ".Записи";
			
		ИначеЕсли ЭтоПолноеИмяЖурналаДокументов(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяПеречисления(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяПоследовательности(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяРегламентногоЗадания(ПолноеИмяОбъектаМетаданных) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
		ЭлементБлокировки.Режим = РежимБлокировки;
		
	КонецЦикла;
	
	Блокировка.Заблокировать();
	
КонецПроцедуры

// Снимает исключительную блокировку области с текущей области данных.
//
Процедура РазблокироватьТекущуюОбластьДанных() Экспорт
	
	Ключ = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ОбщегоНазначения.ЗначениеРазделителяСеанса()));
		
	РазблокироватьДанныеДляРедактирования(Ключ);
	
	УстановитьМонопольныйРежим(Ложь);
	
КонецПроцедуры

// Проверяет блокировку области данных.
//
// Параметры:
//  ОбластьДанных -  Число - значение разделителя области данных, 
//   блокировку которой требуется проверить.
//
// Возвращаемое значение:
// Булево - Истина область данных заблокирована, иначе нет.
//
Функция ОбластьДанныхЗаблокирована(Знач ОбластьДанных) Экспорт
	
	Ключ = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ОбластьДанных));
	
	Попытка
		ЗаблокироватьДанныеДляРедактирования(Ключ);
	Исключение
		Возврат Истина;
	КонецПопытки;
	
	РазблокироватьДанныеДляРедактирования(Ключ);
	
	Возврат Ложь;
	
КонецФункции

// Подготавливает область данных к использованию. Запускает
// процедура обновления ИБ, при необходимости заполняет демонстрационными
// данными, устанавливает новый статус в регистре ОбластиДанных.
// 
// Параметры: 
// ОбластьДанных - Тип значения разделителя - значение разделителя
// области данных, которую необходимо подготовить к использованию.
// 
Процедура ПодготовитьОбластьДанныхКИспользованию(Знач ОбластьДанных, Знач ИДФайлаВыгрузки, 
												 Знач Вариант = Неопределено) Экспорт
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	КлючОбласти = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ОбластьДанных));
	ЗаблокироватьДанныеДляРедактирования(КлючОбласти);
	
	Попытка
		МенеджерЗаписи = ПолучитьМенеджерЗаписиОбластиДанных(ОбластьДанных, Перечисления.СтатусыОбластейДанных.Новая);
		
		// Список пользователей не пустой и не фоновое задание из регламентного.
		// В этом случае требуется авторизовать пользователя.
		Если ПользователиИнформационнойБазы.ТекущийПользователь().Имя <> "" Тогда
			
			ПользователиСлужебный.АвторизоватьТекущегоПользователя();
			
		КонецЕсли;
		
		СообщениеОбОшибке = "";
		Если Не ЗначениеЗаполнено(Вариант) Тогда
			
			РезультатПодготовки = ПодготовитьОбластьДанныхКИспользованиюИзВыгрузки(ОбластьДанных, ИДФайлаВыгрузки, 
				СообщениеОбОшибке);
			
		Иначе
			
			РезультатПодготовки = ПодготовитьОбластьДанныхКИспользованиюИзЭталонной(ОбластьДанных, ИДФайлаВыгрузки, 
				Вариант, СообщениеОбОшибке);
				
		КонецЕсли;
		
		СменитьСтатусОбластиИУведомитьМенеджер(МенеджерЗаписи, РезультатПодготовки, СообщениеОбОшибке);

	Исключение
		РазблокироватьДанныеДляРедактирования(КлючОбласти);
		ВызватьИсключение;
	КонецПопытки;
	
	РазблокироватьДанныеДляРедактирования(КлючОбласти);

КонецПроцедуры

// Копирует данные области данных в другую область данных.
// 
// Параметры: 
// ОбластьИсточник - Тип значения разделителя - значение разделителя
// области данных - источника данных.
// ОбластьПриемник - Тип значения разделителя - значение разделителя
// области данных - приемника данных.
// 
Процедура СкопироватьДанныеОбласти(Знач ОбластьИсточник, Знач ОбластьПриемник) Экспорт
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, ОбластьИсточник);
	
	ИмяФайлаВыгрузки = Неопределено;
	
	Если Не ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.РаботаВМоделиСервиса.ВыгрузкаЗагрузкаОбластейДанных") Тогда
		
		ВызватьИсключениеОтсутствуетПодсистемаБТС("ТехнологияСервиса.РаботаВМоделиСервиса.ВыгрузкаЗагрузкаОбластейДанных");
		
	КонецЕсли;
	
	МодульВыгрузкаЗагрузкаОбластейДанных = ОбщегоНазначения.ОбщийМодуль("ВыгрузкаЗагрузкаОбластейДанных");
	
	Попытка
		ИмяФайлаВыгрузки = МодульВыгрузкаЗагрузкаОбластейДанных.ВыгрузитьТекущуюОбластьДанныхВАрхив();
	Исключение
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если ИмяФайлаВыгрузки <> Неопределено Тогда
			Попытка
				УдалитьФайлы(ИмяФайлаВыгрузки);
			Исключение
				ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
					УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			КонецПопытки;
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
	ОбщегоНазначения.УстановитьРазделениеСеанса(Неопределено, ОбластьПриемник);
	
	Попытка
		МодульВыгрузкаЗагрузкаОбластейДанных.ЗагрузитьТекущуюОбластьДанныхИзАрхива(ИмяФайлаВыгрузки);
	Исключение
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Попытка
			УдалитьФайлы(ИмяФайлаВыгрузки);
		Исключение
			ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
				УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		ВызватьИсключение;
	КонецПопытки;
	
	Попытка
		УдалитьФайлы(ИмяФайлаВыгрузки);
	Исключение
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
КонецПроцедуры

// Удаляет все данные области данных, кроме предопределенных, устанавливает для области данных
//  статус Удалена, отправляет в менеджер сервиса сообщение с информацией об изменении статуса
//  области. После этого область данных будет непригодна к использованию.
//
// Если нужно удалить все данные области без изменения ее статуса и с сохранением возможности
//  дальнейшего использования области, необходимо использовать процедуру ОчиститьДанныеОбласти().
//
// Параметры: 
//  ОбластьДанных - Число(7,0) - значение разделителя области данных которую требуется очистить,
//   При вызове процедуры разделение данных уже должно быть переключено в эту область.
//  УдалитьПользователей - Булево - флаг необходимости удаления пользователей информационной
//    базы для данной области данных.
//
Процедура ОчиститьОбластьДанных(Знач ОбластьДанных, Знач УдалитьПользователей = Истина) Экспорт
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	КлючОбласти = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ОбластьДанных));
	ЗаблокироватьДанныеДляРедактирования(КлючОбласти);
	
	Попытка
		
		МенеджерЗаписи = ПолучитьМенеджерЗаписиОбластиДанных(ОбластьДанных, Перечисления.СтатусыОбластейДанных.КУдалению);
		
		ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
			"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриУдаленииОбластиДанных");
		
		Для каждого Обработчик Из ОбработчикиСобытия Цикл
			Обработчик.Модуль.ПриУдаленииОбластиДанных(ОбластьДанных);
		КонецЦикла;
		
		РаботаВМоделиСервисаПереопределяемый.ПриУдаленииОбластиДанных(ОбластьДанных);
		
		ОчиститьДанныеОбласти(УдалитьПользователей); // Вызываем очистку
		
		// Восстановление предопределенных элементов.
		МодельДанных = РаботаВМоделиСервисаПовтИсп.ПолучитьМодельДанныхОбласти();

		Для каждого ЭлементМодели Из МодельДанных Цикл
			
			ПолноеИмяОбъектаМетаданных = ЭлементМодели.Ключ;
			
			Если ЭтоПолноеИмяСправочника(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяПланаСчетов(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяПланаВидовХарактеристик(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяПланаВидовРасчета(ПолноеИмяОбъектаМетаданных) Тогда
				
				ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
				
				Если ОбъектМетаданных.ПолучитьИменаПредопределенных().Количество() > 0 Тогда
					
					Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
					Менеджер.УстановитьИнициализациюПредопределенныхДанных(Ложь);
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;		

		СменитьСтатусОбластиИУведомитьМенеджер(МенеджерЗаписи, "ОбластьУдалена", "");
		
	Исключение
		РазблокироватьДанныеДляРедактирования(КлючОбласти);
		ВызватьИсключение;
	КонецПопытки;
	
	РазблокироватьДанныеДляРедактирования(КлючОбласти);
	
КонецПроцедуры

// Удаляет все разделенные данные из текущей области данных (в т.ч. при выключенном
//  разделении по областям данных), кроме переопределенных.
//
// Параметры:
//  УдалитьПользователей - Булево, флаг необходимости удаления пользователей
//    информационной базы.
//
Процедура ОчиститьДанныеОбласти(Знач УдалитьПользователей) Экспорт
	
	МодельДанных = РаботаВМоделиСервисаПовтИсп.ПолучитьМодельДанныхОбласти();
	
	ИсключенияОчистки = Новый Массив();
	ИсключенияОчистки.Добавить(Метаданные.РегистрыСведений.ОбластиДанных.ПолноеИмя());
	
	Для каждого ЭлементМодели Из МодельДанных Цикл
		
		ПолноеИмяОбъектаМетаданных = ЭлементМодели.Ключ;
		ОписаниеОбъектаМетаданных = ЭлементМодели.Значение;
		
		Если ИсключенияОчистки.Найти(ПолноеИмяОбъектаМетаданных) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЭтоПолноеИмяКонстанты(ПолноеИмяОбъектаМетаданных) Тогда
			
			ОбъектМетаданныхОбласти = Метаданные.Константы.Найти(ОписаниеОбъектаМетаданных.Имя);
			МенеджерЗначения = Константы[ОписаниеОбъектаМетаданных.Имя].СоздатьМенеджерЗначения();
			МенеджерЗначения.ОбменДанными.Загрузка = Истина;
			МенеджерЗначения.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
			МенеджерЗначения.Значение = ОбъектМетаданныхОбласти.Тип.ПривестиЗначение();
			МенеджерЗначения.Записать();
			
		ИначеЕсли ЭтоПолноеИмяОбъектаСсылочногоТипа(ПолноеИмяОбъектаМетаданных) Тогда
			
			ЭтоПланОбмена = ЭтоПолноеИмяПланаОбмена(ПолноеИмяОбъектаМетаданных);
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ
			|	Т.Ссылка КАК Ссылка
			|ИЗ
			|	" + ПолноеИмяОбъектаМетаданных + " КАК Т");
			
			Если ЭтоПланОбмена Тогда
				
				Запрос.Текст = Запрос.Текст + "
				|ГДЕ
				|	Т.Ссылка <> &ЭтотУзел";
				
				Запрос.УстановитьПараметр("ЭтотУзел", ПланыОбмена[ОписаниеОбъектаМетаданных.Имя].ЭтотУзел());
				
			КонецЕсли;
			
			РезультатЗапроса = Запрос.Выполнить();
			Выборка = РезультатЗапроса.Выбрать();
			
			Пока Выборка.Следующий() Цикл
				
				УдаляемыйОбъект = Выборка.Ссылка.ПолучитьОбъект();
				УдаляемыйОбъект.ОбменДанными.Загрузка = Истина;
				УдаляемыйОбъект.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
				УдаляемыйОбъект.Удалить();
				
			КонецЦикла;
			
			
		ИначеЕсли ЭтоПолноеИмяРегистра(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяПерерасчета(ПолноеИмяОбъектаМетаданных) Тогда
			
			ЭтоРегистрНакопления = ЭтоПолноеИмяРегистраНакопления(ПолноеИмяОбъектаМетаданных);
			ЭтоРегистрБухгалтерии = ЭтоПолноеИмяРегистраБухгалтерии(ПолноеИмяОбъектаМетаданных);
			ЭтоРегистрСведений = ЭтоПолноеИмяРегистраСведений(ПолноеИмяОбъектаМетаданных);
			
			Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
			
			ЭтоНезависимыйРегистрСведений = Ложь;
			
			Если ЭтоРегистрНакопления Тогда
				
				РегистрМетаданные = Метаданные.РегистрыНакопления.Найти(ОписаниеОбъектаМетаданных.Имя);
				
				Если РегистрМетаданные.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
					
					Если Менеджер.ПолучитьМинимальныйПериодРассчитанныхИтогов() <> '00010101'
						ИЛИ Менеджер.ПолучитьМаксимальныйПериодРассчитанныхИтогов() <> КонецМесяца('00010101') Тогда
					
						Менеджер.УстановитьМинимальныйИМаксимальныйПериодыРассчитанныхИтогов('00010101', '00010101');
						
					КонецЕсли;
					
					Если Менеджер.ПолучитьИспользованиеТекущихИтогов() Тогда
					
						Менеджер.УстановитьИспользованиеТекущихИтогов(Ложь);
						
					КонецЕсли;
					
					Если Менеджер.ПолучитьИспользованиеИтогов() Тогда
					
						Менеджер.УстановитьИспользованиеИтогов(Ложь);
						
					КонецЕсли;
					
				КонецЕсли;
				
			ИначеЕсли ЭтоРегистрБухгалтерии Тогда
				
				Если Менеджер.ПолучитьМинимальныйПериодРассчитанныхИтогов() <> '00010101'
					ИЛИ Менеджер.ПолучитьМаксимальныйПериодРассчитанныхИтогов() <> '00010101' Тогда
				
					Менеджер.УстановитьМинимальныйИМаксимальныйПериодыРассчитанныхИтогов('00010101', '00010101');
					
				КонецЕсли;
				
				Если Менеджер.ПолучитьИспользованиеТекущихИтогов() Тогда
				
					Менеджер.УстановитьИспользованиеТекущихИтогов(Ложь);
					
				КонецЕсли;
				
				Если Менеджер.ПолучитьИспользованиеИтогов() Тогда
				
					Менеджер.УстановитьИспользованиеИтогов(Ложь);
					
				КонецЕсли;
				
			ИначеЕсли ЭтоРегистрСведений Тогда
				
				РегистрМетаданные = Метаданные.РегистрыСведений.Найти(ОписаниеОбъектаМетаданных.Имя);
				
				Если РегистрМетаданные.РазрешитьИтогиСрезПервых
					ИЛИ РегистрМетаданные.РазрешитьИтогиСрезПоследних Тогда
				
					Если Менеджер.ПолучитьИспользованиеИтогов() Тогда
					
						Менеджер.УстановитьИспользованиеИтогов(Ложь);
						
					КонецЕсли;
					
				КонецЕсли;
				
				ЭтоНезависимыйРегистрСведений = (РегистрМетаданные.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.Независимый);
				
			КонецЕсли;
			
			Если ЭтоНезависимыйРегистрСведений Тогда
				
				НаборЗаписей = Менеджер.СоздатьНаборЗаписей();
				НаборЗаписей.ОбменДанными.Загрузка = Истина;
				НаборЗаписей.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
				НаборЗаписей.Записать();
				
			Иначе
				
				ПараметрыВыборки = ПараметрыВыборки(ПолноеИмяОбъектаМетаданных);
				ИмяПоляРегистратор = ПараметрыВыборки.ИмяПоляРегистратор;
				
				Запрос = Новый Запрос(
				"ВЫБРАТЬ РАЗЛИЧНЫЕ
				|	Т.Регистратор КАК Регистратор
				|ИЗ
				|	" + ПараметрыВыборки.Таблица + " КАК Т");
				
				Если ИмяПоляРегистратор <> "Регистратор" Тогда
					
					Запрос.Текст = СтрЗаменить(Запрос.Текст, "Регистратор", ИмяПоляРегистратор);
					
				КонецЕсли;
				
				РезультатЗапроса = Запрос.Выполнить();
				Выборка = РезультатЗапроса.Выбрать();
				
				Пока Выборка.Следующий() Цикл
					
					НаборЗаписей = Менеджер.СоздатьНаборЗаписей();
					НаборЗаписей.Отбор[ИмяПоляРегистратор].Установить(Выборка[ИмяПоляРегистратор]);
					НаборЗаписей.ОбменДанными.Загрузка = Истина;
					НаборЗаписей.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
					НаборЗаписей.Записать();
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Пользователи
	Если УдалитьПользователей Тогда
		
		ПервыйАдминистратор = Неопределено;
		
		Для каждого ПользовательИБ Из ПользователиИнформационнойБазы.ПолучитьПользователей() Цикл
			
			Если ПервыйАдминистратор = Неопределено И Пользователи.ЭтоПолноправныйПользователь(ПользовательИБ, Истина, Ложь) Тогда
				
				// Отложим удаление администратора, чтобы на момент его удаления все остальные
				// пользователи информационной базы уже были удалены.
				ПервыйАдминистратор = ПользовательИБ;
				
			Иначе
				
				ПользовательИБ.Удалить();
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если ПервыйАдминистратор <> Неопределено Тогда
			
			ПервыйАдминистратор.Удалить();
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Настройки
	Хранилища = Новый Массив;
	Хранилища.Добавить(ХранилищеВариантовОтчетов);
	Хранилища.Добавить(ХранилищеНастроекДанныхФорм);
	Хранилища.Добавить(ХранилищеОбщихНастроек);
	Хранилища.Добавить(ХранилищеПользовательскихНастроекОтчетов);
	Хранилища.Добавить(ХранилищеСистемныхНастроек);
	
	Для каждого Хранилище Из Хранилища Цикл
		
		Если ТипЗнч(Хранилище) <> Тип("СтандартноеХранилищеНастроекМенеджер") Тогда
			
			// Настройки будут удалены при очистке данных.
			Продолжить;
			
		КонецЕсли;
		
		Хранилище.Удалить(Неопределено, Неопределено, Неопределено);
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура одноименного регламентного задания.
// Находит все области данных со статусами, требующими обработки
// прикладным приложением и при необходимости планирует запуск ФЗ
// по их обслуживанию.
// 
Процедура ОбслуживаниеОбластейДанных() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.ОбслуживаниеОбластейДанных);
	
	МаксимальноеКоличествоПовторов = 3;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ОбластиДанных.ОбластьДанныхВспомогательныеДанные КАК ОбластьДанных,
	|	ОбластиДанных.Статус КАК Статус,
	|	ОбластиДанных.ИдентификаторВыгрузки КАК ИдентификаторВыгрузки,
	|	ОбластиДанных.Вариант КАК Вариант
	|ИЗ
	|	РегистрСведений.ОбластиДанных КАК ОбластиДанных
	|ГДЕ
	|	ОбластиДанных.Статус В (ЗНАЧЕНИЕ(Перечисление.СтатусыОбластейДанных.Новая), ЗНАЧЕНИЕ(Перечисление.СтатусыОбластейДанных.КУдалению))
	|	И ОбластиДанных.ОшибкаОбработки = ЛОЖЬ
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбластьДанных";
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Выполняется = 0;
	
	Пока Выборка.Следующий() Цикл
		
		Ключ = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
			РегистрыСведений.ОбластиДанных,
			Новый Структура(РазделительВспомогательныхДанных(), Выборка.ОбластьДанных));
		
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Ключ);
		Исключение
			Продолжить;
		КонецПопытки;
		
		Менеджер = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
		Менеджер.ОбластьДанныхВспомогательныеДанные = Выборка.ОбластьДанных;
		Менеджер.Прочитать();
		
		Если Менеджер.Статус = Перечисления.СтатусыОбластейДанных.Новая Тогда 
			ИмяМетода = "РаботаВМоделиСервиса.ПодготовитьОбластьДанныхКИспользованию";
		ИначеЕсли Менеджер.Статус = Перечисления.СтатусыОбластейДанных.КУдалению Тогда 
			ИмяМетода = "РаботаВМоделиСервиса.ОчиститьОбластьДанных";
		Иначе
			РазблокироватьДанныеДляРедактирования(Ключ);
			Продолжить;
		КонецЕсли;
		
		Если Менеджер.Повтор < МаксимальноеКоличествоПовторов Тогда
		
			ОтборЗадания = Новый Структура;
			ОтборЗадания.Вставить("ИмяМетода", ИмяМетода);
			ОтборЗадания.Вставить("Ключ"     , "1");
			ОтборЗадания.Вставить("ОбластьДанных", Выборка.ОбластьДанных);
			Задания = ОчередьЗаданий.ПолучитьЗадания(ОтборЗадания);
			Если Задания.Количество() > 0 Тогда
				РазблокироватьДанныеДляРедактирования(Ключ);
				Продолжить;
			КонецЕсли;
			
			Менеджер.Повтор = Менеджер.Повтор + 1;
			
			КопияМенеджера = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
			ЗаполнитьЗначенияСвойств(КопияМенеджера, Менеджер);
			Менеджер = КопияМенеджера;
			
			Менеджер.Записать();

			ПараметрыМетода = Новый Массив;
			ПараметрыМетода.Добавить(Выборка.ОбластьДанных);
			
			Если Выборка.Статус = Перечисления.СтатусыОбластейДанных.Новая Тогда
				
				ПараметрыМетода.Добавить(Выборка.ИдентификаторВыгрузки);
				Если ЗначениеЗаполнено(Выборка.Вариант) Тогда
					ПараметрыМетода.Добавить(Выборка.Вариант);
				КонецЕсли;
			КонецЕсли;
			
			ПараметрыЗадания = Новый Структура;
			ПараметрыЗадания.Вставить("ИмяМетода"    , ИмяМетода);
			ПараметрыЗадания.Вставить("Параметры"    , ПараметрыМетода);
			ПараметрыЗадания.Вставить("Ключ"         , "1");
			ПараметрыЗадания.Вставить("ОбластьДанных", Выборка.ОбластьДанных);
			ПараметрыЗадания.Вставить("ЭксклюзивноеВыполнение", Истина);
			
			ОчередьЗаданий.ДобавитьЗадание(ПараметрыЗадания);
			
			РазблокироватьДанныеДляРедактирования(Ключ);
		Иначе
			
			СменитьСтатусОбластиИУведомитьМенеджер(Менеджер, ?(Менеджер.Статус = Перечисления.СтатусыОбластейДанных.Новая,
				"ФатальнаяОшибка", "ОшибкаУдаления"), НСтр("ru = 'Исчерпано количество попыток обработки области'"));
			
			РазблокироватьДанныеДляРедактирования(Ключ);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает прокси web-сервиса для синхронизации административных действий в сервисе.
// 
// Возвращаемое значение: 
// WSПрокси.
// Прокси менеджера сервиса. 
// 
Функция ПолучитьПроксиМенеджераСервиса(Знач ПарольПользователя = Неопределено) Экспорт
	
	АдресМенеджераСервиса = ВнутреннийАдресМенеджераСервиса();
	Если Не ЗначениеЗаполнено(АдресМенеджераСервиса) Тогда
		ВызватьИсключение(НСтр("ru = 'Не установлены параметры связи с менеджером сервиса.'"));
	КонецЕсли;
	
	АдресСервиса = АдресМенеджераСервиса + "/ws/ManageApplication_1_0_3_1?wsdl";
	
	Если ПарольПользователя = Неопределено Тогда
		ИмяПользователя = ИмяСлужебногоПользователяМенеджераСервиса();
		ПарольПользователя = ПарольСлужебногоПользователяМенеджераСервиса();
	Иначе
		ИмяПользователя = ИмяПользователя();
	КонецЕсли;
	
	Прокси = ОбщегоНазначения.WSПрокси(АдресСервиса, "http://www.1c.ru/SaaS/ManageApplication/1.0.3.1",
		"ManageApplication_1_0_3_1", , ИмяПользователя, ПарольПользователя, 20);
		
	Возврат Прокси;
	
КонецФункции

// Устанавливает разделение сеанса.
//
// Параметры:
// Использование - Булево - Использование разделителя ОбластьДанных в сеансе.
// ОбластьДанных - Число - Значение разделителя ОбластьДанных.
//
Процедура УстановитьРазделениеСеанса(Знач Использование = Неопределено, Знач ОбластьДанных = Неопределено) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
		ВызватьИсключение(НСтр("ru = 'Изменить разделение сеанса возможно только из сеанса запущенного без указания разделителей'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Использование <> Неопределено Тогда
		ПараметрыСеанса.ОбластьДанныхИспользование = Использование;
	КонецЕсли;
	
	Если ОбластьДанных <> Неопределено Тогда
		ПараметрыСеанса.ОбластьДанныхЗначение = ОбластьДанных;
	КонецЕсли;
	
	ПриИзмененииОбластиДанных();
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Возвращаемое значение: 
// Тип значения разделителя.
// Значение разделителя текущей области данных. 
// 
Функция ЗначениеРазделителяСеанса() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат 0;
	Иначе
		Если НЕ ОбщегоНазначения.ИспользованиеРазделителяСеанса() Тогда
			ВызватьИсключение(НСтр("ru = 'Не установлено значение разделителя'"));
		КонецЕсли;
		
		// Получим значение разделителя текущей области данных.
		Возврат ПараметрыСеанса.ОбластьДанныхЗначение;
	КонецЕсли;
	
КонецФункции

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Возвращаемое значение: 
// Булево - Истина разделение используется, иначе нет.
// 
Функция ИспользованиеРазделителяСеанса() Экспорт
	
	Возврат ПараметрыСеанса.ОбластьДанныхИспользование;
	
КонецФункции

// Добавляет описание параметра по имени константы в таблицу параметров.
// Возвращает добавленный параметр.
//
// Параметры: 
// ТаблицаПараметров - Таблица значений - таблица описания параметров ИБ.
// ИмяКонстанты - Строка - имя константы, которую необходимо добавить в
// параметры ИБ.
//
// Возвращаемое значение: 
// Строка таблицы значений.
// Строка содержащая описание добавленного параметра. 
// 
Функция ДобавитьКонстантуВТаблицуПараметровИБ(Знач ТаблицаПараметров, Знач ИмяКонстанты) Экспорт
	
	МетаданныеКонстанты = Метаданные.Константы[ИмяКонстанты];
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = МетаданныеКонстанты.Имя;
	СтрокаПараметра.Описание = МетаданныеКонстанты.Представление();
	СтрокаПараметра.Тип = МетаданныеКонстанты.Тип;
	
	Возврат СтрокаПараметра;
	
КонецФункции

// Возвращает таблицу описания параметров ИБ.
//
// Возвращаемое значение: 
// Таблица значений.
// Таблица описывающая параметры ИБ.
// Колонки:
// Имя - Строка - имя параметра.
// Описание - Строка - описание параметра для отображения в пользовательском интерфейсе.
// ЗапретЧтения - Булево - признак невозможности считывания параметра ИБ. Может установлен
//                         например для паролей.
// ЗапретЗаписи - Булево - признак невозможности изменения параметра ИБ.
// Тип - Описание типов - тип значения параметра. Допускается использовать только примитивные
//                         типы и перечисления присутствующие в управляющем приложении.
// 
Функция ПолучитьТаблицуПараметровИБ() Экспорт
	
	ТаблицаПараметров = ПолучитьПустуюТаблицуПараметровИБ();
	
	ПриЗаполненииТаблицыПараметровИБ(ТаблицаПараметров);
	
	РаботаВМоделиСервисаПереопределяемый.ПолучитьТаблицуПараметровИБ(ТаблицаПараметров);
	
	Возврат ТаблицаПараметров;
	
КонецФункции

// Получает имя приложения, так как его задал Абонент.
//
// Возвращаемое значение - Строка - имя приложения.
//
Функция ПолучитьИмяПриложения() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат Константы.ПредставлениеОбластиДанных.Получить();
	
КонецФункции

// Возвращает размер блоков в Мб для передачи больших файлов частями.
//
Функция ПолучитьРазмерБлокаПередачиФайла() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	РазмерБлокаПередачиФайла = Константы.РазмерБлокаПередачиФайла.Получить(); // Мб
	Если Не ЗначениеЗаполнено(РазмерБлокаПередачиФайла) Тогда
		РазмерБлокаПередачиФайла = 20;
	КонецЕсли;
	Возврат РазмерБлокаПередачиФайла;

КонецФункции

// Сериализует объект структурного типа.
//
// Параметры:
// ЗначениеСтруктурногоТипа - Массив, Структура, Соответствие или их фиксированные аналоги.
//
// Возвращаемое значение:
// Строка - Сериализованное значение объекта структурного типа.
//
Функция ЗаписатьСтруктурныйОбъектXDTOВСтроку(Знач ЗначениеСтруктурногоТипа) Экспорт
	
	ОбъектXDTO = СтруктурныйОбъектВОбъектXDTO(ЗначениеСтруктурногоТипа);
	
	Возврат ЗаписатьЗначениеВСтроку(ОбъектXDTO);
	
КонецФункции

// Кодирует строковое значение по алгоритму base64.
//
// Параметры:
// Строка - Строка.
//
// Возвращаемое значение:
// Строка - base64-представление.
//
Функция СтрокаВBase64(Знач Строка) Экспорт
	
	Хранилище = Новый ХранилищеЗначения(Строка, Новый СжатиеДанных(9));
	
	Возврат XMLСтрока(Хранилище);
	
КонецФункции

// Декодирует base64-представление строки в исходное значение.
//
// Параметры:
// СтрокаBase64 - Строка.
//
// Возвращаемое значение:
// Строка.
//
Функция Base64ВСтроку(Знач СтрокаBase64) Экспорт
	
	Хранилище = XMLЗначение(Тип("ХранилищеЗначения"), СтрокаBase64);
	
	Возврат Хранилище.Получить();
	
КонецФункции

// Возвращает часовой пояс области данных.
// Предназначена для вызова из сеансов с неустановленным использованием
// разделителей. В сеансах с установленным использованием разделителей
// следует использовать ПолучитьЧасовойПоясИнформационнойБазы().
//
// Параметры:
//  ОбластьДанных - Число - значение разделителя области данных, часовой
//   пояс которой требуется получить.
//
// Возвращаемое значение:
//  Строка, Неопределено - часовой пояс области данных, Неопределено
//   если часовой пояс не задан.
//
Функция ПолучитьЧасовойПоясОбластиДанных(Знач ОбластьДанных) Экспорт
	
	Менеджер = Константы.ЧасовойПоясОбластиДанных.СоздатьМенеджерЗначения();
	Менеджер.ОбластьДанныхВспомогательныеДанные = ОбластьДанных;
	Менеджер.Прочитать();
	ЧасовойПояс = Менеджер.Значение;
	
	Если Не ЗначениеЗаполнено(ЧасовойПояс) Тогда
		ЧасовойПояс = Неопределено;
	КонецЕсли;
	
	Возврат ЧасовойПояс;
	
КонецФункции

// Возвращает внутренний адрес менеджера сервиса.
//
// Возвращаемое значение:
//  Строка - внутренний адрес менеджера сервиса.
//
Функция ВнутреннийАдресМенеджераСервиса() Экспорт
	
	Возврат Константы.ВнутреннийАдресМенеджераСервиса.Получить();
	
КонецФункции

// Возвращает имя служебного пользователя менеджера сервиса.
//
// Возвращаемое значение:
//  Строка - имя служебного пользователя менеджера сервиса.
//
Функция ИмяСлужебногоПользователяМенеджераСервиса() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Владелец = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Константа.ВнутреннийАдресМенеджераСервиса");
	ИмяСлужебногоПользователя = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(Владелец, "ИмяСлужебногоПользователяМенеджераСервиса", Истина);
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат ИмяСлужебногоПользователя;
	
КонецФункции

// Возвращает пароль служебного пользователя менеджера сервиса.
//
// Возвращаемое значение:
//  Строка - пароль служебного пользователя менеджера сервиса.
//
Функция ПарольСлужебногоПользователяМенеджераСервиса() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Владелец = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Константа.ВнутреннийАдресМенеджераСервиса");
	ПарольСлужебногоПользователя = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(Владелец, "ПарольСлужебногоПользователяМенеджераСервиса", Истина);
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат ПарольСлужебногоПользователя;
	
КонецФункции

// Обрабатывает информация об ошибке полученную из web-сервиса.
// В случае если передана не пустая информация об ошибке, записывает
// подробное представление ошибки в журнал регистрации и вызывает
// исключение с текстом краткого представления об ошибке.
//
Процедура ОбработатьИнформациюОбОшибкеWebСервиса(Знач ИнформацияОбОшибке, Знач ИмяПодсистемы = "", Знач ИмяВебСервиса = "", Знач ИмяОперации = "") Экспорт
	
	Если ИнформацияОбОшибке = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустаяСтрока(ИмяПодсистемы) Тогда
		ИмяПодсистемы = Метаданные.Подсистемы.СтандартныеПодсистемы.Подсистемы.РаботаВМоделиСервиса.Имя;
	КонецЕсли;
	
	ИмяСобытия = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = '%1.Ошибка вызова операции web-сервиса'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
		ИмяПодсистемы);
	
	ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Ошибка при вызове операции %1 веб-сервиса %2: %3'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
		ИмяОперации,
		ИмяВебСервиса,
		ИнформацияОбОшибке.DetailErrorDescription);
	
	ЗаписьЖурналаРегистрации(
		ИмяСобытия,
		УровеньЖурналаРегистрации.Ошибка,
		,
		,
		ТекстОшибки);
		
	ВызватьИсключение ИнформацияОбОшибке.BriefErrorDescription;
	
КонецПроцедуры

// Возвращает псевдоним пользователя, который должен использоваться в интерфейсе.
//
// Параметры:
//  ИдентификаторПользователя - УникальныйИдентификатор.
//
// Возвращаемое значение: Строка, псевдоним пользователя информационной базы
//  для отображения в интерфейсе.
//
Функция ПсевдонимПользователяИнформационнойБазы(Знач ИдентификаторПользователя) Экспорт
	
	Псевдоним = "";
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриОпределенииПсевдонимаПользователя");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриОпределенииПсевдонимаПользователя(ИдентификаторПользователя, Псевдоним);
	КонецЦикла;
	
	Возврат Псевдоним;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с файлами

// Возвращает полное имя файла, полученного из файлового хранилища МС по его идентификатору.
//
// Параметры:
// ИДФайла - УникальныйИдентификатор - Идентификатор файла в файловом хранилище МС.
//
// Возвращаемое значение:
// Строка - Полное имя извлеченного файла.
//
Функция ПолучитьФайлИзХранилищаМенеджераСервиса(Знач ИДФайла) Экспорт
	
	АдресМенеджераСервиса = ВнутреннийАдресМенеджераСервиса();
	Если Не ЗначениеЗаполнено(АдресМенеджераСервиса) Тогда
		ВызватьИсключение(НСтр("ru = 'Не установлены параметры связи с менеджером сервиса.'"));
	КонецЕсли;
	
	ПараметрыДоступаКХранилищу = Новый Структура;
	ПараметрыДоступаКХранилищу.Вставить("URL", АдресМенеджераСервиса);
	ПараметрыДоступаКХранилищу.Вставить("UserName", ИмяСлужебногоПользователяМенеджераСервиса());
	ПараметрыДоступаКХранилищу.Вставить("Password", ПарольСлужебногоПользователяМенеджераСервиса());
	
	ОписаниеФайла = ПолучитьФайлИзХранилища(ИДФайла, ПараметрыДоступаКХранилищу, Истина, Истина);
	Если ОписаниеФайла = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СвойстваФайла = Новый Файл(ОписаниеФайла.ПолноеИмя);
	Если Не СвойстваФайла.Существует() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Менеджер сервиса устанавливает исходному файлу атрибут "Только чтение".
	// Унаследованный атрибут снимается, чтобы файл можно было удалить.
	СвойстваФайла.УстановитьТолькоЧтение(Ложь);	
	
	Возврат СвойстваФайла.ПолноеИмя;
	
КонецФункции

// Добавляет файл в хранилище менеджера сервиса.
//
// Параметры:
// АдресДанныеФайл - Строка/ДвоичныеДанные/Файл - Адрес временного хранилища/Данные файла/Файл.
// ИмяФайла - Строка - Хранимое имя файла. 
//		
// Возвращаемое значение:
// УникальныйИдентификатор - Идентификатор файла в хранилище.
//
Функция ПоместитьФайлВХранилищеМенеджераСервиса(Знач АдресДанныеФайл, Знач ИмяФайла = "") Экспорт
	
	ПараметрыДоступаКХранилищу = Новый Структура;
	ПараметрыДоступаКХранилищу.Вставить("URL", ВнутреннийАдресМенеджераСервиса());
	ПараметрыДоступаКХранилищу.Вставить("UserName", ИмяСлужебногоПользователяМенеджераСервиса());
	ПараметрыДоступаКХранилищу.Вставить("Password", ПарольСлужебногоПользователяМенеджераСервиса());
	
	Возврат ПоместитьФайлВХранилище(АдресДанныеФайл, ПараметрыДоступаКХранилищу, ИмяФайла);

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции определения типов объектов метаданных по полному имени объекта
// метаданных.

// Ссылочные типы данных

// Определяет принадлежность объекта метаданных к общему типу "Документ" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяДокумента(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Документ", "Document");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Справочник" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяСправочника(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Справочник", "Catalog");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Перечисление" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяПеречисления(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Перечисление", "Enum");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План обмена" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяПланаОбмена(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ПланОбмена", "ExchangePlan");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов характеристик" по
//  полному имени объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяПланаВидовХарактеристик(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ПланВидовХарактеристик", "ChartOfCharacteristicTypes");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Бизнес-процесс" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяБизнесПроцесса(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "БизнесПроцесс", "BusinessProcess");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Задача" по полному имени объекта
//  метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
// 
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяЗадачи(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Задача", "Task");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План счетов" по полному имени объекта
//  метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяПланаСчетов(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ПланСчетов", "ChartOfAccounts");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов расчета" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяПланаВидовРасчета(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ПланВидовРасчета", "ChartOfCalculationTypes");
	
КонецФункции

// Регистры

// Определяет принадлежность объекта метаданных к общему типу "Регистр сведений" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяРегистраСведений(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегистрСведений", "InformationRegister");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр накопления" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяРегистраНакопления(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегистрНакопления", "AccumulationRegister");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр бухгалтерии" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяРегистраБухгалтерии(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегистрБухгалтерии", "AccountingRegister");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр расчета" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяРегистраРасчета(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегистрРасчета", "CalculationRegister")
		И Не ЭтоПолноеИмяПерерасчета(ПолноеИмя);
	
КонецФункции

// Перерасчеты

// Определяет принадлежность объекта метаданных к типу "Перерасчет" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяПерерасчета(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Перерасчет", "Recalculation", 2);
	
КонецФункции

// Константы

// Определяет принадлежность объекта метаданных к общему типу "Константа" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяКонстанты(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Константа", "Constant");
	
КонецФункции

// Журналы документов

// Определяет принадлежность объекта метаданных к общему типу "Журнал документов" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяЖурналаДокументов(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ЖурналДокументов", "DocumentJournal");
	
КонецФункции

// Последовательности

// Определяет принадлежность объекта метаданных к общему типу "Последовательности" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяПоследовательности(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Последовательность", "Sequence");
	
КонецФункции

// РегламентныеЗадания

// Определяет принадлежность объекта метаданных к общему типу "Регламентные задания" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяРегламентногоЗадания(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегламентноеЗадание", "ScheduledJob");
	
КонецФункции

// Общие

// Определяет принадлежность объекта метаданных к типу регистр по полному имени объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяРегистра(Знач ПолноеИмя) Экспорт
	
	Возврат ЭтоПолноеИмяРегистраСведений(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяРегистраНакопления(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяРегистраБухгалтерии(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяРегистраРасчета(ПолноеИмя);
	
КонецФункции

// Определяет принадлежность объекта метаданных к ссылочному типу по полному имени объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоПолноеИмяОбъектаСсылочногоТипа(Знач ПолноеИмя) Экспорт
	
	Возврат ЭтоПолноеИмяСправочника(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяДокумента(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяБизнесПроцесса(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяЗадачи(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяПланаСчетов(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяПланаОбмена(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяПланаВидовХарактеристик(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяПланаВидовРасчета(ПолноеИмя);
	
КонецФункции

// Для внутреннего использования.
//
Функция ПараметрыВыборки(Знач ПолноеИмяОбъектаМетаданных) Экспорт
	
	Результат = Новый Структура("Таблица,ИмяПоляРегистратор");
	
	Если ЭтоПолноеИмяРегистра(ПолноеИмяОбъектаМетаданных)
			ИЛИ ЭтоПолноеИмяПоследовательности(ПолноеИмяОбъектаМетаданных) Тогда
		
		Результат.Таблица = ПолноеИмяОбъектаМетаданных;
		Результат.ИмяПоляРегистратор = "Регистратор";
		
	ИначеЕсли ЭтоПолноеИмяПерерасчета(ПолноеИмяОбъектаМетаданных) Тогда
		
		Подстроки = СтрРазделить(ПолноеИмяОбъектаМетаданных, ".");
		Результат.Таблица = Подстроки[0] + "." + Подстроки[1] + "." + Подстроки[3];
		Результат.ИмяПоляРегистратор = "ОбъектПерерасчета";
		
	Иначе
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Функция ПараметрыВыборки() не должна использоваться для объекта %1.'"),
			ПолноеИмяОбъектаМетаданных);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Для внутреннего использования.
//
Функция СобытиеЖурналаРегистрацииКопированиеОбластиДанных() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Копирование области данных'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка());
	
КонецФункции

// Для внутреннего использования.
//
Функция СобытиеЖурналаРегистрацииБлокировкаОбластиДанных() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Блокировка области данных'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка());
	
КонецФункции

// Для внутреннего использования.
//
Функция СобытиеЖурналаРегистрацииПодготовкаОбластиДанных() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Подготовка области данных'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка());
	
КонецФункции

// Для внутреннего использования.
//
Функция СобытиеЖурналаРегистрацииПолучениеФайлаИзХранилища() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Получение файла из хранилища'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка());
	
КонецФункции

// Для внутреннего использования.
//
Функция СобытиеЖурналаРегистрацииДобавлениеФайлаОбменЧерезФС() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Добавление файла.Обмен через ФС'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка());
	
КонецФункции

// Для внутреннего использования.
//
Функция СобытиеЖурналаРегистрацииДобавлениеФайлаОбменНеЧерезФС() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Добавление файла.Обмен не через ФС'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка());
	
КонецФункции

// Для внутреннего использования.
//
Функция СобытиеЖурналаРегистрацииУдалениеВременногоФайла() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Удаление временного файла'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка());
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Вызовы в другие подсистемы

// Формирует список параметров ИБ.
//
// Параметры:
// ТаблицаПараметров - ТаблицаЗначений - таблица описания параметров.
// Описание состав колонок - см. РаботаВМоделиСервиса.ПолучитьТаблицуПараметровИБ().
//
Процедура ПриЗаполненииТаблицыПараметровИБ(Знач ТаблицаПараметров) Экспорт
	
	Если ОбщегоНазначенияПовтИсп.ЭтоРазделеннаяКонфигурация() Тогда
		ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "ИспользоватьРазделениеПоОбластямДанных");
		
		ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "РежимИспользованияИнформационнойБазы");
		
		ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "КопироватьОбластиДанныхИзЭталонной");
	КонецЕсли;
	
	ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "ВнутреннийАдресМенеджераСервиса");
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = "ИмяСлужебногоПользователяМенеджераСервиса";
	СтрокаПараметра.Описание = "ИмяСлужебногоПользователяМенеджераСервиса";
	СтрокаПараметра.Тип = Новый ОписаниеТипов("Строка");
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = "ПарольСлужебногоПользователяМенеджераСервиса";
	СтрокаПараметра.Описание = "ПарольСлужебногоПользователяМенеджераСервиса";
	СтрокаПараметра.Тип = Новый ОписаниеТипов("Строка");
	СтрокаПараметра.ЗапретЧтения = Истина;
	
	// Для совместимости с предыдущими версиями.
	СтрокаПараметра = ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "ВнутреннийАдресМенеджераСервиса");
	СтрокаПараметра.Имя = "URLСервиса";
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = "ИмяСлужебногоПользователяСервиса";
	СтрокаПараметра.Описание = "ИмяСлужебногоПользователяСервиса";
	СтрокаПараметра.Тип = Новый ОписаниеТипов("Строка");
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = "ПарольСлужебногоПользователяСервиса";
	СтрокаПараметра.Описание = "ПарольСлужебногоПользователяСервиса";
	СтрокаПараметра.Тип = Новый ОписаниеТипов("Строка");
	СтрокаПараметра.ЗапретЧтения = Истина;
	// Конец Для совместимости с предыдущими версиями.
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = "ВерсияКонфигурации";
	СтрокаПараметра.Описание = НСтр("ru = 'Версия конфигурации'");
	СтрокаПараметра.ЗапретЗаписи = Истина;
	СтрокаПараметра.Тип = Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная));
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриЗаполненииТаблицыПараметровИБ");
	
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриЗаполненииТаблицыПараметровИБ(ТаблицаПараметров);
	КонецЦикла;
	
КонецПроцедуры

// Получает описание файла по его идентификатору в регистре Файлы.
// Если хранение на диске и ПутьВместоДанных = Истина, 
// в выходной структуре Данные = Неопределено, ПолноеИмя = Полное имя файла,
// иначе Данные - двоичные данные файла, ПолноеИмя - Неопределено.
// Значение ключа Имя всегда содержит имя в хранилище.
//
// Параметры:
// ИдентификаторФайла - УникальныйИдентификатор.
// ПараметрыПодключения - Структура:
//							- URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//							- UserName - Строка - Имя пользователя сервиса.
//							- Password - Строка - Пароль пользователя сервиса.
// ПутьВместоДанных - Булево - Что возвращать. 
// ПроверятьСуществование - Булево - Проверять ли существования файла в случае ошибки его получения.
//		
// Возвращаемое значение:
// ОписаниеФайла - Структура:
//	Имя - Строка - имя файла в хранилище.
//	Данные - ДвоичныеДанные - данные файла.
//	ПолноеИмя - Строка - полное имя файла.
//			  - Файл будет удален автоматически по истечении срока хранения временных файлов.
//
Функция ПолучитьФайлИзХранилища(Знач ИдентификаторФайла, Знач ПараметрыПодключения, 
	Знач ПутьВместоДанных = Ложь, Знач ПроверятьСуществование = Ложь) Экспорт
	
	НачалоВыполнения = ТекущаяУниверсальнаяДата();
	
	ОписаниеПрокси = ОписаниеПроксиСервисаПередачиФайлов(ПараметрыПодключения);
	
	ОбменЧерезФС = МожноПередаватьЧерезФСССервера(ОписаниеПрокси.Прокси, ОписаниеПрокси.ЕстьПоддержка2йВерсии);
	
	Если ОбменЧерезФС Тогда
			
		Попытка
			Попытка
				ИмяФайла = ОписаниеПрокси.Прокси.WriteFileToFS(ИдентификаторФайла);
			Исключение
				ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				Если ПроверятьСуществование И Не ОписаниеПрокси.Прокси.FileExists(ИдентификаторФайла) Тогда
					Возврат Неопределено;
				КонецЕсли;
				ВызватьИсключение ОписаниеОшибки;
			КонецПопытки;
			
			СвойстваФайла = Новый Файл(ПолучитьОбщийКаталогВременныхФайлов() + ИмяФайла);
			Если СвойстваФайла.Существует() Тогда
				ОписаниеФайла = СоздатьОписаниеФайла();
				ОписаниеФайла.Имя = СвойстваФайла.Имя;
				
				РазмерПолученногоФайла = СвойстваФайла.Размер();
				
				Если ПутьВместоДанных Тогда
					ОписаниеФайла.Данные = Неопределено;
					ОписаниеФайла.ПолноеИмя = СвойстваФайла.ПолноеИмя;
				Иначе
					ОписаниеФайла.Данные = Новый ДвоичныеДанные(СвойстваФайла.ПолноеИмя);
					ОписаниеФайла.ПолноеИмя = Неопределено;
					Попытка
						УдалитьФайлы(СвойстваФайла.ПолноеИмя);
					Исключение
						ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПолучениеФайлаИзХранилища(),
							УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
					КонецПопытки;
				КонецЕсли;
				
				ЗаписатьВЖурналСобытиеФайловогоХранилища(
					НСтр("ru = 'Извлечение'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					ИдентификаторФайла,
					РазмерПолученногоФайла,
					ТекущаяУниверсальнаяДата() - НачалоВыполнения,
					ОбменЧерезФС);
				
				Возврат ОписаниеФайла;
			Иначе
				ОбменЧерезФС = Ложь;
			КонецЕсли;
		Исключение
			ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПолучениеФайлаИзХранилища(),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ОбменЧерезФС = Ложь;
		КонецПопытки;
			
	КонецЕсли; // ОбменЧерезФС
	
	КоличествоЧастей = Неопределено;
	ИмяФайлаВСправочнике = Неопределено;
	РазмерБлокаПередачиФайла = ПолучитьРазмерБлокаПередачиФайла();
	Попытка
		Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
			ИдентификаторПередачи = ОписаниеПрокси.Прокси.PrepareGetFile(ИдентификаторФайла, РазмерБлокаПередачиФайла * 1024, КоличествоЧастей);
		Иначе
			ИдентификаторПередачи = Неопределено;
			ОписаниеПрокси.Прокси.PrepareGetFile(ИдентификаторФайла, РазмерБлокаПередачиФайла * 1024, ИдентификаторПередачи, КоличествоЧастей);
		КонецЕсли;
	Исключение
		ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Если ПроверятьСуществование И Не ОписаниеПрокси.Прокси.FileExists(ИдентификаторФайла) Тогда
			Возврат Неопределено;
		КонецЕсли;
		ВызватьИсключение ОписаниеОшибки;
	КонецПопытки;
	
	ИменаФайлов = Новый Массив;
	
	КаталогСборки = СоздатьКаталогСборки();
	
	Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
		Для НомерЧасти = 1 По КоличествоЧастей Цикл
			ДанныеЧасти = ОписаниеПрокси.Прокси.GetFilePart(ИдентификаторПередачи, НомерЧасти, КоличествоЧастей);
			ИмяФайлаЧасти = КаталогСборки + "part" + Формат(НомерЧасти, "ЧЦ=4; ЧВН=; ЧГ=");
			ДанныеЧасти.Записать(ИмяФайлаЧасти);
			ИменаФайлов.Добавить(ИмяФайлаЧасти);
		КонецЦикла;
	Иначе // 1-я версия.
		Для НомерЧасти = 1 По КоличествоЧастей Цикл
			ДанныеЧасти = Неопределено;
			ОписаниеПрокси.Прокси.GetFilePart(ИдентификаторПередачи, НомерЧасти, ДанныеЧасти);
			ИмяФайлаЧасти = КаталогСборки + "part" + Формат(НомерЧасти, "ЧЦ=4; ЧВН=; ЧГ=");
			ДанныеЧасти.Записать(ИмяФайлаЧасти);
			ИменаФайлов.Добавить(ИмяФайлаЧасти);
		КонецЦикла;
	КонецЕсли;
	ДанныеЧасти = Неопределено;
	
	ОписаниеПрокси.Прокси.ReleaseFile(ИдентификаторПередачи);
	
	ИмяАрхива = ПолучитьИмяВременногоФайла("zip");
	
	Попытка
	
		ОбъединитьФайлы(ИменаФайлов, ИмяАрхива);
		ФайлОбъединен = Истина;
		
	Исключение
		
		ФайлОбъединен = Ложь;
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Выполнение операции объединения файлов'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			
	КонецПопытки;
	
	Если ФайлОбъединен Тогда
		
		Попытка
		
			ЧтениеZipФайла = Новый ЧтениеZipФайла(ИмяАрхива);
			ПрочитанZipФайл = Истина;
			
		Исключение
			
			ПрочитанZipФайл = Ложь;
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Выполнение операции чтения zip файла'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				
		КонецПопытки;
		
		Если ПрочитанZipФайл Тогда
			
			ВПолученномАрхивеБолееОдногоФайла = ЧтениеZipФайла.Элементы.Количество() > 1;
			
			Если НЕ ВПолученномАрхивеБолееОдногоФайла Тогда
				
				ИмяФайла = КаталогСборки + ЧтениеZipФайла.Элементы[0].Имя;
				ЧтениеZipФайла.Извлечь(ЧтениеZipФайла.Элементы[0], КаталогСборки);
				ЧтениеZipФайла.Закрыть();
				
				ФайлРезультата = Новый Файл(ПолучитьИмяВременногоФайла());
				ПереместитьФайл(ИмяФайла, ФайлРезультата.ПолноеИмя);
				РазмерПолученногоФайла = ФайлРезультата.Размер();
				
				ОписаниеФайла = СоздатьОписаниеФайла();
				ОписаниеФайла.Имя = ФайлРезультата.Имя;
				
				Если ПутьВместоДанных Тогда
					
					ОписаниеФайла.Данные = Неопределено;
					ОписаниеФайла.ПолноеИмя = ФайлРезультата.ПолноеИмя;
					
				Иначе
					
					ОписаниеФайла.Данные = Новый ДвоичныеДанные(ФайлРезультата.ПолноеИмя);
					ОписаниеФайла.ПолноеИмя = Неопределено;
					
					Попытка
						
						УдалитьФайлы(ФайлРезультата.ПолноеИмя);
						
					Исключение
						
						ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПолучениеФайлаИзХранилища(),
							УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
							
					КонецПопытки;
						
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ФайлВременный = Новый Файл(ИмяАрхива);
	
	Если ФайлВременный.Существует() Тогда
		
		Попытка
			
			ФайлВременный.УстановитьТолькоЧтение(Ложь);
			УдалитьФайлы(ИмяАрхива);
			
		Исключение
			
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Выполнение операции удаления временного файла'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				
		КонецПопытки;
		
	КонецЕсли;
	
	Попытка
		
		УдалитьФайлы(КаталогСборки);
		
	Исключение
		
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПолучениеФайлаИзХранилища(),
			УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			
	КонецПопытки;
		
	Если НЕ ПрочитанZipФайл Тогда
		
		ВызватьИсключение(НСтр("ru = 'При чтении zip файла произошла ошибка.'"));
		
	КонецЕсли;
	
	Если ВПолученномАрхивеБолееОдногоФайла Тогда
		
		ВызватьИсключение(НСтр("ru = 'В полученном архиве содержится более одного файла.'"));
		
	КонецЕсли;
	
	ЗаписатьВЖурналСобытиеФайловогоХранилища(
		НСтр("ru = 'Извлечение'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
		ИдентификаторФайла,
		РазмерПолученногоФайла,
		ТекущаяУниверсальнаяДата() - НачалоВыполнения,
		ОбменЧерезФС);
	
	Возврат ОписаниеФайла;
	
КонецФункции

// Записывает тестовый файл на диск, возвращая его имя и размер.
// Файл должна удалять вызывающая сторона.
//
// Параметры:
// РазмерФайла - Число.
//
// Возвращаемое значение:
// Строка - Имя пробного файла без пути.
//
Функция ЗаписатьПробныйФайл() Экспорт
	
	НовыйИД = Новый УникальныйИдентификатор;
	СвойстваФайла = Новый Файл(ПолучитьОбщийКаталогВременныхФайлов() + НовыйИД + ".tmp");
	
	Текст = Новый ЗаписьТекста(СвойстваФайла.ПолноеИмя, КодировкаТекста.ANSI);
	Текст.Записать(НовыйИД);
	Текст.Закрыть();
	
	Возврат СвойстваФайла.Имя;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в другие подсистемы.

// Дополнительные действия, выполняемые при изменении разделения сеанса.
//
Процедура ПриИзмененииОбластиДанных() Экспорт
	
	ОчиститьВсеПараметрыСеансаКромеРазделителей();
	
	Если НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Возврат;
		
	КонецЕсли;
	
	// Пустой список пользователей или фоновое задание из регламентного.
	// В этом случае авторизовать пользователя не требуется.
	Если ПользователиИнформационнойБазы.ТекущийПользователь().Имя = "" Тогда
	   
	   Возврат;
	   
	КонецЕсли;

	МенеджерЗаписи = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Прочитать();
	
	Если МенеджерЗаписи.Выбран() Тогда
		
		Если НЕ (МенеджерЗаписи.ОшибкаОбработки
			ИЛИ МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.КУдалению
			ИЛИ МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.Удалена) Тогда
	
			ПользователиСлужебный.АвторизоватьТекущегоПользователя();
		
		КонецЕсли;
		
	Иначе
		
		ПользователиСлужебный.АвторизоватьТекущегоПользователя();
		
	КонецЕсли;
		
КонецПроцедуры

// Регистрирует обработчики поставляемых данных за день и за все время.
//
Процедура ЗарегистрироватьОбработчикиПоставляемыхДанных(Знач Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.ВидДанных = "ЭталонОбластиДанных";
	Обработчик.КодОбработчика = "ЭталонОбластиДанных";
	Обработчик.Обработчик = РаботаВМоделиСервиса;
	
КонецПроцедуры

// Вызывается при получении уведомления о новых данных.
// В теле следует проверить, необходимы ли эти данные приложению, 
// и если да - установить флажок Загружать.
// 
// Параметры:
//   Дескриптор   - ОбъектXDTO Descriptor.
//   Загружать    - булево, возвращаемое.
//
Процедура ДоступныНовыеДанные(Знач Дескриптор, Загружать) Экспорт
	
	Если Дескриптор.DataType = "ЭталонОбластиДанных" Тогда
		Для каждого Характеристика Из Дескриптор.Properties.Property Цикл
			Если Характеристика.Code = "ИмяКонфигурации" И Характеристика.Value = Метаданные.Имя Тогда
				Загружать = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
		
КонецПроцедуры

// Вызывается после вызова ДоступныНовыеДанные, позволяет разобрать данные.
//
// Параметры:
//   Дескриптор   - ОбъектXDTO Дескриптор.
//   ПутьКФайлу   - Строка или Неопределено. Полное имя извлеченного файла. Файл будет автоматически удален 
//                  после завершения процедуры. Если в менеджере сервиса не был
//                  указан файл - значение аргумента равно Неопределено.
//
Процедура ОбработатьНовыеДанные(Знач Дескриптор, Знач ПутьКФайлу) Экспорт
	
	Если Дескриптор.DataType = "ЭталонОбластиДанных" Тогда
		ОбработатьПоставляемыйЭталонКонфигурации(Дескриптор, ПутьКФайлу);
	КонецЕсли;
	
КонецПроцедуры

// Вызывается при отмене обработки данных в случае сбоя.
//
Процедура ОбработкаДанныхОтменена(Знач Дескриптор) Экспорт 
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Параметры:
//  ЗаданиеМетаданные - ОбъектМетаданных - метаданные предопределенного регламентного задания.
//  Использование     - Булево - Истина, если задание нужно включить, иначе Ложь.
//
Процедура УстановитьИспользованиеПредопределенногоРегламентногоЗадания(ЗаданиеМетаданные, Использование) Экспорт
	
	Шаблон = ОчередьЗаданий.ШаблонПоИмени(ЗаданиеМетаданные.Имя);
	
	ОтборЗадания = Новый Структура;
	ОтборЗадания.Вставить("Шаблон", Шаблон);
	Задания = ОчередьЗаданий.ПолучитьЗадания(ОтборЗадания);
	
	ПараметрыЗадания = Новый Структура("Использование", Использование);
	ОчередьЗаданий.ИзменитьЗадание(Задания[0].Идентификатор, ПараметрыЗадания);
	
КонецПроцедуры

// Проверяет возможность использования конфигурации в модели сервиса.
//  При невозможности использования - генерируется исключение с указанием причины,
//  из-за которой использование конфигурации в модели сервиса невозможно.
//
Процедура ПроверитьВозможностьИспользованияКонфигурацииВМоделиСервиса() Экспорт
	
	ОписанияПодсистем = СтандартныеПодсистемыПовтИсп.ОписанияПодсистем().ПоИменам;
	ОписаниеБТС = ОписанияПодсистем.Получить("БиблиотекаТехнологииСервиса");
	
	Если ОписаниеБТС = Неопределено Тогда
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В конфигурацию не внедрена библиотека ""1С:Библиотека технологии сервиса"".
                  |Без внедрения этой библиотеки конфигурация не может использоваться в модели сервиса.
                  |
                  |Для использования этой конфигурации в модели сервиса требуется внедрить библиотеку
                  |""1С:Библиотека технологии сервиса"" версии не младше %1!'", Метаданные.ОсновнойЯзык.КодЯзыка),
			ТребуемаяВерсияБТС());
		
	Иначе
		
		ВерсияБТС = ОписаниеБТС.Версия;
		
		Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияБТС, ТребуемаяВерсияБТС()) < 0 Тогда
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Для использования конфигурации в модели сервиса с текущей версией БСП требуется
                      |обновить используемую версию библиотеки ""1С:Библиотека технологии сервиса""!
                      |
                      |Используемая версия: %1, требуется версия не младше %2!'", Метаданные.ОсновнойЯзык.КодЯзыка),
				ВерсияБТС, ТребуемаяВерсияБТС());
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Вызывает исключение при отсутствии требуемой подсистемы из библиотеки технологии сервиса.
//
// Параметры:
//  ИмяПодсистемы - Строка.
//
Процедура ВызватьИсключениеОтсутствуетПодсистемаБТС(Знач ИмяПодсистемы) Экспорт
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Невозможно выполнить операцию по причине - в конфигурации не внедрена подсистема ""%1"".
              |Данная подсистема поставляется в состав библиотеки технологии сервиса, которая должна отдельно внедряться в состав конфигурации.
              |Проверьте наличие и корректность внедрения подсистемы ""%1"".'"),
		ИмяПодсистемы);
	
КонецПроцедуры

// Объявляет события подсистемы РаботаВМоделиСервиса:
//
// Серверные события:
//   ПриУдаленииОбластиДанных,
//   ПриПолученииТаблицыПараметровИБ,
//   ПриУстановкеЗначенийПараметровИБ,
//   ПриЗаполненииТаблицыПараметровИБ,
//   ПриУстановкеПравПоУмолчанию,
//   ПослеЗагрузкиДанныхИзДругойМодели.
//
// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииСлужебныхСобытий(КлиентскиеСобытия, СерверныеСобытия) Экспорт
	
	// СЕРВЕРНЫЕ СОБЫТИЯ.
	
	// Вызывается при удалении области данных.
	// В процедуре необходимо удалить данные области данных, которые не
	// могут быть удалены стандартным механизмом.
	//
	// Параметры:
	// ОбластьДанных - Тип значения разделителя - значение разделителя
	// удаляемой области данных.
	//
	// Синтаксис:
	// Процедура ПриУдаленииОбластиДанных(Знач ОбластьДанных) Экспорт
	//
	// (То же, что РаботаВМоделиСервисаПереопределяемый.ПриУдаленииОбластиДанных).
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриУдаленииОбластиДанных");
	
	// Формирует список параметров ИБ.
	//
	// Параметры:
	// ТаблицаПараметров - ТаблицаЗначений - таблица описания параметров.
	// Описание состав колонок - см. РаботаВМоделиСервиса.ПолучитьТаблицуПараметровИБ().
	//
	// Синтаксис:
	// Процедура ПриПолученииТаблицыПараметровИБ(Знач ТаблицаПараметров) Экспорт
	//
	// (То же, что РаботаВМоделиСервисаПереопределяемый.ПолучитьТаблицуПараметровИБ).
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриПолученииТаблицыПараметровИБ");
	
	// Вызывается перед попыткой записи значений параметров ИБ в одноименные
	// константы.
	//
	// Параметры:
	// ЗначенияПараметров - Структура - значения параметров которые требуется установить.
	// В случае если значение параметра устанавливается в данной процедуре из структуры
	// необходимо удалить соответствующую пару КлючИЗначение.
	//
	// Синтаксис:
	// Процедура ПриУстановкеЗначенийПараметровИБ(Знач ЗначенияПараметров) Экспорт
	//
	// (То же, что РаботаВМоделиСервисаПереопределяемый.ПриУстановкеЗначенийПараметровИБ).
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриУстановкеЗначенийПараметровИБ");
	
	// Формирует список параметров ИБ.
	//
	// Параметры:
	// ТаблицаПараметров - ТаблицаЗначений - таблица описания параметров.
	// Описание состав колонок - см. РаботаВМоделиСервиса.ПолучитьТаблицуПараметровИБ().
	//
	// Синтаксис:
	// Процедура ПриЗаполненииТаблицыПараметровИБ(Знач ТаблицаПараметров) Экспорт
	//
	// Для использования в других библиотеках.
	//
	// (То же, что РаботаВМоделиСервисаПереопределяемый.ПолучитьТаблицуПараметровИБ).
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриЗаполненииТаблицыПараметровИБ");
	
	// Устанавливает пользователю права по умолчанию.
	// Вызывается при работе в модели сервиса, в случае обновления в менеджере
	// сервиса прав пользователя без прав администрирования.
	//
	// Параметры:
	//  Пользователь - СправочникСсылка.Пользователи - пользователь, которому
	//   требуется установить права по умолчанию.
	//
	// Синтаксис:
	// Процедура ПриУстановкеПравПоУмолчанию(Пользователь) Экспорт
	//
	// (То же, что РаботаВМоделиСервисаПереопределяемый.УстановитьПраваПоУмолчанию).
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриУстановкеПравПоУмолчанию");
	
	// Вызывается при определении псевдонима пользователя для отображения в интерфейсе.
	//
	// Параметры:
	//  ИдентификаторПользователя - УникальныйИдентификатор,
	//  Псевдоним - Строка, псевдоним пользователя.
	//
	// Синтаксис:
	// Процедура ПриОпределенииПсевдонимаПользователя(ИдентификаторПользователя, Псевдоним) Экспорт
	//
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриОпределенииПсевдонимаПользователя");
		
	// Вызывается при определении списка метаданных, которые являются не разделенными
	// и которые можно записывать из разделенного сеанса. Процедура должна в массив Исключения добавить ссылки
	// на исключаемые при проверке объекты метаданных. Эти метаданные могут отсутствовать в подписках, которые
	// проверяют запрет на запись неразделенных данных из разделенного сеанса.
	
	// Синтаксис:
	// Процедура ПриОпределенииИсключенийНеразделенныхДанных(Исключения)
		
	СерверныеСобытия.Добавить(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриОпределенииИсключенийНеразделенныхДанных");
	
КонецПроцедуры

// См. описание этой же процедуры в модуле СтандартныеПодсистемыСервер.
Процедура ПриДобавленииОбработчиковСлужебныхСобытий(КлиентскиеОбработчики, СерверныеОбработчики) Экспорт
	
	// СЕРВЕРНЫЕ ОБРАБОТЧИКИ.
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса.ПоставляемыеДанные") Тогда
		СерверныеОбработчики[
			"СтандартныеПодсистемы.РаботаВМоделиСервиса.ПоставляемыеДанные\ПриОпределенииОбработчиковПоставляемыхДанных"].Добавить(
				"РаботаВМоделиСервиса");
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий") Тогда
		СерверныеОбработчики[
			"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриОпределенииПсевдонимовОбработчиков"].Добавить(
				"РаботаВМоделиСервиса");
	
		СерверныеОбработчики[
			"СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий\ПриОпределенииИспользованияРегламентныхЗаданий"].Добавить(
				"РаботаВМоделиСервиса");
	КонецЕсли;
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления"].Добавить(
			"РаботаВМоделиСервиса");
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриВключенииРазделенияПоОбластямДанных"].Добавить(
			"РаботаВМоделиСервиса");
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииПараметровРаботыКлиентаПриЗапуске"].Добавить(
			"РаботаВМоделиСервиса");
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииПараметровРаботыКлиента"].Добавить(
			"РаботаВМоделиСервиса");
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.ВыгрузкаЗагрузкаДанных") Тогда
		СерверныеОбработчики[
			"ТехнологияСервиса.ВыгрузкаЗагрузкаДанных\ПриЗаполненииТиповИсключаемыхИзВыгрузкиЗагрузки"].Добавить(
				"РаботаВМоделиСервиса");
		СерверныеОбработчики[
			"ТехнологияСервиса.ВыгрузкаЗагрузкаДанных\ПослеЗагрузкиДанных"].Добавить(
				"РаботаВМоделиСервиса");
	КонецЕсли;
	
	СерверныеОбработчики[
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриУстановкеЗначенийПараметровИБ"].Добавить(
			"РаботаВМоделиСервиса");
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в эту подсистему.

// Заполняет соответствие имен методов их псевдонимам для вызова из очереди заданий.
//
// Параметры:
//  СоответствиеИменПсевдонимам - Соответствие
//   Ключ - Псевдоним метода, например ОчиститьОбластьДанных.
//   Значение - Имя метода для вызова, например РаботаВМоделиСервиса.ОчиститьОбластьДанных.
//    В качестве значения можно указать Неопределено, в этом случае считается что имя 
//    совпадает с псевдонимом.
//
Процедура ПриОпределенииПсевдонимовОбработчиков(СоответствиеИменПсевдонимам) Экспорт
	
	СоответствиеИменПсевдонимам.Вставить("РаботаВМоделиСервиса.ПодготовитьОбластьДанныхКИспользованию");
	
	СоответствиеИменПсевдонимам.Вставить("РаботаВМоделиСервиса.ОчиститьОбластьДанных");
	
КонецПроцедуры

// Формирует таблицу регламентных заданий
// с признаком использования в модели сервиса.
//
// Параметры:
// ТаблицаИспользования - ТаблицаЗначений - таблица, которую необходимо 
// заполнить регламентными заданиями и признаком использования, колонки:
//  РегламентноеЗадание - Строка - имя предопределенного регламентного задания.
//  Использование - Булево - Истина, если регламентное задание должно
//   выполняться в модели сервиса. Ложь - если не должно.
//
Процедура ПриОпределенииИспользованияРегламентныхЗаданий(ТаблицаИспользования) Экспорт
	
	НоваяСтрока = ТаблицаИспользования.Добавить();
	НоваяСтрока.РегламентноеЗадание = "ОбслуживаниеОбластейДанных";
	НоваяСтрока.Использование       = Истина;
	
КонецПроцедуры

// Определить список справочников, доступных для загрузки с помощью подсистемы "Загрузка данных из файла".
//
// Параметры:
//  ЗагружаемыеСправочники - ТаблицаЗначений - список справочников, в которые возможна загрузка данных.
//      * ПолноеИмя          - Строка - полное имя справочника (как в метаданных).
//      * Представление      - Строка - представление справочника в списке выбора.
//      * ПрикладнаяЗагрузка - Булево - если Истина, значит справочник использует собственный алгоритм загрузки и
//                                      в модуле менеджера справочника определены функции.
//
Процедура ПриОпределенииСправочниковДляЗагрузкиДанных(ЗагружаемыеСправочники) Экспорт
	
	// Загрузка в классификатор валюты запрещена.
	СтрокаТаблицы = ЗагружаемыеСправочники.Найти(Метаданные.Справочники.ОчередьЗаданийОбластейДанных.ПолноеИмя(), "ПолноеИмя");
	Если СтрокаТаблицы <> Неопределено Тогда 
		ЗагружаемыеСправочники.Удалить(СтрокаТаблицы);
	КонецЕсли;
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Проверка безопасного режима разделения данных.

// Проверка безопасного режима разделения данных.
// Только для вызова из модуля сеанса.
//
Процедура ПриПроверкеВключенияБезопасногоРежимаРазделенияДанных() Экспорт
	
	Если БезопасныйРежим() = Ложь
		И ОбщегоНазначенияПовтИсп.РазделениеВключено()
		И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных()
		И НЕ ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
		
		Если НЕ БезопасныйРежимРазделенияДанных(РазделительВспомогательныхДанных()) Тогда
			
			УстановитьБезопасныйРежимРазделенияДанных(РазделительВспомогательныхДанных(), Истина);
			
		КонецЕсли;
		
		Если НЕ БезопасныйРежимРазделенияДанных(РазделительОсновныхДанных()) Тогда
			
			УстановитьБезопасныйРежимРазделенияДанных(РазделительОсновныхДанных(), Истина);
			
		КонецЕсли;
	
	КонецЕсли;
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Проверка блокировки области данных при запуске.

// Проверка заблокированности области данных при запуске.
// Только для вызова из СтандартныеПодсистемыСервер.ДобавитьПараметрыРаботыКлиентаПриЗапуске().
//
Процедура ПриПроверкеБлокировкиОбластиДанныхПриЗапуске(ОписаниеОшибки) Экспорт
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено()
			И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных()
			И ОбластьДанныхЗаблокирована(ОбщегоНазначения.ЗначениеРазделителяСеанса()) Тогда
		
		ОписаниеОшибки =
			НСтр("ru = 'Запуск приложения временно недоступен.
			           |Выполняются регламентные операции по обслуживанию приложения.
			           |
			           |Попробуйте запустить приложение через несколько минут.'");
		
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Контроль неразделенных данных.

// Обработчик подписки на событие КонтрольНеразделенныхОбъектовПриЗаписи.
//
Процедура КонтрольНеразделенныхОбъектовПриЗаписи(Источник, Отказ) Экспорт
	
	КонтрольНеразделенныхДанныхПриЗаписи(Источник);
	
КонецПроцедуры

// Обработчик подписки на событие КонтрольНеразделенныхНаборовЗаписейПриЗаписи.
//
Процедура КонтрольНеразделенныхНаборовЗаписейПриЗаписи(Источник, Отказ, Замещение) Экспорт
	
	КонтрольНеразделенныхДанныхПриЗаписи(Источник);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработка вспомогательных данных области.

// Выполняет запись значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - значение ссылочного типа или УдалениеОбъекта.
//
Процедура ЗаписатьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	ОбработатьВспомогательныеДанные(
		ОбъектВспомогательныхДанных,
		Истина,
		Ложь);
	
КонецПроцедуры

// Выполняет удаление значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - значение ссылочного типа.
//
Процедура УдалитьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	ОбработатьВспомогательныеДанные(
		ОбъектВспомогательныхДанных,
		Ложь,
		Истина);
	
КонецПроцедуры

// Создает ключ записи для регистра сведений, включенного в состав разделителя ОбластьДанныхВспомогательныеДанные.
//
// Параметры:
//  Менеджер - РегистрСведенийМенеджер, менеджер регистра сведений, для которого требуется
//    получить ключ записи,
//  ЗначенияКлюча - Структура, содержащая значения для заполнения свойств ключа записи.
//    Имена элементов структуры должны соответствовать именам ключевых полей.
//
// Возвращаемое значение: РегистрСведенийКлючЗаписи.
//
Функция СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(Знач Менеджер, Знач ЗначенияКлюча) Экспорт
	
	Ключ = Менеджер.СоздатьКлючЗаписи(ЗначенияКлюча);
	
	ОбластьДанных = Неопределено;
	Разделитель = РазделительВспомогательныхДанных();
	
	Если ЗначенияКлюча.Свойство(Разделитель, ОбластьДанных) Тогда
		
		Если Ключ[Разделитель] <> ОбластьДанных Тогда
			
			Объект = СериализаторXDTO.ЗаписатьXDTO(Ключ);
			Объект[Разделитель] = ОбластьДанных;
			Ключ = СериализаторXDTO.ПрочитатьXDTO(Объект);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Ключ;
	
КонецФункции

// Для внутреннего использования.
//
Функция ОбластьДанныхОсновныеДанныеСостав() Экспорт
	Возврат Метаданные.ОбщиеРеквизиты.ОбластьДанныхОсновныеДанные.Состав;
КонецФункции

// Для внутреннего использования.
//
Функция ПолучитьОбластиДанныхРезультатЗапроса() Экспорт
	Запрос = Новый Запрос();
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ОбластиДанных.ОбластьДанныхВспомогательныеДанные КАК ОбластьДанных
	|ИЗ
	|	РегистрСведений.ОбластиДанных КАК ОбластиДанных
	|ГДЕ
	|	ОбластиДанных.Статус = ЗНАЧЕНИЕ(Перечисление.СтатусыОбластейДанных.Используется)
	|УПОРЯДОЧИТЬ ПО
	|	ОбластьДанных";
	
	Результат = Запрос.Выполнить();
	
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Возвращает полный путь к каталогу временных файлов.
//
// Возвращаемое значение:
// Строка - Полный путь к каталогу временных файлов.
//
Функция ПолучитьОбщийКаталогВременныхФайлов()
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТипПлатформыСервера = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера();
	
	Если ТипПлатформыСервера = ТипПлатформы.Linux_x86
		ИЛИ ТипПлатформыСервера = ТипПлатформы.Linux_x86_64 Тогда
		
		ОбщийВременныйКаталог = Константы.КаталогОбменаФайламиВМоделиСервисаLinux.Получить();
		РазделительПути = "/";
	Иначе
		ОбщийВременныйКаталог = Константы.КаталогОбменаФайламиВМоделиСервиса.Получить();
		РазделительПути = "\";
	КонецЕсли;
	
	Если ПустаяСтрока(ОбщийВременныйКаталог) Тогда
		ОбщийВременныйКаталог = СокрЛП(КаталогВременныхФайлов());
	Иначе
		ОбщийВременныйКаталог = СокрЛП(ОбщийВременныйКаталог);
	КонецЕсли;
	
	Если Не СтрЗаканчиваетсяНа(ОбщийВременныйКаталог, РазделительПути) Тогда
		ОбщийВременныйКаталог = ОбщийВременныйКаталог + РазделительПути;
	КонецЕсли;
	
	Возврат ОбщийВременныйКаталог;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Подготовка областей данных

// Получает в транзакции менеджер записи для регистра ОбластиДанных.
//
// Параметры:
//  ОбластьДанных - номер области данных.
//  Статус - Перечисления.СтатусыОбластейДанных, ожидаемый статус области.
//
// Возвращаемое значение:
//  РегистрыСведений.ОбластиДанных.МенеджерЗаписи.
//
Функция ПолучитьМенеджерЗаписиОбластиДанных(Знач ОбластьДанных, Знач Статус)
	
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		Элемент = Блокировка.Добавить("РегистрСведений.ОбластиДанных");
		Элемент.УстановитьЗначение("ОбластьДанныхВспомогательныеДанные", ОбластьДанных);
		Элемент.Режим = РежимБлокировкиДанных.Разделяемый;
		Блокировка.Заблокировать();
		
		МенеджерЗаписи = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.ОбластьДанныхВспомогательныеДанные = ОбластьДанных;
		МенеджерЗаписи.Прочитать();
		
		Если НЕ МенеджерЗаписи.Выбран() Тогда
			ШаблонСообщения = НСтр("ru = 'Область данных %1 не найдена'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ОбластьДанных);
			ВызватьИсключение(ТекстСообщения);
		ИначеЕсли МенеджерЗаписи.Статус <> Статус Тогда
			ШаблонСообщения = НСтр("ru = 'Статус области данных %1 не равен ""%2""'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ОбластьДанных, Статус);
			ВызватьИсключение(ТекстСообщения);
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПодготовкаОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат МенеджерЗаписи;
	
КонецФункции
	
// Обновляет статус области в регистре ОбластиДанных, отправляет сообщение в менеджер сервиса.
//
// Параметры:
//  МенеджерЗаписи - РегистрыСведений.ОбластиДанных.МенеджерЗаписи
//  РезультатПодготовки - строка, одна из "Успех", "ТребуетсяКонвертация", "ФатальнаяОшибка",
//    "ОшибкаУдаления", "ОбластьУдалена" 
//  СообщениеОбОшибке - строка.
//
Процедура СменитьСтатусОбластиИУведомитьМенеджер(Знач МенеджерЗаписи, Знач РезультатПодготовки, Знач СообщениеОбОшибке)
	
	КопияМенеджера = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
	ЗаполнитьЗначенияСвойств(КопияМенеджера, МенеджерЗаписи);
	МенеджерЗаписи = КопияМенеджера;

	ВключатьСообщениеОбОшибке = Ложь;
	Если РезультатПодготовки = "Успех" Тогда
		МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.Используется;
		ТипСообщения = СообщенияКонтрольУдаленногоАдминистрированияИнтерфейс.СообщениеОбластьДанныхПодготовлена();
	ИначеЕсли РезультатПодготовки = "ТребуетсяКонвертация" Тогда
		МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.ИмпортИзФайла;
		ТипСообщения = СообщенияКонтрольУдаленногоАдминистрированияИнтерфейс.СообщениеОшибкаПодготовкиОбластиДанныхТребуетсяКонвертация();
	ИначеЕсли РезультатПодготовки = "ОбластьУдалена" Тогда
		МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.Удалена;
		ТипСообщения = СообщенияКонтрольУдаленногоАдминистрированияИнтерфейс.СообщениеОбластьДанныхУдалена();
	ИначеЕсли РезультатПодготовки = "ФатальнаяОшибка" Тогда
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПодготовкаОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , СообщениеОбОшибке);
		МенеджерЗаписи.ОшибкаОбработки = Истина;
		ТипСообщения = СообщенияКонтрольУдаленногоАдминистрированияИнтерфейс.СообщениеОшибкаПодготовкиОбластиДанных();
		ВключатьСообщениеОбОшибке = Истина;
	ИначеЕсли РезультатПодготовки = "ОшибкаУдаления" Тогда
		МенеджерЗаписи.ОшибкаОбработки = Истина;
		ТипСообщения = СообщенияКонтрольУдаленногоАдминистрированияИнтерфейс.СообщениеОшибкаУдаленияОбластиДанных();
		ВключатьСообщениеОбОшибке = Истина;
	Иначе
		ВызватьИсключение НСтр("ru = 'Неожиданный код возврата'");
	КонецЕсли;
	
	// Отправить сообщение о готовности области в менеджер сервиса.
	Сообщение = СообщенияВМоделиСервиса.НовоеСообщение(ТипСообщения);
	Сообщение.Body.Zone = МенеджерЗаписи.ОбластьДанныхВспомогательныеДанные;
	Если ВключатьСообщениеОбОшибке Тогда
		Сообщение.Body.ErrorDescription = СообщениеОбОшибке;
	КонецЕсли;

	НачатьТранзакцию();
	Попытка
		СообщенияВМоделиСервиса.ОтправитьСообщение(
			Сообщение,
			РаботаВМоделиСервисаПовтИсп.КонечнаяТочкаМенеджераСервиса());
		
		МенеджерЗаписи.Записать();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Загружает данные в "типовую" область.
// 
// Параметры: 
//   ОбластьДанных - номер заполняемой области.
//   ИДФайлаВыгрузки - ид файла начальных данных.
//   Вариант - вариант начальных данных.
//   СообщениеОбОшибке - строка, возвращаемая, описание ошибки.
//
// Возвращаемое значение:
//  Строка - один из вариантов "Успех", "ФатальнаяОшибка".
//
Функция ПодготовитьОбластьДанныхКИспользованиюИзЭталонной(Знач ОбластьДанных, Знач ИДФайлаВыгрузки, 
												 		  Знач Вариант, СообщениеОбОшибке)
	
	Если Константы.КопироватьОбластиДанныхИзЭталонной.Получить() Тогда
		
		Результат = ЗагрузитьОбластьИзПоставляемыхДанных(ОбластьДанных, ИДФайлаВыгрузки, Вариант, СообщениеОбОшибке);
		Если Результат <> "Успех" Тогда
			Возврат Результат;
		КонецЕсли;
		
	Иначе
		
		Результат = "Успех";
		
	КонецЕсли;
	
	ОбновлениеИнформационнойБазы.ВыполнитьОбновлениеИнформационнойБазы();
	
	Возврат Результат;
	
КонецФункции
	
// Загружает данные в область из пользовательской выгрузки.
// 
// Параметры: 
//   ОбластьДанных - номер заполняемой области.
//   ИДФайлаВыгрузки - ид файла начальных данных.
//   СообщениеОбОшибке - строка, возвращаемая, описание ошибки.
//
// Возвращаемое значение:
//  Строка - один из вариантов "ТребуетсяКонвертация", "Успех", "ФатальнаяОшибка".
//
Функция ПодготовитьОбластьДанныхКИспользованиюИзВыгрузки(Знач ОбластьДанных, Знач ИДФайлаВыгрузки, СообщениеОбОшибке)
	
	ИмяФайлаВыгрузки = ПолучитьФайлИзХранилищаМенеджераСервиса(ИДФайлаВыгрузки);
	
	Если ИмяФайлаВыгрузки = Неопределено Тогда
		
		СообщениеОбОшибке = НСтр("ru = 'Нет файла начальных данных для области'");
		
		Возврат "ФатальнаяОшибка";
	КонецЕсли;
	
	Если Не ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.РаботаВМоделиСервиса.ВыгрузкаЗагрузкаОбластейДанных") Тогда
		
		ВызватьИсключениеОтсутствуетПодсистемаБТС("ТехнологияСервиса.РаботаВМоделиСервиса.ВыгрузкаЗагрузкаОбластейДанных");
		
	КонецЕсли;
	
	МодульВыгрузкаЗагрузкаОбластейДанных = ОбщегоНазначения.ОбщийМодуль("ВыгрузкаЗагрузкаОбластейДанных");
	
	Если Не МодульВыгрузкаЗагрузкаОбластейДанных.ВыгрузкаВАрхивеСовместимаСТекущейКонфигурацией(ИмяФайлаВыгрузки) Тогда
		Результат = "ТребуетсяКонвертация";
	Иначе
		
		МодульВыгрузкаЗагрузкаОбластейДанных.ЗагрузитьТекущуюОбластьДанныхИзАрхива(ИмяФайлаВыгрузки);
		Результат = "Успех";
		
	КонецЕсли;
	
	Попытка
		УдалитьФайлы(ИмяФайлаВыгрузки);
	Исключение
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПодготовкаОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции определения типов объектов метаданных по полному имени объекта
// метаданных.

Функция ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(Знач ПолноеИмя, Знач РусскаяЛокализация, Знач АнглийскаяЛокализация, Знач ПозицияПодстроки = 0)
	
	Подстроки = СтрРазделить(ПолноеИмя, ".");
	Если Подстроки.Количество() > ПозицияПодстроки Тогда
		ИмяТипа = Подстроки.Получить(ПозицияПодстроки);
		Возврат ИмяТипа = РусскаяЛокализация ИЛИ ИмяТипа = АнглийскаяЛокализация;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики событий подсистем БСП.

// Вызывается при включении разделения данных по областям данных.
//
Процедура ПриВключенииРазделенияПоОбластямДанных() Экспорт
	
	ПроверитьВозможностьИспользованияКонфигурацииВМоделиСервиса();
	
	РаботаВМоделиСервисаПереопределяемый.ПриВключенииРазделенияПоОбластямДанных();
	
КонецПроцедуры

// Зарегистрировать обработчики поставляемых данных.
//
// При получении уведомления о доступности новых общих данных, вызывается процедуры.
// ДоступныНовыеДанные модулей, зарегистрированных через ПолучитьОбработчикиПоставляемыхДанных.
// В процедуру передается Дескриптор - ОбъектXDTO Descriptor.
// 
// В случае, если ДоступныНовыеДанные устанавливает аргумент Загружать в значение Истина, 
// данные загружаются, дескриптор и путь к файлу с данными передаются в процедуру.
// ОбработатьНовыеДанные. Файл будет автоматически удален после завершения процедуры.
// Если в менеджере сервиса не был указан файл - значение аргумента равно Неопределено.
//
// Параметры: 
//   Обработчики, ТаблицаЗначений - таблица для добавления обработчиков. 
//       Колонки:
//        ВидДанных, строка - код вида данных, обрабатываемый обработчиком.
//        КодОбработчика, строка(20) - будет использоваться при восстановлении обработки данных после сбоя.
//        Обработчик,  ОбщийМодуль - модуль, содержащий следующие процедуры:
//          ДоступныНовыеДанные(Дескриптор, Загружать) Экспорт  
//          ОбработатьНовыеДанные(Дескриптор, ПутьКФайлу) Экспорт
//          ОбработкаДанныхОтменена(Дескриптор) Экспорт
//
Процедура ПриОпределенииОбработчиковПоставляемыхДанных(Обработчики) Экспорт
	
	ЗарегистрироватьОбработчикиПоставляемыхДанных(Обработчики);
	
КонецПроцедуры

// Добавляет процедуры-обработчики обновления, необходимые данной подсистеме.
//
// Параметры:
//  Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
//                                  общего модуля ОбновлениеИнформационнойБазы.
// 
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.3.31";
	Обработчик.Процедура = "РаботаВМоделиСервиса.ПеренестиОбластиДанных";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 99;
	Обработчик.МонопольныйРежим = Истина;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "2.1.3.9";
	Обработчик.Процедура = "РаботаВМоделиСервиса.ОтключитьРазделениеПользователейПоРазделителюВнутреннихДанных";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.МонопольныйРежим = Истина;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "*";
	Обработчик.Процедура = "РаботаВМоделиСервиса.КонтрольНеразделенныхДанныхПриОбновлении";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 99;
	Обработчик.МонопольныйРежим = Ложь;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "*";
	Обработчик.Процедура = "РаботаВМоделиСервиса.КонтрольРазделителейПриОбновлении";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 99;
	Обработчик.МонопольныйРежим = Ложь;
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "*";
		Обработчик.Процедура = "РаботаВМоделиСервиса.ПроверитьВозможностьИспользованияКонфигурацииВМоделиСервиса";
		Обработчик.ОбщиеДанные = Истина;
		Обработчик.ВыполнятьВГруппеОбязательных = Истина;
		Обработчик.Приоритет = 99;
		Обработчик.МонопольныйРежим = Ложь;
		
	КонецЕсли;
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "2.2.4.9";
		Обработчик.Процедура = "РаботаВМоделиСервиса.ПеренестиРейтингАктивностиОбластейДанных";
		Обработчик.ОбщиеДанные = Истина;
		Обработчик.ВыполнятьВГруппеОбязательных = Истина;
		Обработчик.МонопольныйРежим = Истина;
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет структуру параметров, необходимых для работы клиентского кода
// конфигурации. 
//
// Параметры:
//   Параметры   - Структура - структура параметров.
//
Процедура ПриДобавленииПараметровРаботыКлиентаПриЗапуске(Параметры) Экспорт
	
	ПриДобавленииПараметровРаботыКлиента(Параметры);
	
КонецПроцедуры

// Заполняет структуру параметров, необходимых для работы клиентского кода
// конфигурации.
//
// Параметры:
//   Параметры   - Структура - структура параметров.
//
Процедура ПриДобавленииПараметровРаботыКлиента(Параметры) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено()
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПредставлениеОбластиДанных.Значение КАК Представление
	|ИЗ
	|	Константа.ПредставлениеОбластиДанных КАК ПредставлениеОбластиДанных
	|ГДЕ
	|	ПредставлениеОбластиДанных.ОбластьДанныхВспомогательныеДанные = &ОбластьДанныхВспомогательныеДанные";
	УстановитьПривилегированныйРежим(Истина);
	Запрос.УстановитьПараметр("ОбластьДанныхВспомогательныеДанные", ОбщегоНазначения.ЗначениеРазделителяСеанса());
	// Считаем данные условно неизменяемыми.
	Результат = Запрос.Выполнить();
	УстановитьПривилегированныйРежим(Ложь);
	Если НЕ Результат.Пустой() Тогда
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		Если ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
			Параметры.Вставить("ПредставлениеОбластиДанных", 
				Формат(ОбщегоНазначения.ЗначениеРазделителяСеанса(), "ЧН=0; ЧГ=") +  " - " + Выборка.Представление);
		ИначеЕсли НЕ ПустаяСтрока(Выборка.Представление) Тогда
			Параметры.Вставить("ПредставлениеОбластиДанных", Выборка.Представление);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Заполняет массив типов, исключаемых из выгрузки и загрузки данных.
//
// Параметры:
//  Типы - Массив(Типы).
//
Процедура ПриЗаполненииТиповИсключаемыхИзВыгрузкиЗагрузки(Типы) Экспорт
	
	Типы.Добавить(Метаданные.Константы.КлючОбластиДанных);
	Типы.Добавить(Метаданные.РегистрыСведений.ОбластиДанных);
	
КонецПроцедуры

// Вызывается перед попыткой записи значений параметров ИБ в одноименные
// константы.
//
// Параметры:
// ЗначенияПараметров - Структура - значения параметров которые требуется установить.
// В случае если значение параметра устанавливается в данной процедуре из структуры
// необходимо удалить соответствующую пару КлючИЗначение.
//
Процедура ПриУстановкеЗначенийПараметровИБ(Знач ЗначенияПараметров) Экспорт
	
	// Для служебного пользователя Менеджера сервиса
	Владелец = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Константа.ВнутреннийАдресМенеджераСервиса");
	Если ЗначенияПараметров.Свойство("ИмяСлужебногоПользователяМенеджераСервиса") Тогда
		УстановитьПривилегированныйРежим(Истина);
		ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище(Владелец, ЗначенияПараметров.ИмяСлужебногоПользователяМенеджераСервиса, "ИмяСлужебногоПользователяМенеджераСервиса");
		УстановитьПривилегированныйРежим(Ложь);
		ЗначенияПараметров.Удалить("ИмяСлужебногоПользователяМенеджераСервиса");
	КонецЕсли;
	
	Если ЗначенияПараметров.Свойство("ПарольСлужебногоПользователяМенеджераСервиса") Тогда
		УстановитьПривилегированныйРежим(Истина);
		ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище(Владелец, ЗначенияПараметров.ПарольСлужебногоПользователяМенеджераСервиса, "ПарольСлужебногоПользователяМенеджераСервиса");
		УстановитьПривилегированныйРежим(Ложь);
		ЗначенияПараметров.Удалить("ПарольСлужебногоПользователяМенеджераСервиса");
	КонецЕсли;
	
КонецПроцедуры

// Вызывается после загрузки данных.
//
// Параметры:
//  Контейнер - ОбработкаОбъект.ВыгрузкаЗагрузкаДанныхМенеджерКонтейнера - менеджер
//    контейнера, используемый в процессе загрузки данных. Подробнее см. комментарий
//    к программному интерфейсу обработки ВыгрузкаЗагрузкаДанныхМенеджерКонтейнера.
Процедура ПослеЗагрузкиДанных(Контейнер) Экспорт
	
	ПользователиСлужебный.ПослеЗагрузкиДанных(Контейнер);
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.УправлениеИтогамиИАгрегатами") Тогда
		
		МодульУправлениеИтогамиИАгрегатамиСлужебный = ОбщегоНазначения.ОбщийМодуль("УправлениеИтогамиИАгрегатамиСлужебный");
		МодульУправлениеИтогамиИАгрегатамиСлужебный.РассчитатьИтоги();
		
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Работа с параметрами ИБ

// Возвращает пустую таблицу параметров ИБ.
//
Функция ПолучитьПустуюТаблицуПараметровИБ()
	
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
	Результат.Колонки.Добавить("Описание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
	Результат.Колонки.Добавить("ЗапретЧтения", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ЗапретЗаписи", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("Тип", Новый ОписаниеТипов("ОписаниеТипов"));
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с файлами

// Добавляет файл в хранилище менеджера сервиса.
//
// Параметры:
// АдресДанныеФайл - Строка/ДвоичныеДанные/Файл - Адрес временного хранилища/Данные файла/Файл.
// ПараметрыПодключения - Структура:
//							- URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//							- UserName - Строка - Имя пользователя сервиса.
//							- Password - Строка - Пароль пользователя сервиса.
// ИмяФайла - Строка - Хранимое имя файла. 
//		
// Возвращаемое значение:
// УникальныйИдентификатор - Идентификатор файла в хранилище.
//
Функция ПоместитьФайлВХранилище(Знач АдресДанныеФайл, Знач ПараметрыПодключения, Знач ИмяФайла = "")
	
	НачалоВыполнения = ТекущаяУниверсальнаяДата();
	
	ОписаниеПрокси = ОписаниеПроксиСервисаПередачиФайлов(ПараметрыПодключения);
	
	Описание = ПолучитьИмяФайлаСДанными(АдресДанныеФайл, ИмяФайла);
	СвойстваФайла = Новый Файл(Описание.Имя);
	
	ОбменЧерезФС = МожноПередаватьЧерезФСНаСервер(ОписаниеПрокси.Прокси, ОписаниеПрокси.ЕстьПоддержка2йВерсии);
	Если ОбменЧерезФС Тогда
		
		// Сохранить данные в файл.
		ОбщийКаталог = ПолучитьОбщийКаталогВременныхФайлов();
		ЦелевойФайл = Новый Файл(ОбщийКаталог + СвойстваФайла.Имя);
		Если ЦелевойФайл.Существует() Тогда
			// Это один и тот же файл. Его можно, не передавая, сразу читать на сервере.
			Если СвойстваФайла.ПолноеИмя = ЦелевойФайл.ПолноеИмя Тогда
				Результат = ОписаниеПрокси.Прокси.ReadFileFromFS(ЦелевойФайл.Имя, СвойстваФайла.Имя);
				РазмерИсходногоФайла = ЦелевойФайл.Размер();
				ЗаписатьВЖурналСобытиеФайловогоХранилища(
					НСтр("ru = 'Помещение'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					Результат,
					РазмерИсходногоФайла,
					ТекущаяУниверсальнаяДата() - НачалоВыполнения,
					ОбменЧерезФС);
				Возврат Результат;
				// Нельзя удалять, поскольку он является и источником.
			КонецЕсли;
			// Источник и приемник - разные файлы. Чтобы не затереть чужой файл, делаем приемнику уникальное имя.
			НовыйИД = Новый УникальныйИдентификатор;
			ЦелевойФайл = Новый Файл(ОбщийКаталог + НовыйИД + СвойстваФайла.Расширение);
		КонецЕсли;
		
		Попытка
			Если Описание.Данные = Неопределено Тогда
				КопироватьФайл(СвойстваФайла.ПолноеИмя, ЦелевойФайл.ПолноеИмя);
			Иначе
				Описание.Данные.Записать(ЦелевойФайл.ПолноеИмя);
			КонецЕсли;
			Результат = ОписаниеПрокси.Прокси.ReadFileFromFS(ЦелевойФайл.Имя, СвойстваФайла.Имя);
			РазмерИсходногоФайла = ЦелевойФайл.Размер();
			ЗаписатьВЖурналСобытиеФайловогоХранилища(
				НСтр("ru = 'Помещение'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				Результат,
				РазмерИсходногоФайла,
				ТекущаяУниверсальнаяДата() - НачалоВыполнения,
				ОбменЧерезФС);
		Исключение
			ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииДобавлениеФайлаОбменЧерезФС(),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ОбменЧерезФС = Ложь;
		КонецПопытки;
		
		УдалитьВременныеФайлы(ЦелевойФайл.ПолноеИмя);
		
	КонецЕсли; // ОбменЧерезФС
		
	Если Не ОбменЧерезФС Тогда
		
		РазмерБлокаПередачиФайла = ПолучитьРазмерБлокаПередачиФайла(); // Мб
		ИдентификаторПередачи = Новый УникальныйИдентификатор;
		
		// Сохранить данные в файл.
		КаталогСборки = СоздатьКаталогСборки();
		ПолноеИмяФайла = КаталогСборки + СвойстваФайла.Имя;
		
		Если Описание.Данные = Неопределено Тогда
			Если СвойстваФайла.Существует() Тогда
				КопироватьФайл(СвойстваФайла.ПолноеИмя, ПолноеИмяФайла);
			Иначе
				ВызватьИсключение(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Добавление файла в хранилище. Не найден файл %1.'"),
					СвойстваФайла.ПолноеИмя));
			КонецЕсли;
		Иначе
			Описание.Данные.Записать(ПолноеИмяФайла);
		КонецЕсли;
		
		ЦелевойФайл = Новый Файл(ПолноеИмяФайла);
		РазмерИсходногоФайла = ЦелевойФайл.Размер();
		
		// Архивировать файл.
		ИмяНеразделенногоФайла = ПолучитьИмяВременногоФайла("zip");
		Архиватор = Новый ЗаписьZipФайла(ИмяНеразделенногоФайла, , , , УровеньСжатияZIP.Минимальный);
		Архиватор.Добавить(ПолноеИмяФайла);
		Архиватор.Записать();
		
		// Разделить файл на части.
		// Мб => байты.
		ИменаФайлов = РазделитьФайл(ИмяНеразделенногоФайла, РазмерБлокаПередачиФайла * 1024 * 1024, КаталогСборки);
		
		Попытка
			УдалитьФайлы(ИмяНеразделенногоФайла);
		Исключение
			ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииДобавлениеФайлаОбменНеЧерезФС(),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		// Передать файл через сервис по частям.
		КоличествоЧастей = ИменаФайлов.Количество();
		Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
			Для НомерЧасти = 1 По КоличествоЧастей Цикл	// Передача по частям.	
				ИмяФайлаЧасти = ИменаФайлов[НомерЧасти - 1];		
				ДанныеФайла = Новый ДвоичныеДанные(ИмяФайлаЧасти);		
				Попытка
					УдалитьФайлы(ИмяФайлаЧасти);
				Исключение
					ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииДобавлениеФайлаОбменНеЧерезФС(),
						УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				КонецПопытки;
				ОписаниеПрокси.Прокси.PutFilePart(ИдентификаторПередачи, НомерЧасти, ДанныеФайла, КоличествоЧастей);
			КонецЦикла;
		Иначе // 1-я версия.
			Для НомерЧасти = 1 По КоличествоЧастей Цикл	// Передача по частям.	
				ИмяФайлаЧасти = ИменаФайлов[НомерЧасти - 1];		
				ДанныеФайла = Новый ДвоичныеДанные(ИмяФайлаЧасти);		
				Попытка
					УдалитьФайлы(ИмяФайлаЧасти);
				Исключение
					ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииДобавлениеФайлаОбменНеЧерезФС(),
						УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				КонецПопытки;
				ОписаниеПрокси.Прокси.PutFilePart(ИдентификаторПередачи, НомерЧасти, ДанныеФайла);
			КонецЦикла;
		КонецЕсли;
		
		Попытка
			УдалитьФайлы(КаталогСборки);
		Исключение
			ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииДобавлениеФайлаОбменНеЧерезФС(),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
			Результат = ОписаниеПрокси.Прокси.SaveFileFromParts(ИдентификаторПередачи, КоличествоЧастей); 
		Иначе // 1-я версия.
			Результат = Неопределено;
			ОписаниеПрокси.Прокси.SaveFileFromParts(ИдентификаторПередачи, КоличествоЧастей, Результат); 
		КонецЕсли;
		
		ЗаписатьВЖурналСобытиеФайловогоХранилища(
			НСтр("ru = 'Помещение'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			Результат,
			РазмерИсходногоФайла,
			ТекущаяУниверсальнаяДата() - НачалоВыполнения,
			ОбменЧерезФС);
		
	КонецЕсли; // Не ОбменЧерезФС
	
	Возврат Результат;
	
КонецФункции

// Возвращает структуру с именем и данными файла по адресу во временном хранилище/информации в объекте Файл/двоичным
// данным.
//
// Параметры:
//	АдресДанныеФайл - Строка/ДвоичныеДанные/Файл - Адрес хранилища данных файла/Данные файла/Файл.
//	ИмяФайла - Строка.
//		
// Возвращаемое значение:
// Структура:
//   Данные - ДвоичныеДанные - Данные файла.
//   Имя - Строка - Имя файла.
//
Функция ПолучитьИмяФайлаСДанными(Знач АдресДанныеФайл, Знач ИмяФайла = "")
	
	Если ТипЗнч(АдресДанныеФайл) = Тип("Строка") Тогда // Адрес данных файла во временном хранилище.
		Если ПустаяСтрока(АдресДанныеФайл) Тогда
			ВызватьИсключение(НСтр("ru = 'Неверный адрес хранилища.'"));
		КонецЕсли;
		ДанныеФайла = ПолучитьИзВременногоХранилища(АдресДанныеФайл);
	ИначеЕсли ТипЗнч(АдресДанныеФайл) = Тип("Файл") Тогда // Объект типа Файл.
		Если Не АдресДанныеФайл.Существует() Тогда
			ВызватьИсключение(НСтр("ru = 'Файл не найден.'"));
		КонецЕсли;
		ДанныеФайла = Неопределено;
		ИмяФайла = АдресДанныеФайл.ПолноеИмя;
	ИначеЕсли ТипЗнч(АдресДанныеФайл) = Тип("ДвоичныеДанные") Тогда // Данные файла.
		ДанныеФайла = АдресДанныеФайл;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Неверный тип данных'"));
	КонецЕсли;
	
	Если ПустаяСтрока(ИмяФайла) Тогда
		ИмяФайла = ПолучитьИмяВременногоФайла();
	КонецЕсли;
	
	Возврат Новый Структура("Данные, Имя", ДанныеФайла, ИмяФайла);
	
КонецФункции

// Проверяет, возможна ли передача файла через файловую систему с сервера на клиент.
//
// Параметры:
// Прокси - WSПрокси - Прокси сервиса FilesTransfer*.
// ЕстьПоддержка2йВерсии - Булево.
//
// Возвращаемое значение:
// Булево.
//
Функция МожноПередаватьЧерезФСССервера(Знач Прокси, Знач ЕстьПоддержка2йВерсии)
	
	Если Не ЕстьПоддержка2йВерсии Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИмяФайла = Прокси.WriteTestFile();
	Если ИмяФайла = "" Тогда 
		Возврат Ложь;
	КонецЕсли;
	
	Результат = ПрочитатьПробныйФайл(ИмяФайла);
	
	Прокси.DeleteTestFile(ИмяФайла);
	
	Возврат Результат;
	
КонецФункции

// Проверяет, возможна ли передача файла через файловую систему с клиента на сервер.
//
// Параметры:
// Прокси - WSПрокси - Прокси сервиса FilesTransfer*.
// ЕстьПоддержка2йВерсии - Булево.
//
// Возвращаемое значение:
// Булево.
//
Функция МожноПередаватьЧерезФСНаСервер(Знач Прокси, Знач ЕстьПоддержка2йВерсии)
	
	Если Не ЕстьПоддержка2йВерсии Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИмяФайла = ЗаписатьПробныйФайл();
	Если ИмяФайла = "" Тогда 
		Возврат Ложь;
	КонецЕсли;
	
	Результат = Прокси.ReadTestFile(ИмяФайла);
	
	ПолноеИмяФайла = ПолучитьОбщийКаталогВременныхФайлов() + ИмяФайла;
	УдалитьВременныеФайлы(ПолноеИмяФайла);
	
	Возврат Результат;
	
КонецФункции

// Создать каталог с уникальным именем для размещения частей разделяемого файла.
//
// Возвращаемое значение:
// Строка - Имя каталога.
//
Функция СоздатьКаталогСборки()
	
	КаталогСборки = ПолучитьИмяВременногоФайла();
	СоздатьКаталог(КаталогСборки);
	Возврат КаталогСборки + ПолучитьРазделительПути();
	
КонецФункции

// Читает тестовый файл с диска, сравнивая содержимое и имя: они должны совпадать.
// Файл должна удалять вызывающая сторона.
//
// Параметры:
// ИмяФайла - Строка - Без пути.
//
// Возвращаемое значение:
// Булево - Истина, если файл успешно прочтен и содержимое совпадает с его именем.
//
Функция ПрочитатьПробныйФайл(Знач ИмяФайла)
	
	СвойстваФайла = Новый Файл(ПолучитьОбщийКаталогВременныхФайлов() + ИмяФайла);
	Если СвойстваФайла.Существует() Тогда
		Текст = Новый ЧтениеТекста(СвойстваФайла.ПолноеИмя, КодировкаТекста.ANSI);
		ТестовыйИД = Текст.Прочитать();
		Текст.Закрыть();
		Возврат ТестовыйИД = СвойстваФайла.ИмяБезРасширения;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

// Создает незаполненную структуру нужного формата.
//
// Возвращаемое значение:
// Структура:
//   Имя - Строка - Имя файла в хранилище.
//   Данные - ДвоичныеДанные - Данные файла.
// 	 ПолноеИмя - Строка - Имя файла с путем.
//
Функция СоздатьОписаниеФайла()
	
	ОписаниеФайла = Новый Структура;
	ОписаниеФайла.Вставить("Имя");
	ОписаниеФайла.Вставить("Данные");
	ОписаниеФайла.Вставить("ПолноеИмя");
	ОписаниеФайла.Вставить("ОбязательныеПараметры", "Имя"); // Обязательные к заполнению параметры.
	Возврат ОписаниеФайла;
	
КонецФункции

// Получает объект WSПрокси Web-сервиса, заданного своим базовым именем.
//
// Параметры:
// ПараметрыПодключения - Структура:
//							- URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//							- UserName - Строка - Имя пользователя сервиса.
//							- Password - Строка - Пароль пользователя сервиса.
// Возвращаемое значение:
//  Структура
//   Прокси - WSПрокси
//   ЕстьПоддержка2йВерсии - Булево.
//
Функция ОписаниеПроксиСервисаПередачиФайлов(Знач ПараметрыПодключения)
	
	БазовоеИмяСервиса = "FilesTransfer";
	
	МассивПоддерживаемыхВерсий = ОбщегоНазначения.ПолучитьВерсииИнтерфейса(ПараметрыПодключения, "СервисПередачиФайлов");
	Если МассивПоддерживаемыхВерсий.Найти("1.0.2.1") = Неопределено Тогда
		ЕстьПоддержка2йВерсии = Ложь;
		ВерсияИнтерфейса = "1.0.1.1"
	Иначе
		ЕстьПоддержка2йВерсии = Истина;
		ВерсияИнтерфейса = "1.0.2.1";
	КонецЕсли;
	
	Если ПараметрыПодключения.Свойство("UserName")
		И ЗначениеЗаполнено(ПараметрыПодключения.UserName) Тогда
		
		ИмяПользователя = ПараметрыПодключения.UserName;
		ПарольПользователя = ПараметрыПодключения.Password;
	Иначе
		ИмяПользователя = Неопределено;
		ПарольПользователя = Неопределено;
	КонецЕсли;
	
	Если ВерсияИнтерфейса = Неопределено Или ВерсияИнтерфейса = "1.0.1.1" Тогда // 1-я версия.
		ИмяСервиса = БазовоеИмяСервиса;
	Иначе // Версии 2 и выше.
		ИмяСервиса = БазовоеИмяСервиса + "_" + СтрЗаменить(ВерсияИнтерфейса, ".", "_");
	КонецЕсли;
	
	АдресСервиса = ПараметрыПодключения.URL + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("/ws/%1?wsdl", ИмяСервиса);
	
	Прокси = ОбщегоНазначения.WSПрокси(АдресСервиса, 
		"http://www.1c.ru/SaaS/1.0/WS", ИмяСервиса, , ИмяПользователя, ПарольПользователя, 600);
		
	Возврат Новый Структура("Прокси, ЕстьПоддержка2йВерсии", Прокси, ЕстьПоддержка2йВерсии);
		
КонецФункции

Процедура ЗаписатьВЖурналСобытиеФайловогоХранилища(Знач Событие,
	Знач ИдФайла, Знач Размер, Знач Длительность, Знач ПередачаЧерезФайловуюСистему)
	
	ДанныеСобытия = Новый Структура;
	ДанныеСобытия.Вставить("ИдФайла", ИдФайла);
	ДанныеСобытия.Вставить("Размер", Размер);
	ДанныеСобытия.Вставить("Длительность", Длительность);
	
	Если ПередачаЧерезФайловуюСистему Тогда
		ДанныеСобытия.Вставить("Транспорт", "file");
	Иначе
		ДанныеСобытия.Вставить("Транспорт", "ws");
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Хранилище файлов'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()) + "." + Событие,
		УровеньЖурналаРегистрации.Информация,
		,
		,
		ОбщегоНазначения.ЗначениеВСтрокуXML(ДанныеСобытия));
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////
// Временные файлы

// Удалить файл(ы) на диске.
// Если в качестве имени файла задана маска с путем, разделить его на путь и маску.
//
Процедура УдалитьВременныеФайлы(Знач ИмяФайла)
	
	Попытка
		Если СтрЗаканчиваетсяНа(ИмяФайла, "*") Тогда // Маска.
			Индекс = СтрНайти(ИмяФайла, ПолучитьРазделительПути(), НаправлениеПоиска.СКонца);
			Если Индекс > 0 Тогда
				ПутьКФайлу = Лев(ИмяФайла, Индекс - 1);
				МаскаФайла = Сред(ИмяФайла, Индекс + 1);
				Если НайтиФайлы(ПутьКФайлу, МаскаФайла, Ложь).Количество() > 0 Тогда
					УдалитьФайлы(ПутьКФайлу, МаскаФайла);
				КонецЕсли;
			КонецЕсли;
		Иначе
			СвойстваФайла = Новый Файл(ИмяФайла);
			Если СвойстваФайла.Существует() Тогда
				СвойстваФайла.УстановитьТолькоЧтение(Ложь); // Снять атрибут.
				УдалитьФайлы(СвойстваФайла.ПолноеИмя);
			КонецЕсли;
		КонецЕсли;
	Исключение
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииУдалениеВременногоФайла(),
			УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат;
	КонецПопытки;
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////
// Сериализация

Функция ЗаписатьЗначениеВСтроку(Знач Значение)
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	
	Если ТипЗнч(Значение) = Тип("ОбъектXDTO") Тогда
		ФабрикаXDTO.ЗаписатьXML(Запись, Значение, , , , НазначениеТипаXML.Явное);
	Иначе
		СериализаторXDTO.ЗаписатьXML(Запись, Значение, НазначениеТипаXML.Явное);
	КонецЕсли;
	
	Возврат Запись.Закрыть();
		
КонецФункции

// Отражает, является ли данный тип сериализуемым.
//
// Параметры:
// СтруктурныйТип - Тип.
//
// Возвращаемое значение:
// Булево.
//
Функция СериализуемыйСтруктурныйТип(СтруктурныйТип);
	
	МассивСериализуемыхТипов = РаботаВМоделиСервисаПовтИсп.СериализуемыеСтруктурныеТипы();
	
	Для Каждого СериализуемыйТип Из МассивСериализуемыхТипов Цикл 
		Если СтруктурныйТип = СериализуемыйТип Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
		
КонецФункции

// Получает XDTO-представление объекта структурного типа.
//
// Параметры:
// ЗначениеСтруктурногоТипа - Массив, Структура, Соответствие или их фиксированные аналоги.
//
// Возвращаемое значение:
// Структурный объект XDTO - XDTO-представление объекта структурного типа.
//
Функция СтруктурныйОбъектВОбъектXDTO(Знач ЗначениеСтруктурногоТипа)
	
	СтруктурныйТип = ТипЗнч(ЗначениеСтруктурногоТипа);
	
	Если Не СериализуемыйСтруктурныйТип(СтруктурныйТип) Тогда
		СообщениеОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Тип %1 не является структурным или его сериализация в настоящее время не поддерживается.'"),
			СтруктурныйТип);
		ВызватьИсключение(СообщениеОбОшибке);
	КонецЕсли;
	
	XMLТипЗначения = СериализаторXDTO.XMLТипЗнч(ЗначениеСтруктурногоТипа);
	ТипСтруктура = ФабрикаXDTO.Тип(XMLТипЗначения);
	СтруктураXDTO = ФабрикаXDTO.Создать(ТипСтруктура);
	
	// Перебор допустимых структурных типов.
	
	Если СтруктурныйТип = Тип("Структура") Или СтруктурныйТип = Тип("ФиксированнаяСтруктура") Тогда
		
		ТипСвойство = ТипСтруктура.Свойства.Получить("Property").Тип;
		
		Для Каждого КлючИЗначение Из ЗначениеСтруктурногоТипа Цикл
			Свойство = ФабрикаXDTO.Создать(ТипСвойство);
			Свойство.name = КлючИЗначение.Ключ;
			Свойство.Value = ЗначениеТипаВЗначениеXDTO(КлючИЗначение.Значение);
			СтруктураXDTO.Property.Добавить(Свойство);
		КонецЦикла;
		
	ИначеЕсли СтруктурныйТип = Тип("Массив") Или СтруктурныйТип = Тип("ФиксированныйМассив") Тогда 
		
		Для Каждого ЗначениеЭлемента Из ЗначениеСтруктурногоТипа Цикл
			СтруктураXDTO.Value.Добавить(ЗначениеТипаВЗначениеXDTO(ЗначениеЭлемента));
		КонецЦикла;
		
	ИначеЕсли СтруктурныйТип = Тип("Соответствие") Или СтруктурныйТип = Тип("ФиксированноеСоответствие") Тогда
		
		Для Каждого КлючИЗначение Из ЗначениеСтруктурногоТипа Цикл
			СтруктураXDTO.pair.Добавить(СтруктурныйОбъектВОбъектXDTO(КлючИЗначение));
		КонецЦикла;
	
	ИначеЕсли СтруктурныйТип = Тип("КлючИЗначение")	Тогда	
		
		СтруктураXDTO.key = ЗначениеТипаВЗначениеXDTO(ЗначениеСтруктурногоТипа.Ключ);
		СтруктураXDTO.value = ЗначениеТипаВЗначениеXDTO(ЗначениеСтруктурногоТипа.Значение);
		
	ИначеЕсли СтруктурныйТип = Тип("ТаблицаЗначений") Тогда
		
		XDTOТипКолонкаТЗ = ТипСтруктура.Свойства.Получить("column").Тип;
		
		Для Каждого Колонка Из ЗначениеСтруктурногоТипа.Колонки Цикл
			
			КолонкаXDTO = ФабрикаXDTO.Создать(XDTOТипКолонкаТЗ);
			
			КолонкаXDTO.Name = ЗначениеТипаВЗначениеXDTO(Колонка.Имя);
			КолонкаXDTO.ValueType = СериализаторXDTO.ЗаписатьXDTO(Колонка.ТипЗначения);
			КолонкаXDTO.Title = ЗначениеТипаВЗначениеXDTO(Колонка.Заголовок);
			КолонкаXDTO.Width = ЗначениеТипаВЗначениеXDTO(Колонка.Ширина);
			
			СтруктураXDTO.column.Добавить(КолонкаXDTO);
			
		КонецЦикла;
		
		XDTOТипИндексТЗ = ТипСтруктура.Свойства.Получить("index").Тип;
		
		Для Каждого Индекс Из ЗначениеСтруктурногоТипа.Индексы Цикл
			
			ИндексXDTO = ФабрикаXDTO.Создать(XDTOТипИндексТЗ);
			
			Для Каждого ПолеИндекса Из Индекс Цикл
				ИндексXDTO.column.Добавить(ЗначениеТипаВЗначениеXDTO(ПолеИндекса));
			КонецЦикла;
			
			СтруктураXDTO.index.Добавить(ИндексXDTO);
			
		КонецЦикла;
		
		XDTOТипСтрокаТЗ = ТипСтруктура.Свойства.Получить("row").Тип;
		
		Для Каждого СтрокаТЗ Из ЗначениеСтруктурногоТипа Цикл
			
			СтрокаXDTO = ФабрикаXDTO.Создать(XDTOТипСтрокаТЗ);
			
			Для Каждого ЗначениеКолонки Из СтрокаТЗ Цикл
				СтрокаXDTO.value.Добавить(ЗначениеТипаВЗначениеXDTO(ЗначениеКолонки));
			КонецЦикла;
			
			СтруктураXDTO.row.Добавить(СтрокаXDTO);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат СтруктураXDTO;
	
КонецФункции

// Получает объект структурного типа из XDTO-объекта.
//
// Параметры:
// ОбъектXDTO - Объект XDTO.
//
// Возвращаемое значение:
// Структурный тип ( Массив, Структура, Соответствие или их фиксированные аналоги).
//
Функция ОбъектXDTOВСтруктурныйОбъект(ОбъектXDTO)
	
	ТипДанныхXML = Новый ТипДанныхXML(ОбъектXDTO.Тип().Имя, ОбъектXDTO.Тип().UriПространстваИмен);
	Если ВозможностьЧтенияТипаДанныхXML(ТипДанныхXML) Тогда
		СтруктурныйТип = СериализаторXDTO.ИзXMLТипа(ТипДанныхXML);
	Иначе
		Возврат ОбъектXDTO;
	КонецЕсли;
	
	Если СтруктурныйТип = Тип("Строка") Тогда
		Возврат "";
	КонецЕсли;
	
	Если Не СериализуемыйСтруктурныйТип(СтруктурныйТип) Тогда
		СообщениеОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Тип %1 не является структурным или его сериализация в настоящее время не поддерживается.'"),
			СтруктурныйТип);
		ВызватьИсключение(СообщениеОбОшибке);
	КонецЕсли;
	
	Если СтруктурныйТип = Тип("Структура")	Или СтруктурныйТип = Тип("ФиксированнаяСтруктура") Тогда
		
		СтруктурныйОбъект = Новый Структура;
		
		Для Каждого Свойство Из ОбъектXDTO.Property Цикл
			СтруктурныйОбъект.Вставить(Свойство.name, ЗначениеXDTOВЗначениеТипа(Свойство.Value));          
		КонецЦикла;
		
		Если СтруктурныйТип = Тип("Структура") Тогда
			Возврат СтруктурныйОбъект;
		Иначе 
			Возврат Новый ФиксированнаяСтруктура(СтруктурныйОбъект);
		КонецЕсли;
		
	ИначеЕсли СтруктурныйТип = Тип("Массив") Или СтруктурныйТип = Тип("ФиксированныйМассив") Тогда 
		
		СтруктурныйОбъект = Новый Массив;
		
		Для Каждого ЭлементМассива Из ОбъектXDTO.Value Цикл
			СтруктурныйОбъект.Добавить(ЗначениеXDTOВЗначениеТипа(ЭлементМассива));          
		КонецЦикла;
		
		Если СтруктурныйТип = Тип("Массив") Тогда
			Возврат СтруктурныйОбъект;
		Иначе 
			Возврат Новый ФиксированныйМассив(СтруктурныйОбъект);
		КонецЕсли;
		
	ИначеЕсли СтруктурныйТип = Тип("Соответствие") Или СтруктурныйТип = Тип("ФиксированноеСоответствие") Тогда
		
		СтруктурныйОбъект = Новый Соответствие;
		
		Для Каждого КлючИЗначениеXDTO Из ОбъектXDTO.pair Цикл
			КлючИЗначение = ОбъектXDTOВСтруктурныйОбъект(КлючИЗначениеXDTO);
			СтруктурныйОбъект.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
		
		Если СтруктурныйТип = Тип("Соответствие") Тогда
			Возврат СтруктурныйОбъект;
		Иначе 
			Возврат Новый ФиксированноеСоответствие(СтруктурныйОбъект);
		КонецЕсли;
	
	ИначеЕсли СтруктурныйТип = Тип("КлючИЗначение")	Тогда	
		
		СтруктурныйОбъект = Новый Структура("Ключ, Значение");
		СтруктурныйОбъект.Ключ = ЗначениеXDTOВЗначениеТипа(ОбъектXDTO.key);
		СтруктурныйОбъект.Значение = ЗначениеXDTOВЗначениеТипа(ОбъектXDTO.value);
		
		Возврат СтруктурныйОбъект;
		
	ИначеЕсли СтруктурныйТип = Тип("ТаблицаЗначений") Тогда
		
		СтруктурныйОбъект = Новый ТаблицаЗначений;
		
		Для Каждого Колонка Из ОбъектXDTO.column Цикл
			
			СтруктурныйОбъект.Колонки.Добавить(
				ЗначениеXDTOВЗначениеТипа(Колонка.Name), 
				СериализаторXDTO.ПрочитатьXDTO(Колонка.ValueType), 
				ЗначениеXDTOВЗначениеТипа(Колонка.Title), 
				ЗначениеXDTOВЗначениеТипа(Колонка.Width));
				
		КонецЦикла;
		Для Каждого Индекс Из ОбъектXDTO.index Цикл
			
			ИндексСтрокой = "";
			Для Каждого ПолеИндекса Из Индекс.column Цикл
				ИндексСтрокой = ИндексСтрокой + ПолеИндекса + ", ";
			КонецЦикла;
			ИндексСтрокой = СокрЛП(ИндексСтрокой);
			Если СтрДлина(ИндексСтрокой) > 0 Тогда
				ИндексСтрокой = Лев(ИндексСтрокой, СтрДлина(ИндексСтрокой) - 1);
			КонецЕсли;
			
			СтруктурныйОбъект.Индексы.Добавить(ИндексСтрокой);
		КонецЦикла;
		Для Каждого СтрокаXDTO Из ОбъектXDTO.row Цикл
			
			СтрокаТЗ = СтруктурныйОбъект.Добавить();
			
			ЧислоКолонок = СтруктурныйОбъект.Колонки.Количество();
			Для Индекс = 0 По ЧислоКолонок - 1 Цикл 
				СтрокаТЗ[СтруктурныйОбъект.Колонки[Индекс].Имя] = ЗначениеXDTOВЗначениеТипа(СтрокаXDTO.value[Индекс]);
			КонецЦикла;
			
		КонецЦикла;
		
		Возврат СтруктурныйОбъект;
		
	КонецЕсли;
	
КонецФункции

Функция ВозможностьЧтенияТипаДанныхXML(Знач ТипДанныхXML)
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Запись.ЗаписатьНачалоЭлемента("Dummy");
	Запись.ЗаписатьСоответствиеПространстваИмен("xsi", "http://www.w3.org/2001/XMLSchema-instance");
	Запись.ЗаписатьСоответствиеПространстваИмен("ns1", ТипДанныхXML.URIПространстваИмен);
	Запись.ЗаписатьАтрибут("xsi:type", "ns1:" + ТипДанныхXML.ИмяТипа);
	Запись.ЗаписатьКонецЭлемента();
	
	Строка = Запись.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(Строка);
	Чтение.ПерейтиКСодержимому();
	
	Возврат СериализаторXDTO.ВозможностьЧтенияXML(Чтение);
	
КонецФункции

// Получает значение простейшего типа в контексте XDTO.
//
// Параметры:
// ЗначениеТипа - Значение произвольного типа.
//
// Возвращаемое значение:
// Произвольный тип. 
//
Функция ЗначениеТипаВЗначениеXDTO(Знач ЗначениеТипа)
	
	Если ЗначениеТипа = Неопределено
		Или ТипЗнч(ЗначениеТипа) = Тип("ОбъектXDTO")
		Или ТипЗнч(ЗначениеТипа) = Тип("ЗначениеXDTO") Тогда
		
		Возврат ЗначениеТипа;
		
	Иначе
		
		Если ТипЗнч(ЗначениеТипа) = Тип("Строка") Тогда
			ТипXDTO = ФабрикаXDTO.Тип("http://www.w3.org/2001/XMLSchema", "string")
		Иначе
			ТипXML = СериализаторXDTO.XMLТипЗнч(ЗначениеТипа);
			ТипXDTO = ФабрикаXDTO.Тип(ТипXML);
		КонецЕсли;
		
		Если ТипЗнч(ТипXDTO) = Тип("ТипОбъектаXDTO") Тогда // Значение структурного типа.
			Возврат СтруктурныйОбъектВОбъектXDTO(ЗначениеТипа);
		Иначе
			Возврат ФабрикаXDTO.Создать(ТипXDTO, ЗначениеТипа); // Например, UUID.
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

// Получает платформенный аналог значения XDTO-типа.
//
// Параметры:
// ЗначениеXDTO - Значение произвольного XDTO-типа.
//
// Возвращаемое значение:
// Произвольный тип. 
//
Функция ЗначениеXDTOВЗначениеТипа(ЗначениеXDTO)
	
	Если ТипЗнч(ЗначениеXDTO) = Тип("ЗначениеXDTO") Тогда
		Возврат ЗначениеXDTO.Значение;
	ИначеЕсли ТипЗнч(ЗначениеXDTO) = Тип("ОбъектXDTO") Тогда
		Возврат ОбъектXDTOВСтруктурныйОбъект(ЗначениеXDTO);
	Иначе
		Возврат ЗначениеXDTO;
	КонецЕсли;
	
КонецФункции

// Заполняет область поставляемыми данными при подготовке к использованию.
//
// Параметры:
//   ОбластьДанных - номер заполняемой области.
//   ИДФайлаВыгрузки - ид файла начальных данных.
//   Вариант - вариант начальных данных.
//   РежимИспользования - демо или рабочий.
//
// Возвращаемое значение:
//  Строка - один из вариантов "Успех", "ФатальнаяОшибка".
//
Функция ЗагрузитьОбластьИзПоставляемыхДанных(Знач ОбластьДанных, Знач ИДФайлаВыгрузки, Знач Вариант, СообщениеОФатальнойОшибке)
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	ФайлДанныхНайден = Ложь;
	
	Фильтр = Новый Массив();
	Фильтр.Добавить(Новый Структура("Код, Значение", "ИмяКонфигурации", Метаданные.Имя));
	Фильтр.Добавить(Новый Структура("Код, Значение", "ВерсияКонфигурации", Метаданные.Версия));
	Фильтр.Добавить(Новый Структура("Код, Значение", "Вариант", Вариант));
	Фильтр.Добавить(Новый Структура("Код, Значение", "Режим", 
		?(Константы.РежимИспользованияИнформационнойБазы.Получить() 
			= Перечисления.РежимыИспользованияИнформационнойБазы.Демонстрационный, 
			"Демонстрационный", "Рабочий")));

	Дескриптор = ПоставляемыеДанные.ДескрипторПоставляемыхДанныхИзКэша(ИДФайлаВыгрузки);
	Если Дескриптор <> Неопределено Тогда
		Если ПоставляемыеДанные.ХарактеристикиСовпадают(Фильтр, Дескриптор.Характеристики) Тогда
			ДанныеЭталона = ПоставляемыеДанные.ПоставляемыеДанныеИзКэша(ИДФайлаВыгрузки);
			ИмяФайлаВыгрузки = ПолучитьИмяВременногоФайла();
			ДанныеЭталона.Записать(ИмяФайлаВыгрузки);
			ФайлДанныхНайден = Истина;
		Иначе
			СообщениеОФатальнойОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Указанный файл начальных данных не подходит для данной конфигурации.
					|Дескриптор файла: %1'"),
				ПоставляемыеДанные.ПолучитьОписаниеДанных(Дескриптор));
			Возврат "ФатальнаяОшибка";
		КонецЕсли;
	КонецЕсли;
	
	Если Не ФайлДанныхНайден Тогда
	
		Дескрипторы = ПоставляемыеДанные.ДескрипторыПоставляемыхДанныхИзМенеджера("ЭталонОбластиДанных", Фильтр);
	
		Если Дескрипторы.Descriptor.Количество() = 0 Тогда
			СообщениеОФатальнойОшибке = 
			НСтр("ru = 'В менеджере сервиса нет файла начальных данных для текущей версии конфигурации.'");
			Возврат "ФатальнаяОшибка";
		КонецЕсли;
		
		Если Дескрипторы.Descriptor[0].FileGUID <> ИДФайлаВыгрузки Тогда
			СообщениеОФатальнойОшибке = 
			НСтр("ru = 'Файл начальных данных, имеющийся в менеджере сервиса, отличается от указанного в сообщении на подготовку области. Область не может быть подготовлена.'");
			Возврат "ФатальнаяОшибка";
		КонецЕсли;
		
		ИмяФайлаВыгрузки = ПолучитьФайлИзХранилищаМенеджераСервиса(ИДФайлаВыгрузки);
			
		Если ИмяФайлаВыгрузки = Неопределено Тогда
			СообщениеОФатальнойОшибке = 
			НСтр("ru = 'В менеджере сервиса больше нет требуемого файла начальных данных, вероятно он был заменен. Область не может быть подготовлена.'");
			Возврат Ложь;
		КонецЕсли;
		
		ПоставляемыеДанные.СохранитьПоставляемыеДанныеВКэш(Дескрипторы.Descriptor[0], ИмяФайлаВыгрузки);
		
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.РаботаВМоделиСервиса.ВыгрузкаЗагрузкаОбластейДанных") Тогда
		
		ВызватьИсключениеОтсутствуетПодсистемаБТС("ТехнологияСервиса.РаботаВМоделиСервиса.ВыгрузкаЗагрузкаОбластейДанных");
		
	КонецЕсли;
	
	МодульВыгрузкаЗагрузкаОбластейДанных = ОбщегоНазначения.ОбщийМодуль("ВыгрузкаЗагрузкаОбластейДанных");
	
	Попытка
		
		ЗагружатьПользователейИБ = Ложь;
		СвернутьПользователей = (Не Константы.РежимИспользованияИнформационнойБазы.Получить() = Перечисления.РежимыИспользованияИнформационнойБазы.Демонстрационный);
		МодульВыгрузкаЗагрузкаОбластейДанных.ЗагрузитьТекущуюОбластьДанныхИзАрхива(ИмяФайлаВыгрузки, ЗагружатьПользователейИБ, СвернутьПользователей);
		
	Исключение
		
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Попытка
			УдалитьФайлы(ИмяФайлаВыгрузки);
		Исключение
			ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
				УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		ВызватьИсключение;
	КонецПопытки;
	
	Попытка
		УдалитьФайлы(ИмяФайлаВыгрузки);
	Исключение
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат "Успех";

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Контроль неразделенных данных.

// Вызывается при проверке доступности неразделенных данных для записи.
//
Процедура КонтрольНеразделенныхДанныхПриЗаписи(Знач Источник)
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		ПредставлениеИсключения = НСтр("ru = 'Нарушение прав доступа!'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка());
		
		ЗаписьЖурналаРегистрации(
			ПредставлениеИсключения,
			УровеньЖурналаРегистрации.Ошибка,
			Источник.Метаданные());
		
		ВызватьИсключение ПредставлениеИсключения;
		
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработка вспомогательных данных области.

// Выполняет обработку значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - значение ссылочного типа или УдалениеОбъекта,
//  Записать - Булево, признак выполнения записи значения ссылочного типа,
//  Удалить - Булево, признак выполнения удаления значения ссылочного типа.
//
Процедура ОбработатьВспомогательныеДанные(ОбъектВспомогательныхДанных, Знач Записать, Знач Удалить)
	
	Попытка
		
		ТребуетсяВосстановлениеРазделенияСеанса = Ложь;
		
		Если ТипЗнч(ОбъектВспомогательныхДанных) = Тип("УдалениеОбъекта") Тогда
			ПроверяемоеЗначение = ОбъектВспомогательныхДанных.Ссылка;
			ПроверяетсяСсылка = Истина;
		Иначе
			ПроверяемоеЗначение = ОбъектВспомогательныхДанных;
			ПроверяетсяСсылка = Ложь;
		КонецЕсли;
		
		Если Не МонопольныйРежим() И ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(ПроверяемоеЗначение.Метаданные(), ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()) Тогда
			
			Если ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
				
				// В разделенном сеансе достаточно просто выполнить запись объекта.
				Если Записать Тогда
					ОбъектВспомогательныхДанных.Записать();
				КонецЕсли;
				Если Удалить Тогда
					ОбъектВспомогательныхДанных.Удалить();
				КонецЕсли;
				
			Иначе
				
				// В неразделенном сеансе требуется переключение разделения сеанса для избежания
				// конфликта блокировок с сеансами, в которых установлено другое значение разделителя.
				Если ПроверяетсяСсылка Тогда
					ЗначениеРазделителя = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ПроверяемоеЗначение, ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных());
				Иначе
					ЗначениеРазделителя = ОбъектВспомогательныхДанных[ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных()];
				КонецЕсли;
				ОбщегоНазначения.УстановитьРазделениеСеанса(Истина, ЗначениеРазделителя);
				ТребуетсяВосстановлениеРазделенияСеанса = Истина;
				Если Записать Тогда
					ОбъектВспомогательныхДанных.Записать();
				КонецЕсли;
				Если Удалить Тогда
					ОбъектВспомогательныхДанных.Удалить();
				КонецЕсли;
				
			КонецЕсли;
			
		Иначе
			
			Если Записать Тогда
				ОбъектВспомогательныхДанных.Записать();
			КонецЕсли;
			Если Удалить Тогда
				ОбъектВспомогательныхДанных.Удалить();
			КонецЕсли;
			
		КонецЕсли;
		
		Если ТребуетсяВосстановлениеРазделенияСеанса Тогда
			ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		КонецЕсли;
		
	Исключение
		
		Если ТребуетсяВосстановлениеРазделенияСеанса Тогда
			ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		КонецЕсли;
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ОБРАБОТЧИКИ ПОЛУЧЕНИЯ ПОСТАВЛЯЕМЫХ ДАННЫХ

Процедура ОбработатьПоставляемыйЭталонКонфигурации(Знач Дескриптор, Знач ПутьКФайлу)
	
	Если ЗначениеЗаполнено(ПутьКФайлу) Тогда
		
		ПоставляемыеДанные.СохранитьПоставляемыеДанныеВКэш(Дескриптор, ПутьКФайлу);
		
	Иначе
		
		Фильтр = Новый Массив;
		Для каждого Характеристика Из Дескриптор.Properties.Property Цикл
			Если Характеристика.IsKey Тогда
				Фильтр.Добавить(Новый Структура("Код, Значение", Характеристика.Code, Характеристика.Value));
			КонецЕсли;
		КонецЦикла;

		Для каждого Ссылка Из ПоставляемыеДанные.СсылкиПоставляемыхДанныхИзКэша(Дескриптор.DataType, Фильтр) Цикл
		
			ПоставляемыеДанные.УдалитьПоставляемыеДанныеИзКэша(Ссылка);
		
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ОБРАБОТЧИКИ ОБНОВЛЕНИЯ ИНФОРМАЦИОННОЙ БАЗЫ

// Переносит данные из РС УдалитьОбластиДанных в РС ОбластиДанных.
//
Процедура ПеренестиОбластиДанных() Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ЕСТЬNULL(ОбластиДанных.ОбластьДанныхВспомогательныеДанные, УдалитьОбластиДанных.ОбластьДанных) КАК ОбластьДанныхВспомогательныеДанные,
		|	УдалитьОбластиДанных.Представление,
		|	ЕСТЬNULL(ОбластиДанных.Статус, УдалитьОбластиДанных.Статус) КАК Статус,
		|	УдалитьОбластиДанных.Префикс,
		|	ЕСТЬNULL(ОбластиДанных.Повтор, УдалитьОбластиДанных.Повтор) КАК Повтор,
		|	УдалитьОбластиДанных.ЧасовойПояс,
		|	ЕСТЬNULL(ОбластиДанных.ИдентификаторВыгрузки, УдалитьОбластиДанных.ИдентификаторВыгрузки) КАК ИдентификаторВыгрузки,
		|	ЕСТЬNULL(ОбластиДанных.ОшибкаОбработки, УдалитьОбластиДанных.ОшибкаОбработки) КАК ОшибкаОбработки,
		|	ЕСТЬNULL(ОбластиДанных.Вариант, УдалитьОбластиДанных.Вариант) КАК Вариант
		|ИЗ
		|	РегистрСведений.УдалитьОбластиДанных КАК УдалитьОбластиДанных
		|		ПОЛНОЕ СОЕДИНЕНИЕ РегистрСведений.ОбластиДанных КАК ОбластиДанных
		|		ПО УдалитьОбластиДанных.ОбластьДанных = ОбластиДанных.ОбластьДанныхВспомогательныеДанные";		Запрос = Новый Запрос(ТекстЗапроса);
		ТаблицаПереноса = Запрос.Выполнить().Выгрузить();
		
		Для Каждого Перенос Из ТаблицаПереноса Цикл
			
			Менеджер = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
			Менеджер.ОбластьДанныхВспомогательныеДанные = Перенос.ОбластьДанныхВспомогательныеДанные;
			Менеджер.Прочитать();
			Если Не Менеджер.Выбран() Тогда
				ЗаполнитьЗначенияСвойств(Менеджер, Перенос);
				Менеджер.Записать();
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Перенос.Представление) Тогда
				
				Менеджер = Константы.ПредставлениеОбластиДанных.СоздатьМенеджерЗначения();
				Менеджер.ОбластьДанныхВспомогательныеДанные = Перенос.ОбластьДанныхВспомогательныеДанные;
				Менеджер.Прочитать();
				Если Не ЗначениеЗаполнено(Менеджер.Значение) Тогда
					Менеджер.Значение = Перенос.Представление;
					Менеджер.Записать();
				КонецЕсли;
				
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Перенос.Префикс) Тогда
				
				Менеджер = Константы.ПрефиксОбластиДанных.СоздатьМенеджерЗначения();
				Менеджер.ОбластьДанныхВспомогательныеДанные = Перенос.ОбластьДанныхВспомогательныеДанные;
				Менеджер.Прочитать();
				Если Не ЗначениеЗаполнено(Менеджер.Значение) Тогда
					Менеджер.Значение = Перенос.Префикс;
					Менеджер.Записать();
				КонецЕсли;
				
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Перенос.ЧасовойПояс) Тогда
				
				Менеджер = Константы.ЧасовойПоясОбластиДанных.СоздатьМенеджерЗначения();
				Менеджер.ОбластьДанныхВспомогательныеДанные = Перенос.ОбластьДанныхВспомогательныеДанные;
				Менеджер.Прочитать();
				Если Не ЗначениеЗаполнено(Менеджер.Значение) Тогда
					Менеджер.Значение = Перенос.ЧасовойПояс;
					Менеджер.Записать();
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Отключает для пользователей информационной базы использование разделителя.
// ОбластьДанныхВспомогательныеДанные.
//
Процедура ОтключитьРазделениеПользователейПоРазделителюВнутреннихДанных() Экспорт
	
	ПользователиИБ = ПользователиИнформационнойБазы.ПолучитьПользователей();
	Для Каждого ПользовательИБ Из ПользователиИБ Цикл
		
		Если ПользовательИБ.РазделениеДанных.Свойство(РазделительВспомогательныхДанных()) Тогда
			ПользовательИБ.РазделениеДанных.Удалить(РазделительВспомогательныхДанных());
			ПользовательИБ.Записать();
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Выполняет контроль структуры метаданных по критерию недоступности неразделенных данных
// для записи из сеансов с включенным разделением.
//
Процедура КонтрольНеразделенныхДанныхПриОбновлении() Экспорт
	
	ПравилаКонтроляМетаданных = Новый Соответствие;
	
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Константы, "КонстантаМенеджерЗначения.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Справочники, "СправочникОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Документы, "ДокументОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.БизнесПроцессы, "БизнесПроцессОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Задачи, "ЗадачаОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыВидовРасчета, "ПланВидовРасчетаОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыВидовХарактеристик, "ПланВидовХарактеристикОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыОбмена, "ПланОбменаОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыСчетов, "ПланСчетовОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыБухгалтерии, "РегистрБухгалтерииНаборЗаписей.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыНакопления, "РегистрНакопленияНаборЗаписей.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыРасчета, "РегистрРасчетаНаборЗаписей.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыСведений, "РегистрСведенийНаборЗаписей.%1");
	
	Исключения = Новый Массив();
	
	Исключения.Добавить(Метаданные.РегистрыСведений.КэшПрограммныхИнтерфейсов);
	Исключения.Добавить(Метаданные.Константы.БлокировкаОтправкиБыстрыхСообщений);
	
	// СтандартныеПодсистемы.ОбменДанными
	Исключения.Добавить(Метаданные.РегистрыСведений.БезопасноеХранилищеДанных);
	Исключения.Добавить(Метаданные.РегистрыСведений.НастройкиТранспортаОбмена);
	Исключения.Добавить(Метаданные.РегистрыСведений.СостоянияОбменовДанными);
	Исключения.Добавить(Метаданные.РегистрыСведений.СостоянияУспешныхОбменовДанными);
	// Конец СтандартныеПодсистемы.ОбменДанными
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ОценкаПроизводительности") Тогда
		Исключения.Добавить(Метаданные.Справочники.Найти("КлючевыеОперации"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ЗамерыВремени"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ЗамерыВремениТехнологические"));
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЦентрМониторинга") Тогда
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ДампыПлатформы"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ОперацииСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("КомментарииСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ОбластиСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("КомментарииОперацииСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("БуферОперацийСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ЗамерыОперацииСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ЗамерыКомментарииСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ЗамерыОбластиСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("СтатистикаКонфигурации"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ПакетыДляОтправки"));
	КонецЕсли;
	
	ОбработчикиСобытия = ОбщегоНазначения.ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.РаботаВМоделиСервиса\ПриОпределенииИсключенийНеразделенныхДанных");
	Для каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриОпределенииИсключенийНеразделенныхДанных(Исключения)
	КонецЦикла;
	
	СтандартныеРазделители = Новый Массив;
	СтандартныеРазделители.Добавить(Метаданные.ОбщиеРеквизиты.ОбластьДанныхОсновныеДанные);
	СтандартныеРазделители.Добавить(Метаданные.ОбщиеРеквизиты.ОбластьДанныхВспомогательныеДанные);
	
	КонтрольныеПроцедуры = Новый Массив;
	КонтрольныеПроцедуры.Добавить(Метаданные.ПодпискиНаСобытия.КонтрольНеразделенныхНаборовЗаписейПриЗаписи.Обработчик);
	КонтрольныеПроцедуры.Добавить(Метаданные.ПодпискиНаСобытия.КонтрольНеразделенныхОбъектовПриЗаписи.Обработчик);
	
	КонтролирующиеПодписки = Новый Массив;
	Для Каждого ПодпискаНаСобытие Из Метаданные.ПодпискиНаСобытия Цикл
		Если КонтрольныеПроцедуры.Найти(ПодпискаНаСобытие.Обработчик) <> Неопределено Тогда
			КонтролирующиеПодписки.Добавить(ПодпискаНаСобытие);
		КонецЕсли;
	КонецЦикла;
	
	НарушенияКонтроляВключенияНеразделенныхДанныхВКонтролирующиеПодписки = Новый Массив();
	НарушенияКонтроляРазделенияОбъектовНесколькимиРазделителями = Новый Массив();
	
	Для Каждого ПравилоКонтроляМетаданных Из ПравилаКонтроляМетаданных Цикл
		
		КонтролируемыеОбъектыМетаданных = ПравилоКонтроляМетаданных.Ключ;
		КонструкторТипаОбъектовМетаданных = ПравилоКонтроляМетаданных.Значение;
		
		Для Каждого КонтролируемыйОбъектМетаданных Из КонтролируемыеОбъектыМетаданных Цикл
			
			// 1. Проверка объекта метаданных на разделение несколькими разделителями.
			
			ЧислоРазделителей = 0;
			Для Каждого СтандартныйРазделитель Из СтандартныеРазделители Цикл
				Если ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(КонтролируемыйОбъектМетаданных, СтандартныйРазделитель.Имя) Тогда
					ЧислоРазделителей = ЧислоРазделителей + 1;
				КонецЕсли;
			КонецЦикла;
			
			Если ЧислоРазделителей > 1 Тогда
				НарушенияКонтроляРазделенияОбъектовНесколькимиРазделителями.Добавить(КонтролируемыйОбъектМетаданных);
			КонецЕсли;
			
			// 2. Проверка неразделенных объектов метаданных на включение в состав контролирующих
			// подписок на события.
			
			Если ЗначениеЗаполнено(КонструкторТипаОбъектовМетаданных) Тогда
				
				Если Исключения.Найти(КонтролируемыйОбъектМетаданных) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				ТипОбъектаМетаданных = Тип(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(КонструкторТипаОбъектовМетаданных, КонтролируемыйОбъектМетаданных.Имя));
				
				ТребуетсяКонтроль = Истина;
				Для Каждого СтандартныйРазделитель Из СтандартныеРазделители Цикл
					
					Если ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(КонтролируемыйОбъектМетаданных, СтандартныйРазделитель.Имя) Тогда
						
						ТребуетсяКонтроль = Ложь;
						
					КонецЕсли;
					
				КонецЦикла;
				
				ОбеспеченКонтроль = Ложь;
				Если ТребуетсяКонтроль Тогда
					
					Для Каждого КонтролирующаяПодписка Из КонтролирующиеПодписки Цикл
						
						Если КонтролирующаяПодписка.Источник.СодержитТип(ТипОбъектаМетаданных) Тогда
							ОбеспеченКонтроль = Истина;
						КонецЕсли;
						
					КонецЦикла;
					
				КонецЕсли;
				
				Если ТребуетсяКонтроль И Не ОбеспеченКонтроль Тогда
					НарушенияКонтроляВключенияНеразделенныхДанныхВКонтролирующиеПодписки.Добавить(КонтролируемыйОбъектМетаданных);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ВызываемыеИсключения = Новый Массив();
	
	ТекстРазделителей = "";
	Для Каждого СтандартныйРазделитель Из СтандартныеРазделители Цикл
		
		Если Не ПустаяСтрока(ТекстРазделителей) Тогда
			ТекстРазделителей = ТекстРазделителей + ", ";
		КонецЕсли;
		
		ТекстРазделителей = ТекстРазделителей + СтандартныйРазделитель.Имя;
		
	КонецЦикла;
	
	Если НарушенияКонтроляВключенияНеразделенныхДанныхВКонтролирующиеПодписки.Количество() > 0 Тогда
		
		ТекстИсключения = "";
		Для Каждого НеконтролируемыйОбъектМетаданных Из НарушенияКонтроляВключенияНеразделенныхДанныхВКонтролирующиеПодписки Цикл
			
			Если Не ПустаяСтрока(ТекстИсключения) Тогда
				ТекстИсключения = ТекстИсключения + ", ";
			КонецЕсли;
			
			ТекстИсключения = ТекстИсключения + НеконтролируемыйОбъектМетаданных.ПолноеИмя();
			
		КонецЦикла;
		
		ТекстПодписок = "";
		Для Каждого КонтролирующаяПодписка Из КонтролирующиеПодписки Цикл
			
			Если Не ПустаяСтрока(ТекстПодписок) Тогда
				ТекстПодписок = ТекстПодписок + ", ";
			КонецЕсли;
			
			ТекстПодписок = ТекстПодписок + КонтролирующаяПодписка.Имя;
			
		КонецЦикла;
		
		ВызываемыеИсключения.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Все объекты метаданных, не входящие в состав разделителей БСП (%1),
                  |должны быть включены в состав подписок на события (%2), контролирующих
                  |невозможность записи неразделенных данных в разделенных сеансах.
                  |Следующие объекты метаданных не удовлетворяют этому критерию: %3.'"),
			ТекстРазделителей, ТекстПодписок, ТекстИсключения));
		
	КонецЕсли;
	
	Если НарушенияКонтроляРазделенияОбъектовНесколькимиРазделителями.Количество() > 0 Тогда
		
		ТекстИсключения = "";
		
		Для Каждого НарушающийОбъектМетаданных Из НарушенияКонтроляРазделенияОбъектовНесколькимиРазделителями Цикл
			
			Если Не ПустаяСтрока(ТекстИсключения) Тогда
				ТекстИсключения = ТекстИсключения + ", ";
			КонецЕсли;
			
			ТекстИсключения = ТекстИсключения + НарушающийОбъектМетаданных.ПолноеИмя();
			
		КонецЦикла;
		
		ВызываемыеИсключения.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Все объекты метаданных конфигурации должны быть разделены не более чем одним разделителем БСП (%1).
                  |Следующие объекты не удовлетворяют этому критерию: %2'"),
			ТекстРазделителей, ТекстИсключения));
		
	КонецЕсли;
	
	РезультирующееИсключение = "";
	Итератор = 1;
	
	Для Каждого ВызываемоеИсключение Из ВызываемыеИсключения Цикл
		
		Если Не ПустаяСтрока(РезультирующееИсключение) Тогда
			РезультирующееИсключение = РезультирующееИсключение + Символы.ПС + Символы.ВК;
		КонецЕсли;
		
		РезультирующееИсключение = РезультирующееИсключение + Формат(Итератор, "ЧДЦ=0; ЧГ=0") + ". " + ВызываемоеИсключение;
		Итератор = Итератор + 1;
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(РезультирующееИсключение) Тогда
		
		РезультирующееИсключение = НСтр("ru = 'Обнаружены ошибки в структуре метаданных конфигурации:'") + Символы.ПС + Символы.ВК + РезультирующееИсключение;
		ВызватьИсключение РезультирующееИсключение;
		
	КонецЕсли;
	
КонецПроцедуры

// Выполняет контроль структуры метаданных по критерию  упорядоченности общих реквизитов
// в дереве метаданных конфигурации.
//
Процедура КонтрольРазделителейПриОбновлении() Экспорт
	
	ПорядокПрикладныхДанных = 99;
	ПорядокВнутреннихДанных = 99;
	
	РазделительПрикладной = Метаданные.ОбщиеРеквизиты.ОбластьДанныхОсновныеДанные;
	РазделительВнутренний = Метаданные.ОбщиеРеквизиты.ОбластьДанныхВспомогательныеДанные;
	
	Итератор = 0;
	Для Каждого ОбщийРеквизитКонфигурации Из Метаданные.ОбщиеРеквизиты Цикл
		
		Если ОбщийРеквизитКонфигурации = РазделительПрикладной Тогда
			ПорядокПрикладныхДанных = Итератор;
		ИначеЕсли ОбщийРеквизитКонфигурации = РазделительВнутренний Тогда
			ПорядокВнутреннихДанных = Итератор;
		КонецЕсли;
		
		Итератор = Итератор + 1;
		
	КонецЦикла;
	
	Если ПорядокПрикладныхДанных <= ПорядокВнутреннихДанных Тогда
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Обнаружено нарушение структуры метаданных конфигурации: общий реквизит %1 должен
                  |быть расположен в дереве метаданных конфигурации до общего реквизита
                  |%2 по порядку!'"),
			РазделительВнутренний.Имя,
			РазделительПрикладной.Имя);
		
	КонецЕсли;
	
КонецПроцедуры

// Переносит записи из РС УдалитьРейтингАктивностиОбластейДанных в регистр РейтингАктивностиОбластейДанных.
//
Процедура ПеренестиРейтингАктивностиОбластейДанных() Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка = Новый БлокировкаДанных();
		Блокировка.Добавить("РегистрСведений.РейтингАктивностиОбластейДанных");
		Блокировка.Добавить("РегистрСведений.УдалитьРейтингАктивностиОбластейДанных");
		Блокировка.Заблокировать();
		
		РегистрыСведений.РейтингАктивностиОбластейДанных.СоздатьНаборЗаписей().Записать();
		
		Набор = Неопределено;
		
		Выборка = РегистрыСведений.УдалитьРейтингАктивностиОбластейДанных.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			Если Набор = Неопределено Тогда
				Набор = РегистрыСведений.РейтингАктивностиОбластейДанных.СоздатьНаборЗаписей();
			КонецЕсли;
			
			Запись = Набор.Добавить();
			Запись.ОбластьДанныхВспомогательныеДанные = Выборка.ОбластьДанных;
			Запись.Рейтинг = Выборка.Рейтинг;
			
			Если Набор.Количество() >= 10000 Тогда
				Набор.Записать(Ложь);
				Набор = Неопределено;
			КонецЕсли;
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Возвращает минимальную версию библиотеки "1С:Библиотека технологии сервиса", совместно с которой
// возможно использование текущей версии БСП.
//
// Возвращаемое значение: Строка, минимальная поддерживаемая версия БТС в формате РР.{П|ПП}.ЗЗ.СС.
//
Функция ТребуемаяВерсияБТС()
	
	Возврат "1.0.2.1";
	
КонецФункции

#КонецОбласти
