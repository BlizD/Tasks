////////////////////////////////////////////////////////////////////////////////
// Подсистема "Базовая функциональность".
// Серверные процедуры и функции общего назначения:
// - для работы с данными в базе;
// - для работы с прикладными типами и коллекциями значений;
// - математические процедуры и функции;
// - для работы с внешним соединением;
// - для работы с формами;
// - для работы с типами, объектами метаданных и их строковыми представлениями;
// - функции определения типов объектов метаданных;
// - сохранение, чтение и удаление настроек из хранилищ;
// - для работы с табличными документами;
// - для работы с журналом регистрации;
// - для работы в режиме разделения данных;
// - версионирование программных интерфейсов;
// - вспомогательные процедуры и функции.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с данными в базе.

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура.
//              Если в качестве объекта передана пустая ссылка, то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
	КонецЕсли;
	
	СтруктураРеквизитов = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура") Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		СтруктураРеквизитов = Реквизиты;
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Для Каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(СтрЗаменить(Реквизит, ".", ""), Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"), Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Ключ));
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции 

// Возвращает значения реквизитов, прочитанные из информационной базы
// для нескольких объектов.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа.
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИменаРеквизитов - Строка, имена реквизитов перечисленные через запятую,
//				в формате требований к свойствам структуры.
//				Например, "Код, Наименование, Родитель".
// 
// Возвращаемое значение:
//  Соответствие - где ключ - ссылка на объект, а Значение - структура, которая 
//		   		содержит список свойств, как список имен в строке.
//				ИменаРеквизитов, со значениям реквизитов, прочитанными из информационной базы.
// 
Функция ЗначенияРеквизитовОбъектов(МассивСсылок, ИменаРеквизитов) Экспорт
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если МассивСсылок.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Ссылка КАК Ссылка, " + ИменаРеквизитов + "
		|ИЗ
		|	" + МассивСсылок[0].Метаданные().ПолноеИмя() + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка В (&МассивСсылок)";
	Запрос.УстановитьПараметр("МассивСсылок", МассивСсылок);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(ИменаРеквизитов);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа.
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Соответствие - Ключ - ссылка на объект, Значение - значение прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита) Экспорт
	
	ЗначенияРеквизитов = ЗначенияРеквизитовОбъектов(МассивСсылок, ИмяРеквизита);
	Для Каждого Элемент Из ЗначенияРеквизитов Цикл
		ЗначенияРеквизитов[Элемент.Ключ] = Элемент.Значение[ИмяРеквизита];
	КонецЦикла;
		
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Проверяет проведенность документов.
//
// Параметры:
//  Документы - Массив - документы, проведенность которых необходимо проверить.
//
// Возвращаемое значение:
//  Массив - непроведенные документы из массива Документы.
//
Функция ПроверитьПроведенностьДокументов(Знач Документы) Экспорт
	
	Результат = Новый Массив;
	
	ШаблонЗапроса = 	
		"ВЫБРАТЬ
		|	ПсевдонимЗаданнойТаблицы.Ссылка КАК Ссылка
		|ИЗ
		|	&ИмяДокумента КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка В(&МассивДокументов)
		|	И НЕ ПсевдонимЗаданнойТаблицы.Проведен";
	
	ТекстОбъединитьВсе =
		"
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";
		
	ИменаДокументов = Новый Массив;
	Для Каждого Документ Из Документы Цикл
		МетаданныеДокумента = Документ.Метаданные();
		Если ИменаДокументов.Найти(МетаданныеДокумента.ПолноеИмя()) = Неопределено
			И Метаданные.Документы.Содержит(МетаданныеДокумента)
			И МетаданныеДокумента.Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить Тогда
				ИменаДокументов.Добавить(МетаданныеДокумента.ПолноеИмя());
		КонецЕсли;
	КонецЦикла;
	
	ТекстЗапроса = "";
	Для Каждого ИмяДокумента Из ИменаДокументов Цикл
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			ТекстЗапроса = ТекстЗапроса + ТекстОбъединитьВсе;
		КонецЕсли;
		ТекстПодзапроса = СтрЗаменить(ШаблонЗапроса, "&ИмяДокумента", ИмяДокумента);
		ТекстЗапроса = ТекстЗапроса + ТекстПодзапроса;
	КонецЦикла;
		
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("МассивДокументов", Документы);
	
	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
		Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Выполняет попытку проведения документов.
//
// Параметры:
//	Документы                - Массив - документы, которые необходимо провести.
//
// Возвращаемое значение:
//	Массив - массив структур с полями:
//			 Ссылка         - документ, который не удалось провести;
//			 ОписаниеОшибки - текст описания ошибки при проведении.
//
Функция ПровестиДокументы(Документы) Экспорт
	
	НепроведенныеДокументы = Новый Массив;
	
	Для Каждого ДокументСсылка Из Документы Цикл
		
		ВыполненоУспешно = Ложь;
		ДокументОбъект = ДокументСсылка.ПолучитьОбъект();
		Если ДокументОбъект.ПроверитьЗаполнение() Тогда
			РежимПроведения = РежимПроведенияДокумента.Неоперативный;
			Если ДокументОбъект.Дата >= НачалоДня(ТекущаяДатаСеанса())
				И ДокументСсылка.Метаданные().ОперативноеПроведение = Метаданные.СвойстваОбъектов.ОперативноеПроведение.Разрешить Тогда
					РежимПроведения = РежимПроведенияДокумента.Оперативный;
			КонецЕсли;
			Попытка
				ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение, РежимПроведения);
				ВыполненоУспешно = Истина;
			Исключение
				ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			КонецПопытки;
		Иначе
			ПредставлениеОшибки = НСтр("ru = 'Поля документа не заполнены.'");
		КонецЕсли;
		
		Если Не ВыполненоУспешно Тогда
			НепроведенныеДокументы.Добавить(Новый Структура("Ссылка,ОписаниеОшибки", ДокументСсылка, ПредставлениеОшибки));
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НепроведенныеДокументы;
	
КонецФункции 

// Проверяет наличие ссылок на объект в базе данных.
//
// Параметры:
//  Ссылка       - ЛюбаяСсылка
//               - Массив значений типа ЛюбаяСсылка.
//
//  ИскатьСредиСлужебныхОбъектов - Булево - начальное значение Ложь,
//                 когда установлено Истина, тогда не будут учитываться
//                 исключения поиска ссылок, заданные при разработке конфигурации.
//
//  ДругиеИсключения - Массив полных имен объектов метаданных, которые также
//                 требуется исключить из поиска ссылок.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьСсылкиНаОбъект(Знач СсылкаИлиМассивСсылок, Знач ИскатьСредиСлужебныхОбъектов = Ложь,  ДругиеИсключения = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ТипЗнч(СсылкаИлиМассивСсылок) = Тип("Массив") Тогда
		МассивСсылок = СсылкаИлиМассивСсылок;
	Иначе
		МассивСсылок = Новый Массив;
		МассивСсылок.Добавить(СсылкаИлиМассивСсылок);
	КонецЕсли;
	
	ТаблицаСсылок = НайтиПоСсылкам(МассивСсылок);
	ТаблицаСсылок.Колонки[0].Имя = "ИсходнаяСсылка";
	ТаблицаСсылок.Колонки[1].Имя = "ОбнаруженныйСсылка";
	ТаблицаСсылок.Колонки[2].Имя = "ОбнаруженныйМетаданные";
	
	Если НЕ ИскатьСредиСлужебныхОбъектов Тогда
		ИсключенияПоискаСсылок = ПолучитьОбщийСписокИсключенийПоискаСсылок();
		Исключения = Новый Массив;
		
		Для Каждого СтрокаТаблицы Из ТаблицаСсылок Цикл
			ИсключениеПоиска = ИсключенияПоискаСсылок[СтрокаТаблицы.ОбнаруженныйМетаданные];
			Если ИсключениеПоиска = "*" Тогда
				Исключения.Добавить(СтрокаТаблицы);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из Исключения Цикл
			ТаблицаСсылок.Удалить(СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли;
	
	Если ТипЗнч(ДругиеИсключения) = Тип("Массив") Тогда
		ИсключенияПоискаСсылок = Новый Соответствие;
		Исключения = Новый Массив;
		
		Для каждого ПолноеИмя Из ДругиеИсключения Цикл
			ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
			Если ОбъектМетаданных <> Неопределено Тогда
				ИсключенияПоискаСсылок.Вставить(ОбъектМетаданных, "*");
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из ТаблицаСсылок Цикл
			ИсключениеПоиска = ИсключенияПоискаСсылок[СтрокаТаблицы.ОбнаруженныйМетаданные];
			Если ИсключениеПоиска = "*" Тогда
				Исключения.Добавить(СтрокаТаблицы);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из Исключения Цикл
			ТаблицаСсылок.Удалить(СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТаблицаСсылок.Количество() > 0;
	
КонецФункции

// Производит замену ссылок во всех данных. После замены неиспользуемые ссылки опционально удаляются.
// Замена ссылок происходит с транзакциями по изменяемому объекту и его связям, не по анализируемой ссылке.
//
// Параметры:
//   ПарыЗамен - Соответствие - Пары замен.
//       * Ключ     - ЛюбаяСсылка - Что ищем (дубль).
//       * Значение - ЛюбаяСсылка - На что заменяем (оригинал).
//       Ссылки сами на себя и пустые ссылки для поиска будут проигнорированы.
//   
//   Параметры - Структура - Необязательный. Параметры замены.
//       
//       * СпособУдаления - Строка - Необязательный. Что делать с дублем после успешной замены.
//           ""                - По умолчанию. Не предпринимать никаких действий.
//           "Пометка"         - Помечать на удаление.
//           "Непосредственно" - Удалять непосредственно.
//       
//       * УчитыватьПрикладныеПравила - Булево - Необязательный. Режим проверки параметра ПарыЗамен.
//           Истина - По умолчанию. Проверять каждую пару "дубль-оригинал" (вызывается функция ВозможностьЗаменыЭлементов модуля менеджера).
//           Ложь   - Отключить прикладные проверки пар.
//       
//       * ВключатьБизнесЛогику - Булево - Необязательный. Режим записи мест использования при замене дублей на оригиналы.
//           Истина - По умолчанию. Места использования дублей записываются в режиме ОбменДанными.Загрузка = Ложь.
//           Ложь   - Запись ведется в режиме ОбменДанными.Загрузка = Истина.
//       
//       * ЗаменаПарыВТранзакции - Булево - Необязательный. Определяет размер транзакции.
//           Истина - По умолчанию. Транзакция охватывает все места использования одного дубля.
//           Ложь   - Замена каждого места использования выполняется в отдельной транзакции.
//       
//       * ПривилегированнаяЗапись - Булево - Необязательный. Требуется ли устанавливать привилегированный режим перед запись.
//           Ложь   - По умолчанию. Записывать с текущими правами.
//           Истина - Записывать в привилегированном режиме.
//
// Возвращаемое значение:
//   ТаблицаЗначений - Неуспешные замены (ошибки).
//       * Ссылка - ЛюбаяСсылка - Ссылка, которую заменяли.
//       * ОбъектОшибки - Произвольный - Объект - причина ошибки.
//       * ПредставлениеОбъектаОшибки - Строка - Строковое представление объекта ошибки.
//       * ТипОшибки - Строка - Тип ошибки:
//           "ОшибкаБлокировки"  - при обработке ссылки некоторые объекты были заблокированы.
//           "ДанныеИзменены"    - в процессе обработки данные были изменены другим пользователем.
//           "ОшибкаЗаписи"      - не смогли записать объект, или метод ВозможностьЗаменыЭлементов вернул отказ.
//           "ОшибкаУдаления"    - не смогли удалить объект.
//           "НеизвестныеДанные" - при обработке были найдены данные, которые не планировались к анализу, замена не реализована.
//       * ТекстОшибки - Строка - Подробное описание ошибки.
//
Функция ЗаменитьСсылки(Знач ПарыЗамен, Знач Параметры = Неопределено) Экспорт
	
	ТипСтрока = Новый ОписаниеТипов("Строка");
	
	ОшибкиЗамены = Новый ТаблицаЗначений;
	ОшибкиЗамены.Колонки.Добавить("Ссылка");
	ОшибкиЗамены.Колонки.Добавить("ОбъектОшибки");
	ОшибкиЗамены.Колонки.Добавить("ПредставлениеОбъектаОшибки", ТипСтрока);
	ОшибкиЗамены.Колонки.Добавить("ТипОшибки", ТипСтрока);
	ОшибкиЗамены.Колонки.Добавить("ТекстОшибки", ТипСтрока);
	
	ОшибкиЗамены.Индексы.Добавить("Ссылка");
	ОшибкиЗамены.Индексы.Добавить("Ссылка, ОбъектОшибки, ТипОшибки");
	
	Результат = Новый Структура;
	Результат.Вставить("ЕстьОшибки", Ложь);
	Результат.Вставить("Ошибки", ОшибкиЗамены);
	
	// Значения по умолчанию.
	ПараметрыВыполнения = Новый Структура;
	ПараметрыВыполнения.Вставить("УдалятьНепосредственно",     Ложь);
	ПараметрыВыполнения.Вставить("ПомечатьНаУдаление",         Ложь);
	ПараметрыВыполнения.Вставить("ВключатьБизнесЛогику",       Истина);
	ПараметрыВыполнения.Вставить("ПривилегированнаяЗапись",    Ложь);
	ПараметрыВыполнения.Вставить("УчитыватьПрикладныеПравила", Ложь);
	ДлиннаяТранзакция = Истина;
	
	// Переданные значения.
	ЗначениеПараметра = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Параметры, "СпособУдаления");
	Если ЗначениеПараметра = "Непосредственно" Тогда
		ПараметрыВыполнения.УдалятьНепосредственно = Истина;
		ПараметрыВыполнения.ПомечатьНаУдаление     = Ложь;
	ИначеЕсли ЗначениеПараметра = "Пометка" Тогда
		ПараметрыВыполнения.УдалятьНепосредственно = Ложь;
		ПараметрыВыполнения.ПомечатьНаУдаление     = Истина;
	КонецЕсли;
	
	ЗначениеПараметра = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Параметры, "ВключатьБизнесЛогику");
	Если ТипЗнч(ЗначениеПараметра) = Тип("Булево") Тогда
		ПараметрыВыполнения.ВключатьБизнесЛогику = ЗначениеПараметра;
	КонецЕсли;
	
	ЗначениеПараметра = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Параметры, "ЗаменаПарыВТранзакции");
	Если ТипЗнч(ЗначениеПараметра) = Тип("Булево") Тогда
		ДлиннаяТранзакция = ЗначениеПараметра;
	КонецЕсли;
	
	ЗначениеПараметра = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Параметры, "ПривилегированнаяЗапись");
	Если ТипЗнч(ЗначениеПараметра) = Тип("Булево") Тогда
		ПараметрыВыполнения.ПривилегированнаяЗапись = ЗначениеПараметра;
	КонецЕсли;
	
	ЗначениеПараметра = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Параметры, "УчитыватьПрикладныеПравила");
	Если ТипЗнч(ЗначениеПараметра) = Тип("Булево") Тогда
		ПараметрыВыполнения.УчитыватьПрикладныеПравила = ЗначениеПараметра;
	КонецЕсли;
	
	Если ПарыЗамен.Количество() = 0 Тогда
		Возврат Результат.Ошибки;
	КонецЕсли;
	
	Дубли = Новый Массив;
	Для Каждого КлючЗначение Из ПарыЗамен Цикл
		Дубль = КлючЗначение.Ключ;
		Оригинал = КлючЗначение.Значение;
		Если Дубль = Оригинал Или Дубль.Пустая() Тогда
			Продолжить; // Самого на себя и пустые ссылки не заменяем.
		КонецЕсли;
		Дубли.Добавить(Дубль);
		// Пропускаем промежуточные замены, чтобы не строить граф (если A->B и B->C то вместо A->B производится замена A->C).
		ОригиналОригинала = ПарыЗамен[Оригинал];
		ЕстьОригиналОригинала = (ОригиналОригинала <> Неопределено И ОригиналОригинала <> Дубль И ОригиналОригинала <> Оригинал);
		Если ЕстьОригиналОригинала Тогда
			Пока ЕстьОригиналОригинала Цикл
				Оригинал = ОригиналОригинала;
				ОригиналОригинала = ПарыЗамен[Оригинал];
				ЕстьОригиналОригинала = (ОригиналОригинала <> Неопределено И ОригиналОригинала <> Дубль И ОригиналОригинала <> Оригинал);
			КонецЦикла;
			ПарыЗамен.Вставить(Дубль, Оригинал);
		КонецЕсли;
	КонецЦикла;
	
	Если ПараметрыВыполнения.УчитыватьПрикладныеПравила И ПодсистемаСуществует("СтандартныеПодсистемы.ПоискИУдалениеДублей") Тогда
		МодульПоискИУдалениеДублей = ОбщийМодуль("ПоискИУдалениеДублей");
		Ошибки = МодульПоискИУдалениеДублей.ПроверитьВозможностьЗаменыЭлементов(ПарыЗамен, Параметры);
		Для Каждого КлючЗначение Из Ошибки Цикл
			Дубль = КлючЗначение.Ключ;
			Оригинал = ПарыЗамен[Дубль];
			ТекстОшибки = КлючЗначение.Значение;
			Причина = ОписаниеОшибкиЗамены("ОшибкаЗаписи", Оригинал, ПредметСтрокой(Оригинал), ТекстОшибки);
			ЗарегистрироватьОшибкуЗамены(Результат, Дубль, Причина);
			
			Индекс = Дубли.Найти(Дубль);
			Если Индекс <> Неопределено Тогда
				Дубли.Удалить(Индекс); // пропускаем проблемный элемент
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ТаблицаПоиска = МестаИспользования(Дубли);
	
	// Для каждой ссылки объекта будем производить замены в порядке "Константа", "Объект", "Набор".
	// Одновременно пустая строка в этой колонке - флаг того, что эта замена не нужна или уже была произведена.
	ТаблицаПоиска.Колонки.Добавить("КлючЗамены", ТипСтрока);
	ТаблицаПоиска.Индексы.Добавить("Ссылка, КлючЗамены");
	ТаблицаПоиска.Индексы.Добавить("Данные, КлючЗамены");
	
	// Вспомогательные данные
	ТаблицаПоиска.Колонки.Добавить("ЦелеваяСсылка");
	ТаблицаПоиска.Колонки.Добавить("Обработано", Новый ОписаниеТипов("Булево"));
	
	// Определяем порядок обработки и проверяем то, что мы можем обработать.
	Количество = Дубли.Количество();
	Для Номер = 1 По Количество Цикл
		ОбратныйИндекс = Количество - Номер;
		Дубль = Дубли[ОбратныйИндекс];
		РезультатРазметки = РазметитьМестаИспользования(ПараметрыВыполнения, Дубль, ПарыЗамен[Дубль], ТаблицаПоиска);
		Если Не РезультатРазметки.Успех Тогда
			// Найдены неизвестные типы замены, не будем работать с этой ссылкой, возможно нарушение связности.
			Дубли.Удалить(ОбратныйИндекс);
			Для Каждого Ошибка Из РезультатРазметки.ОшибкиРазметки Цикл
				ПредставлениеОбъектаОшибки = ПредметСтрокой(Ошибка.Объект);
				ЗарегистрироватьОшибкуЗамены(Результат, Дубль,
					ОписаниеОшибкиЗамены("НеизвестныеДанные", Ошибка.Объект, ПредставлениеОбъектаОшибки, Ошибка.Текст));
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	ПараметрыВыполнения.Вставить("ПарыЗамен",      ПарыЗамен);
	ПараметрыВыполнения.Вставить("УспешныеЗамены", Новый Соответствие);
	
	Если ДлиннаяТранзакция Тогда
		Для Каждого Дубль Из Дубли Цикл
			ЗаменитьСсылкуДлиннойТранзакцией(Результат, Дубль, ПараметрыВыполнения, ТаблицаПоиска);
		КонецЦикла;
	Иначе
		ЗаменитьСсылкиКороткимиТранзакциями(Результат, ПараметрыВыполнения, Дубли, ТаблицаПоиска);
	КонецЕсли;
	
	Возврат Результат.Ошибки;
КонецФункции

// Получает все места использования ссылок.
// Если какая-либо ссылка нигде не используется, то строк для нее в результирующей таблице не будет.
//
// Параметры:
//     НаборСсылок     - Массив - Ссылки, для которых ищем места использования.
//     АдресРезультата - Строка - Необязательный адрес во временном хранилище, куда будет помещен копия результата
//                                замены.
// 
// Возвращаемое значение:
//     ТаблицаЗначений - Состоит из колонок:
//       * Ссылка                - ЛюбаяСсылка      - Ссылка, которая анализируется.
//       * Данные                - Произвольный     - Данные, содержащие анализируемую ссылку.
//       * Метаданные            - ОбъектМетаданных - Метаданные найденных данных.
//       * ПредставлениеДанных   - Строка           - Представление данных, содержащих анализируемую ссылку.
//       * ТипСсылки             - Тип              - Тип анализируемой ссылки.
//       * ВспомогательныеДанные - Булево           - Истина, если данные используются анализируемой ссылкой как
//                                                    вспомогательными  данными (ведущее измерение и т.п.).
//
Функция МестаИспользования(Знач НаборСсылок, Знач АдресРезультата = "") Экспорт
	
	МестаИспользования = Новый ТаблицаЗначений;
	
	УстановитьПривилегированныйРежим(Истина);
	МестаИспользования = НайтиПоСсылкам(НаборСсылок);
	
	МестаИспользования.Колонки.Добавить("ПредставлениеДанных", Новый ОписаниеТипов("Строка"));
	МестаИспользования.Колонки.Добавить("ТипСсылки");
	МестаИспользования.Колонки.Добавить("ИнформацияОМестеИспользования");
	МестаИспользования.Колонки.Добавить("ВспомогательныеДанные", Новый ОписаниеТипов("Булево"));
	
	МестаИспользования.Индексы.Добавить("Ссылка");
	МестаИспользования.Индексы.Добавить("Данные");
	МестаИспользования.Индексы.Добавить("ВспомогательныеДанные");
	МестаИспользования.Индексы.Добавить("Ссылка, ВспомогательныеДанные");
	
	ТипКлючиЗаписей = ОписаниеТипаКлючиЗаписей();
	ТипВсеСсылки    = ОписаниеТипаВсеСсылки();
	
	МетаПоследовательности = Метаданные.Последовательности;
	МетаКонстанты          = Метаданные.Константы;
	МетаДокументы          = Метаданные.Документы;
	
	ИсключенияПоискаСсылок = ПолучитьОбщийСписокИсключенийПоискаСсылок();
	
	КэшИзмерений = Новый Соответствие;
	
	Для Каждого Строка Из МестаИспользования Цикл
		Ссылка    = Строка.Ссылка;
		Данные    = Строка.Данные;
		Мета      = Строка.Метаданные;
		ТипДанных = ТипЗнч(Данные);
		
		ИсключениеПоиска = ИсключенияПоискаСсылок[Мета];
		
		Если ИсключениеПоиска = Неопределено Тогда
			ЭтоВспомогательныеДанные = (Ссылка = Данные);
			
		ИначеЕсли ИсключениеПоиска = "*" Тогда
			ЭтоВспомогательныеДанные = Истина;
			
		Иначе
			ЭтоВспомогательныеДанные = Ложь;
			Для Каждого ПутьКРеквизиту Из ИсключениеПоиска Цикл
				Если Ссылка = ВычислитьЗначениеДанныхПоПути(Данные, ПутьКРеквизиту) Тогда
					ЭтоВспомогательныеДанные = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Если МетаДокументы.Содержит(Мета) Тогда
			Представление = Строка(Данные);
			
		ИначеЕсли МетаКонстанты.Содержит(Мета) Тогда
			Представление = Мета.Представление() + " (" + НСтр("ru = 'константа'") + ")";
			
		ИначеЕсли МетаПоследовательности.Содержит(Мета) Тогда
			Представление = Мета.Представление() + " (" + НСтр("ru = 'последовательность'") + ")";
			
		ИначеЕсли ТипДанных = Неопределено Тогда
			Представление = Строка(Данные);
			
		ИначеЕсли ТипВсеСсылки.СодержитТип(ТипДанных) Тогда
			МетаПредставлениеОбъекта = Новый Структура("ПредставлениеОбъекта");
			ЗаполнитьЗначенияСвойств(МетаПредставлениеОбъекта, Мета);
			Если ПустаяСтрока(МетаПредставлениеОбъекта.ПредставлениеОбъекта) Тогда
				МетаПредставление = Мета.Представление();
			Иначе
				МетаПредставление = МетаПредставлениеОбъекта.ПредставлениеОбъекта;
			КонецЕсли;
			Представление = Строка(Данные);
			Если Не ПустаяСтрока(МетаПредставление) Тогда
				Представление = Представление + " (" + МетаПредставление + ")";
			КонецЕсли;
			
		ИначеЕсли ТипКлючиЗаписей.СодержитТип(ТипДанных) Тогда
			Представление = Мета.ПредставлениеЗаписи;
			Если ПустаяСтрока(Представление) Тогда
				Представление = Мета.Представление();
			КонецЕсли;
			
			ОписаниеИзмерений = "";
			Для Каждого КлючЗначение Из ОписаниеИзмеренийНабора(Мета, КэшИзмерений) Цикл
				Значение = Данные[КлючЗначение.Ключ];
				Описание = КлючЗначение.Значение;
				Если Значение = Ссылка Тогда
					Если Описание.Ведущее Тогда
						ЭтоВспомогательныеДанные = Истина;
					КонецЕсли;
				КонецЕсли;
				Формат = Описание.Формат; 
				ОписаниеИзмерений = ОписаниеИзмерений + ", " 
					+ Описание.Представление + " """ + ?(Формат = Неопределено, Строка(Значение), Формат(Значение, Формат)) + """";
			КонецЦикла;
			ОписаниеИзмерений = Сред(ОписаниеИзмерений, 3);
			
			Если Не ПустаяСтрока(ОписаниеИзмерений) Тогда
				Представление = Представление + " (" + ОписаниеИзмерений + ")";
			КонецЕсли;
			
		Иначе
			Представление = Строка(Данные);
			
		КонецЕсли;
		
		Строка.ПредставлениеДанных   = Представление;
		Строка.ВспомогательныеДанные = ЭтоВспомогательныеДанные;
		Строка.ТипСсылки             = ТипЗнч(Строка.Ссылка);
	КонецЦикла;
	
	Если Не ПустаяСтрока(АдресРезультата) Тогда
		ПоместитьВоВременноеХранилище(МестаИспользования, АдресРезультата);
	КонецЕсли;
	
	Возврат МестаИспользования;
КонецФункции

// Возвращает описание типа, включающего в себя все возможные ссылочные типы конфигурации.
//
Функция ОписаниеТипаВсеСсылки() Экспорт
	
	Возврат Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(
		Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(
			Справочники.ТипВсеСсылки(),
			Документы.ТипВсеСсылки().Типы()),
			ПланыОбмена.ТипВсеСсылки().Типы()),
			Перечисления.ТипВсеСсылки().Типы()),
			ПланыВидовХарактеристик.ТипВсеСсылки().Типы()),
			ПланыСчетов.ТипВсеСсылки().Типы()),
			ПланыВидовРасчета.ТипВсеСсылки().Типы()),
			БизнесПроцессы.ТипВсеСсылки().Типы()),
			БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().Типы()),
			Задачи.ТипВсеСсылки().Типы());
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с прикладными типами и коллекциями значений.

// Получает имя значения перечисления как объекта метаданных.
//
// Параметры:
//  Значение - значение перечисления для которого необходимо получить имя перечисления.
//
// Возвращаемое значение:
//  Строка - имя значения перечисления как объекта метаданных.
//
Функция ИмяЗначенияПеречисления(Значение) Экспорт
	
	ОбъектМетаданных = Значение.Метаданные();
	
	ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);
	
	Возврат ОбъектМетаданных.ЗначенияПеречисления[ИндексЗначения].Имя;
	
КонецФункции 

// Устарела. Следует использовать ОбщегоНазначенияКлиентСервер.ДополнитьМассив,
// установив параметра ТолькоУникальныеЗначения в значение Истина.
//
// Заполняет массив-приемник уникальными значениями из массива-источника.
// Если элемент в массиве-приемнике уже существует, то добавления нового элемента не происходит.
//
// Параметры:
//  МассивПриемник - Массив - массив, который заполняется уникальными значениями.
//  МассивИсточник - Массив - массив, из которого подбираются элементы в массив-приемник.
// 
Процедура ЗаполнитьМассивУникальнымиЗначениями(МассивПриемник, МассивИсточник) Экспорт
	
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(МассивПриемник, МассивИсточник, Истина);
	
КонецПроцедуры

// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам 
// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
//
// Параметры:
//	МассивРеквизитов              - Массив - массив строк с именами реквизитов объекта.
//	МассивНепроверяемыхРеквизитов - Массив строк с именами реквизитов объекта, не требующих проверки.
//
Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл
	
		ПорядковыйНомер = МассивРеквизитов.Найти(ЭлементМассива);
		Если ПорядковыйНомер <> Неопределено Тогда
			МассивРеквизитов.Удалить(ПорядковыйНомер);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

//	Преобразует таблицу значений в массив.
//	Может использоваться для передачи на клиента данных, полученных
//	на сервере в виде таблицы значений в том случае, если таблица
//	значений содержит только такие значения, которые могут
//  быть переданы на клиента.
//
//	Полученный массив содержит структуры, каждая из которых повторяет
//	структуру колонок таблицы значений.
//
//	Не рекомендуется использовать для преобразования таблиц значений
//	с большим количеством строк.
//
//	Параметры: 
//    ТаблицаЗначений - ТаблицаЗначений.
//
//	Возвращаемое значение: 
//    Массив
//
Функция ТаблицаЗначенийВМассив(ТаблицаЗначений) Экспорт
	
	Массив = Новый Массив();
	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат Массив;

КонецФункции

// Функция СтрокаТаблицыЗначенийВСтруктуру создает
// структуру со свойствами, как колонки таблицы
// значений передаваемой строки
// и устанавливает этим свойствам значения
// из строки таблицы значений.
// 
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений.
//
// ВозвращаемоеЗначение:
//  Структура
//
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
	
	Структура = Новый Структура;
	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

// Создает структуру аналогичную менеджеру записи регистра сведений.
// 
// Параметры:
//	МенеджерЗаписи - РегистрСведенийМенеджерЗаписи,
//	МетаданныеРегистра - метаданные регистра сведений.
//
Функция СтруктураПоМенеджеруЗаписи(МенеджерЗаписи, МетаданныеРегистра) Экспорт
	
	ЗаписьКакСтруктура = Новый Структура;
	
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		ЗаписьКакСтруктура.Вставить("Период", МенеджерЗаписи.Период);
	КонецЕсли;
	Для Каждого Поле Из МетаданныеРегистра.Измерения Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Ресурсы Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Реквизиты Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	
	Возврат ЗаписьКакСтруктура;
	
КонецФункции

// Создает массив и копирует в него значения, содержащиеся в колонке коллекции строк.
//
// Параметры:
//	КоллекцияСтрок - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл.
//	ИмяКолонки - строка с именем поля коллекции, значения которого нужно выгрузить.
//	ТолькоУникальныеЗначения - булево, необязательный, если истина, 
//		то в массив будут включены только различающиеся значения.
//
Функция ВыгрузитьКолонку(КоллекцияСтрок, ИмяКолонки, ТолькоУникальныеЗначения = Ложь) Экспорт

	МассивЗначений = Новый Массив;
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого СтрокаКоллекции Из КоллекцияСтрок Цикл
		Значение = СтрокаКоллекции[ИмяКолонки];
		Если ТолькоУникальныеЗначения И УникальныеЗначения[Значение] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивЗначений.Добавить(Значение);
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла; 
	
	Возврат МассивЗначений;
	
КонецФункции

// Преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
//
// Параметры:
//  XML     - текст в формате XML или ЧтениеXML.
//
// Схема XML:
// <?xml version="1.0" encoding="utf-8"?>
//  <xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
//   <xs:element name="Items">
//    <xs:complexType>
//     <xs:sequence>
//      <xs:element maxOccurs="unbounded" name="Item">
//       <xs:complexType>
//        <xs:attribute name="Code" type="xs:integer" use="required" />
//        <xs:attribute name="Name" type="xs:string" use="required" />
//        <xs:attribute name="Socr" type="xs:string" use="required" />
//        <xs:attribute name="Index" type="xs:string" use="required" />
//       </xs:complexType>
//      </xs:element>
//     </xs:sequence>
//    <xs:attribute name="Description" type="xs:string" use="required" />
//    <xs:attribute name="Columns" type="xs:string" use="required" />
//   </xs:complexType>
//  </xs:element>
// </xs:schema>
//
// Примеры XML-файлов см. в демонстрационной конфигурации.
// 
// Пример использования:
//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(
//     Справочники.Валюты.ПолучитьМакет("ОбщероссийскийКлассификаторВалют").ПолучитьТекст()).Данные;
//
// Возвращаемое значение:
//  Структура - с полями 
//    * ИмяТаблицы - Строка
//    * Данные - ТаблицаЗначений.
//
Функция ПрочитатьXMLВТаблицу(Знач XML) Экспорт
	
	Если ТипЗнч(XML) <> Тип("ЧтениеXML") Тогда
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(XML);
	Иначе
		Чтение = XML;
	КонецЕсли;
	
	// Прочитаем первый узел и проверим его.
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение НСтр("ru = 'Пустой XML'");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее.
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице.
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла = ТипУзлаXML.КонецЭлемента И Чтение.Имя = "Items" Тогда
			Прервать;
		ИначеЕсли Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции

// Функция выполняет сравнение двух коллекций строк, для которых доступен обход 
// посредством оператора Для каждого … Из … Цикл.
// Сравниваемые коллекции должны отвечать следующим требованиям:
//  - доступен обход посредством оператора Для каждого … Из … Цикл,
//  - наличие в обеих коллекциях всех колонок, перечисленных в параметре ИменаКолонок 
//  (если ИменаКолонок не заполнен - всех колонок).
//  Так же позволяет сравнивать массивы.
//
// Параметры:
//	КоллекцияСтрок1 - КоллекцияЗначений - коллекция, отвечающая вышеописанным требованиям;
//	КоллекцияСтрок2 - КоллекцияЗначений - коллекция, отвечающая вышеописанным требованиям;
//	ИменаКолонок - Строка - имена колонок через запятую, 
//						по которым производится сравнение. 
//						Не является обязательным для коллекций, 
//						состав колонок которых можно выявить: 
//						ТаблицаЗначений, СписокЗначений, Соответствие, Структура,
//						если не указан - сравнение производится по всем колонкам.
//						Для коллекций других типов является обязательным.
//	ИсключаяКолонки - Строка - имена колонок, которые игнорируются при сравнении, необязательный.
//	УчитыватьПоследовательностьСтрок - Булево - если Истина, то коллекции признаются 
//						идентичными только если одинаковые строки размещены 
//						в коллекциях на одинаковых местах.
//
// Возвращаемое значение:
//  Булево.
//
Функция КоллекцииИдентичны(КоллекцияСтрок1, КоллекцияСтрок2, ИменаКолонок = "", ИсключаяКолонки = "", УчитыватьПоследовательностьСтрок = Ложь) Экспорт
	
	СравниваютсяМассивы = (ТипЗнч(КоллекцияСтрок1) = Тип("Массив")
	 Или ТипЗнч(КоллекцияСтрок1) = Тип("ФиксированныйМассив"));
	
	Если Не СравниваютсяМассивы Тогда
		
		// Типы коллекций, для которых доступен состав колонок,
		// и можно выявить, если он не задан.
		ТипыОсобыхКоллекций = Новый Массив;
		ТипыОсобыхКоллекций.Добавить(Тип("ТаблицаЗначений"));
		ТипыОсобыхКоллекций.Добавить(Тип("СписокЗначений"));
		
		ТипыКоллекцийКлючИЗначение = Новый Массив;
		ТипыКоллекцийКлючИЗначение.Добавить(Тип("Соответствие"));
		ТипыКоллекцийКлючИЗначение.Добавить(Тип("Структура"));
		ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированноеСоответствие"));
		ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированнаяСтруктура"));
		
		Если ПустаяСтрока(ИменаКолонок) Тогда
			Если ТипыОсобыхКоллекций.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено
				Или ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
				СравниваемыеКолонки = Новый Массив;
				Если ТипЗнч(КоллекцияСтрок1) = Тип("ТаблицаЗначений") Тогда
					Для Каждого Колонка Из КоллекцияСтрок1.Колонки Цикл
						СравниваемыеКолонки.Добавить(Колонка.Имя);
					КонецЦикла;
				ИначеЕсли ТипЗнч(КоллекцияСтрок1) = Тип("СписокЗначений") Тогда
					СравниваемыеКолонки.Добавить("Значение");
					СравниваемыеКолонки.Добавить("Картинка");
					СравниваемыеКолонки.Добавить("Пометка");
					СравниваемыеКолонки.Добавить("Представление");
				ИначеЕсли ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
					СравниваемыеКолонки.Добавить("Ключ");
					СравниваемыеКолонки.Добавить("Значение");
				КонецЕсли;
			Иначе
				ТекстИсключения = НСтр("ru = 'Для коллекции типа %1 необходимо указать имена полей, по которым производится сравнение'");
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИсключения, ТипЗнч(КоллекцияСтрок1));
			КонецЕсли;
		Иначе
			СравниваемыеКолонки = СтрРазделить(ИменаКолонок, ",");
		КонецЕсли;
		
		// Вычитаем исключаемые поля
		СравниваемыеКолонки = ОбщегоНазначенияКлиентСервер.СократитьМассив(СравниваемыеКолонки, СтрРазделить(ИсключаяКолонки, ","));
	КонецЕсли;
	
	Если УчитыватьПоследовательностьСтрок Тогда
		
		// Параллельный обход обеих коллекций.
		НомерСтрокиКоллекции1 = 0;
		Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
			// Спозиционируемся на аналогичную строку второй коллекции.
			НомерСтрокиКоллекции2 = 0;
			ЕстьСтрокиКоллекции2 = Ложь;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				ЕстьСтрокиКоллекции2 = Истина;
				Если НомерСтрокиКоллекции2 = НомерСтрокиКоллекции1 Тогда
					Прервать;
				КонецЕсли;
				НомерСтрокиКоллекции2 = НомерСтрокиКоллекции2 + 1;
			КонецЦикла;
			Если Не ЕстьСтрокиКоллекции2 Тогда
				// Во второй коллекции вообще нет строк.
				Возврат Ложь;
			КонецЕсли;
			// Сравниваем значения полей двух строк.
			Если СравниваютсяМассивы Тогда
				Если СтрокаКоллекции1 <> СтрокаКоллекции2 Тогда
					Возврат Ложь;
				КонецЕсли;
			Иначе
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаКоллекции2[ИмяКолонки] Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			НомерСтрокиКоллекции1 = НомерСтрокиКоллекции1 + 1;
		КонецЦикла;
		
		КоличествоСтрокКоллекции1 = НомерСтрокиКоллекции1;
		
		// Отдельно подсчитаем количество строк второй коллекции.
		КоличествоСтрокКоллекции2 = 0;
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			КоличествоСтрокКоллекции2 = КоличествоСтрокКоллекции2 + 1;
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй.
		Если КоличествоСтрокКоллекции1 = 0 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
			КоличествоСтрокКоллекции2 = 0;
		КонецЕсли;
		
		// Количество строк не должно отличаться.
		Если КоличествоСтрокКоллекции1 <> КоличествоСтрокКоллекции2 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	Иначе
		
		// Для массивов используется более простой алгоритм.
		Если СравниваютсяМассивы Тогда
			
			Если КоллекцияСтрок1.Количество() <> КоллекцияСтрок2.Количество() Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
				Если КоллекцияСтрок2.Найти(СтрокаКоллекции1) = Неопределено Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
			
		Иначе
			
			// Проверяем идентичность состава одинаковых строк без учета их последовательности.
			
			// Строки отбора накапливаем по первой коллекции для того, чтобы:
			//  - повторно не искать одинаковые строки,
			//  - убедиться, что во второй коллекции ни одной такой строки, которой нет в накопленных.
			
			СтрокиОтбора = Новый ТаблицаЗначений;
			ПараметрыОтбора = Новый Структура;
			Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
				СтрокиОтбора.Колонки.Добавить(ИмяКолонки);
				ПараметрыОтбора.Вставить(ИмяКолонки);
			КонецЦикла;
			
			ЕстьСтрокиКоллекции1 = Ложь;
			Для Каждого СтрокаОтбора Из КоллекцияСтрок1 Цикл
				
				ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаОтбора);
				Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() > 0 Тогда
					// Строку с такими полями уже искали.
					Продолжить;
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(СтрокиОтбора.Добавить(), СтрокаОтбора);
				
				// Подсчитаем количество таких строк в первой коллекции.
				НайденоСтрокКоллекции1 = 0;
				Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
					СтрокаПодходит = Истина;
					Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
						Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
							СтрокаПодходит = Ложь;
							Прервать;
						КонецЕсли;
					КонецЦикла;
					Если СтрокаПодходит Тогда
						НайденоСтрокКоллекции1 = НайденоСтрокКоллекции1 + 1;
					КонецЕсли;
				КонецЦикла;
				
				// Подсчитаем количество таких строк во второй коллекции.
				НайденоСтрокКоллекции2 = 0;
				Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
					СтрокаПодходит = Истина;
					Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
						Если СтрокаКоллекции2[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
							СтрокаПодходит = Ложь;
							Прервать;
						КонецЕсли;
					КонецЦикла;
					Если СтрокаПодходит Тогда
						НайденоСтрокКоллекции2 = НайденоСтрокКоллекции2 + 1;
						// Если количество таких строк во второй коллекции превысило количество в первой, 
						// то уже можно сделать вывод, что коллекции не идентичны.
						Если НайденоСтрокКоллекции2 > НайденоСтрокКоллекции1 Тогда
							Возврат Ложь;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
				
				// Количество таких строк не должно отличаться.
				Если НайденоСтрокКоллекции1 <> НайденоСтрокКоллекции2 Тогда
					Возврат Ложь;
				КонецЕсли;
				
				ЕстьСтрокиКоллекции1 = Истина;
				
			КонецЦикла;
			
			// Если в первой коллекции не оказалось строк, 
			// то их не должно быть и во второй.
			Если Не ЕстьСтрокиКоллекции1 Тогда
				Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
					Возврат Ложь;
				КонецЦикла;
			КонецЕсли;
			
			// Проверим, что во второй коллекции нет ни одной такой строки, которой нет в накопленных.
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаКоллекции2);
				Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() = 0 Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
	
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Сравнивает данные сложной структуры с учетом вложенности.
//
// Параметры:
//  Данные1 - Структура,    ФиксированнаяСтруктура -
//          - Соответствие, ФиксированноеСоответствие -
//          - Массив,       ФиксированныйМассив - 
//          - ХранилищеЗначения, ТаблицаЗначений - сложные типы для сравнения.
//          - Строка, Число, Булево - простые типы, которые можно сравнивать на равно.
//
//  Данные2 - Произвольный - те же типы, что и для параметра Данные1.
//
// Возвращаемое значение:
//  Булево.
//
Функция ДанныеСовпадают(Данные1, Данные2) Экспорт
	
	Если ТипЗнч(Данные1) <> ТипЗнч(Данные2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Данные1) = Тип("Структура")
	 ИЛИ ТипЗнч(Данные1) = Тип("ФиксированнаяСтруктура") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			СтароеЗначение = Неопределено;
			
			Если НЕ Данные2.Свойство(КлючИЗначение.Ключ, СтароеЗначение)
			 ИЛИ НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
			
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Соответствие")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированноеСоответствие") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		КлючиНовогоСоответствия = Новый Соответствие;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			КлючиНовогоСоответствия.Вставить(КлючИЗначение.Ключ, Истина);
			СтароеЗначение = Данные2.Получить(КлючИЗначение.Ключ);
			
			Если НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого КлючИЗначение Из Данные2 Цикл
			Если КлючиНовогоСоответствия[КлючИЗначение.Ключ] = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Массив")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированныйМассив") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Индекс = Данные1.Количество()-1;
		Пока Индекс >= 0 Цикл
			Если НЕ ДанныеСовпадают(Данные1.Получить(Индекс), Данные2.Получить(Индекс)) Тогда
				Возврат Ложь;
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ТаблицаЗначений") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если Данные1.Колонки.Количество() <> Данные2.Колонки.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Колонка Из Данные1.Колонки Цикл
			Если Данные2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Индекс = Данные1.Количество()-1;
			Пока Индекс >= 0 Цикл
				Если НЕ ДанныеСовпадают(Данные1[Индекс][Колонка.Имя], Данные2[Индекс][Колонка.Имя]) Тогда
					Возврат Ложь;
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ХранилищеЗначения") Тогда
	
		Если НЕ ДанныеСовпадают(Данные1.Получить(), Данные2.Получить()) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Возврат Истина;
	КонецЕсли;
	
	Возврат Данные1 = Данные2;
	
КонецФункции

// Фиксирует данные типов Структура, Соответствие, Массив с учетом вложенности.
//
// Параметры:
//  Данные - Структура, Соответствие, Массив - коллекции, значения которых являются примитивными типами,
//           хранилищем значения или не могут быть изменены. Поддерживаются типы значений:
//           Булево, Строка, Число, Дата, Неопределено, УникальныйИдентификатор, Null, Тип,
//           ХранилищеЗначения, ОбщийМодуль, ОбъектМетаданных, ТипЗначенияXDTO, ТипОбъектаXDTO,
//           ЛюбаяСсылка.
//
//  ВызыватьИсключение - Булево - начальное значение Истина. Когда установлено.
//                       Ложь, тогда в случае наличия нефиксируемых данных исключение не будет
//                       вызвано, при этом данные будут зафиксированы на сколько возможно.
//
// Возвращаемое значение:
//  Фиксированные данные, аналогичные переданным в параметре Данные.
// 
Функция ФиксированныеДанные(Данные, ВызыватьИсключение = Истина) Экспорт
	
	Если ТипЗнч(Данные) = Тип("Массив") Тогда
		Массив = Новый Массив;
		
		Индекс = Данные.Количество() - 1;
		
		Для каждого Значение Из Данные Цикл
			
			Если ТипЗнч(Значение) = Тип("Структура")
			 ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
			 ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Массив.Добавить(ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Массив.Добавить(Значение);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Новый ФиксированныйМассив(Массив);
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура")
	      ИЛИ ТипЗнч(Данные) = Тип("Соответствие") Тогда
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Коллекция = Новый Структура;
		Иначе
			Коллекция = Новый Соответствие;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные Цикл
			Значение = КлючИЗначение.Значение;
			
			Если ТипЗнч(Значение) = Тип("Структура")
			 ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
			 ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Коллекция.Вставить(
					КлючИЗначение.Ключ, ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Коллекция.Вставить(КлючИЗначение.Ключ, Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Возврат Новый ФиксированнаяСтруктура(Коллекция);
		Иначе
			Возврат Новый ФиксированноеСоответствие(Коллекция);
		КонецЕсли;
		
	ИначеЕсли ВызыватьИсключение Тогда
		ПроверкаФиксированностиДанных(Данные);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Создает копию объекта XDTO.
//
// Параметры:
//  Фабрика - ФабрикаXDTO - фабрика, которой создан исходный объект.
//  Объект  - ОбъектXDTO  - объект, копию которого требуется создать.
//
// Возвращаемое значение:
//  ОбъектXDTO - копия исходного объекта XDTO.
//
Функция СкопироватьXDTO(Знач Фабрика, Знач Объект) Экспорт
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Фабрика.ЗаписатьXML(Запись, Объект, , , , НазначениеТипаXML.Явное);
	
	XMLПредставление = Запись.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(XMLПредставление);
	
	Возврат Фабрика.ПрочитатьXML(Чтение, Объект.Тип());
	
КонецФункции

// Возвращает XML представление типа XDTO.
//
// Параметры:
//  ТипXDTO - ТипОбъектаXDTO, ТипЗначенияXDTO - тип XDTO для которого требуется получить.
//   XML представление.
//
// Возвращаемое значение:
//  Строка - XML представление типа XDTO.
//
Функция ПредставлениеТипаXDTO(ТипXDTO) Экспорт
	
	Возврат СериализаторXDTO.XMLСтрока(Новый РасширенноеИмяXML(ТипXDTO.URIПространстваИмен, ТипXDTO.Имя))
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Математические процедуры и функции.

// Выполняет пропорциональное распределение суммы в соответствии с заданными коэффициентами.
//
// Параметры:
//  РаспределяемаяСумма - Число;
//  КоэффициентыРаспределения - Массив;
//  ТочностьОкругления - Число.
//
// Возвращаемое значение:
//   Массив - список распределенных сумм.
//               В случае, если распределить не удалось (сумма = 0, кол-во коэффициентов = 0,
//               или суммарный вес коэффициентов = 0), возвращается значение Неопределено.
//
Функция РаспределитьСуммуПропорциональноКоэффициентам(Знач РаспределяемаяСумма, КоэффициентыРаспределения, Знач Точность = 2) Экспорт
	
	Возврат ОбщегоНазначенияКлиентСервер.РаспределитьСуммуПропорциональноКоэффициентам(РаспределяемаяСумма, КоэффициентыРаспределения, Точность);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с внешним соединением.

// Возвращает CLSID COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
// Параметры:
//  ИмяCOMСоединителя - Строка - имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
// Возвращаемое значение:
//  Строка - строковое представление CLSID.
//
Функция ИдентификаторCOMСоединителя(Знач ИмяCOMСоединителя) Экспорт
	
	Если ИмяCOMСоединителя = "v83.COMConnector" Тогда
		Возврат "181E893D-73A4-4722-B61D-D604B3D67D47";
	КонецЕсли;
	
	ТекстИсключения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'На задан CLSID для класса %1'"), ИмяCOMСоединителя);
	ВызватьИсключение ТекстИсключения;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции.

// Определяет режим эксплуатации информационной базы файловый (Истина) или серверный (Ложь).
// При проверке используется СтрокаСоединенияИнформационнойБазы, которую можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат СтрНайти(ВРег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

// Переводит параметры сеанса в состояние "Не установлено". 
// 
// Параметры: 
// ПараметрыДляОчистки - Строка - имена параметров сеанса для очистки, разделенные ",".
// Исключения          - Строка - имена параметров сеанса не предназначенные для очистки, разделенные ",".
//
Процедура ОчиститьПараметрыСеанса(ПараметрыДляОчистки = "", Исключения = "") Экспорт
	
	МассивИсключений = СтрРазделить(Исключения, ",");
	МассивПараметровДляОчистки = СтрРазделить(ПараметрыДляОчистки, ",", Ложь);
	
	Если МассивПараметровДляОчистки.Количество() = 0 Тогда
		Для Каждого ПараметрСеанса Из Метаданные.ПараметрыСеанса Цикл
			Если МассивИсключений.Найти(ПараметрСеанса.Имя) = Неопределено Тогда
				МассивПараметровДляОчистки.Добавить(ПараметрСеанса.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Индекс = МассивПараметровДляОчистки.Найти("ПараметрыКлиентаНаСервере");
	Если Индекс <> Неопределено Тогда
		МассивПараметровДляОчистки.Удалить(Индекс);
	КонецЕсли;
	
	Индекс = МассивПараметровДляОчистки.Найти("УстановленныеРасширения");
	Если Индекс <> Неопределено Тогда
		МассивПараметровДляОчистки.Удалить(Индекс);
	КонецЕсли;
	
	ПараметрыСеанса.Очистить(МассивПараметровДляОчистки);
	
КонецПроцедуры

// Возвращает описание предмета в виде текстовой строки.
// 
// Параметры:
//  СсылкаНаПредмет  - ЛюбаяСсылка - объект ссылочного типа.
//
// Возвращаемое значение:
//   Строка.
// 
Функция ПредметСтрокой(СсылкаНаПредмет) Экспорт
	
	Результат = "";
	
	Если СсылкаНаПредмет = Неопределено Или СсылкаНаПредмет.Пустая() Тогда
		Результат = НСтр("ru = 'не задан'");
	ИначеЕсли Метаданные.Документы.Содержит(СсылкаНаПредмет.Метаданные()) Тогда
		Результат = Строка(СсылкаНаПредмет);
	Иначе
		ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().ПредставлениеОбъекта;
		Если ПустаяСтрока(ПредставлениеОбъекта) Тогда
			ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().Представление();
		КонецЕсли;
		Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("%1 (%2)", Строка(СсылкаНаПредмет), ПредставлениеОбъекта);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует соответствие для удаления объектов.
//
// Возвращаемое значение:
//   Соответствие - Исключения поиска ссылок в разрезе объектов метаданных
//       * Ключ - ОбъектМетаданных - Объект метаданных, для которого применяются исключения.
//       * Значение - Строка, Массив - описание исключенных реквизитов.
//           - "*" - Исключены все реквизиты объекта метаданных.
//           - Массив из Строка - Относительные имена исключенных реквизитов.
//
Функция ПолучитьОбщийСписокИсключенийПоискаСсылок() Экспорт
	МассивИсключенийСобытия = Новый Массив;
	ОбработчикиСобытия = ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииИсключенийПоискаСсылок");
	Для Каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриДобавленииИсключенийПоискаСсылок(МассивИсключенийСобытия);
	КонецЦикла;
	
	МассивИсключенийПереопределения = Новый Массив;
	ОбщегоНазначенияПереопределяемый.ПриДобавленииИсключенийПоискаСсылок(МассивИсключенийПереопределения);
	
	Результат = Новый Соответствие;
	ДобавитьИсключенияПоискаСсылок(Результат, МассивИсключенийСобытия);
	ДобавитьИсключенияПоискаСсылок(Результат, МассивИсключенийПереопределения);
	Возврат Результат;
КонецФункции

// Возвращает значение в виде XML-строки.
// Преобразованы в XML-строку (сериализованы) могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
//   Значение - Произвольный. Значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
//   Строка - XML-строка представления значения в сериализованном виде.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Возвращает значение, полученное из XML-строки. 
// Получены из XML-строки могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
// СтрокаXML - строка представления значения в сериализованном виде.
//
// Возвращаемое значение:
// Значение, полученное из переданной XML-строки.
//
Функция ЗначениеИзСтрокиXML(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

// Возвращает XML-представление XDTO-объекта.
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO  - объект, для которого требуется сформировать XML-представление.
//  Фабрика    - ФабрикаXDTO - фабрика, с использованием которой требуется формировать XML-представление.
//                             Если параметр не указан - будет использоваться глобальная фабрика XDTO.
//
// Возвращаемое значение: 
//   Строка - XML-представление XDTO-объекта.
//
Функция ОбъектXDTOВСтрокуXML(Знач ОбъектXDTO, Знач Фабрика = Неопределено) Экспорт
	
	ОбъектXDTO.Проверить();
	
	Если Фабрика = Неопределено Тогда
		Фабрика = ФабрикаXDTO;
	КонецЕсли;
	
	Запись = Новый ЗаписьXML();
	Запись.УстановитьСтроку();
	Фабрика.ЗаписатьXML(Запись, ОбъектXDTO, , , , НазначениеТипаXML.Явное);
	
	Возврат Запись.Закрыть();
	
КонецФункции

// Формирует XDTO-объект по XML-представлению.
//
// Параметры:
//  СтрокаXML - Строка    - XML-представление XDTO-объекта,
//  Фабрика - ФабрикаXDTO - фабрика, с использованием которой требуется формировать XDTO-объект.
//                          Если параметр не указан - будет использоваться глобальная фабрика XDTO.
//
// Возвращаемое значение: 
//   ОбъектXDTO.
//
Функция ОбъектXDTOИзСтрокиXML(Знач СтрокаXML, Знач Фабрика = Неопределено) Экспорт
	
	Если Фабрика = Неопределено Тогда
		Фабрика = ФабрикаXDTO;
	КонецЕсли;
	
	Чтение = Новый ЧтениеXML();
	Чтение.УстановитьСтроку(СтрокаXML);
	
	Возврат Фабрика.ПрочитатьXML(Чтение);
	
КонецФункции

// Формирует из исходной строки СтрокаПоиска строку для поиска данных в запросе.
//
// Параметры:
//	СтрокаПоиска - Строка - исходная строка, содержащая запрещенные символы.
//
// Возвращаемое значение:
//  Строка - строка подготовленная для поиска данных в запросе.
//
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");
	
	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - месторасположение wsdl.
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса.
//  ИмяСервиса - Строка - имя сервиса.
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap.
//  ИмяПользователя - Строка - имя пользователя для входа на сервер.
//  Пароль - Строка - пароль пользователя.
//  Таймаут - Число - таймаут на операции выполняемые через полученное прокси.
//
// Возвращаемое значение:
//  WSПрокси
//
Функция WSПрокси(Знач АдресWSDL,
	Знач URIПространстваИмен,
	Знач ИмяСервиса,
	Знач ИмяТочкиПодключения = "",
	Знач ИмяПользователя,
	Знач Пароль,
	Знач Таймаут = 0,
	Знач ДелатьКонтрольныйВызов = Ложь) Экспорт

	Если ДелатьКонтрольныйВызов И Таймаут <> Неопределено И Таймаут > 20 Тогда
		
		WSПроксиPing = ОбщегоНазначенияПовтИсп.WSПрокси(
			АдресWSDL,
			URIПространстваИмен,
			ИмяСервиса,
			ИмяТочкиПодключения,
			ИмяПользователя,
			Пароль,
			3);
		
		Попытка
			WSПроксиPing.Ping();
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'WSПрокси'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ВызватьИсключение;
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат ОбщегоНазначенияПовтИсп.WSПрокси(
		АдресWSDL,
		URIПространстваИмен,
		ИмяСервиса,
		ИмяТочкиПодключения,
		ИмяПользователя,
		Пароль,
		Таймаут);
	
КонецФункции

// Определяет доступность объекта метаданных по функциональным опциям.
//
// Параметры:
//   ОбъектМетаданных - ОбъектМетаданных - проверяемый объект метаданных.
//
// Возвращаемое значение: 
//  Булево - Истина, если объект доступен.
//
Функция ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Экспорт
	Возврат ОбщегоНазначенияПовтИсп.ДоступностьОбъектовПоОпциям()[ОбъектМетаданных] <> Ложь;
КонецФункции

// Устанавливает или снимает пометку удаления для всех объектов, которые ссылаются на заданный "объект-владелец".
//
// Параметры:
//  Владелец        - ПланОбменаСсылка, СправочникСсылка, ДокументСсылка - ссылка на объект, который является
//                    "владельцем" по отношению к помечаемым на удаление объектам.
//
//  ПометкаУдаления - Булево - признак установки/снятия пометки на удаление у всех "подчиненных" объектов.
//
Процедура УстановитьПометкуУдаленияПодчиненнымОбъектам(Знач Владелец, Знач ПометкаУдаления) Экспорт
	
	НачатьТранзакцию();
	Попытка
		
		СписокСсылок = Новый Массив;
		СписокСсылок.Добавить(Владелец);
		Ссылки = НайтиПоСсылкам(СписокСсылок);
		
		Для Каждого Ссылка Из Ссылки Цикл
			
			Если ЗначениеСсылочногоТипа(Ссылка[1]) Тогда
				
				Ссылка[1].ПолучитьОбъект().УстановитьПометкуУдаления(ПометкаУдаления);
				
			КонецЕсли;
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Пытается выполнить запрос в несколько попыток.
// Используется для чтения вне транзакции часто изменяемых данных.
// При вызове в транзакции выдает ошибку.
//
// Параметры:
//  Запрос - Запрос - запрос который требуется выполнить.
//
// Возвращаемое значение:
//  РезультатЗапроса - результат выполнения запроса.
//
Функция ВыполнитьЗапросВнеТранзакции(Знач Запрос) Экспорт
	
	Если ТранзакцияАктивна() Тогда
		ВызватьИсключение(НСтр("ru = 'Транзакция активна. Выполнение запроса вне транзакции невозможно.'"));
	КонецЕсли;
	
	КоличествоПопыток = 0;
	
	Результат = Неопределено;
	Пока Истина Цикл
		Попытка
			Результат = Запрос.Выполнить(); // Чтение вне транзакции, возможно появление ошибки.
			                                // Could not continue scan with NOLOCK due to data movement
			                                // в этом случае нужно повторить попытку чтения.
			Прервать;
		Исключение
			КоличествоПопыток = КоличествоПопыток + 1;
			Если КоличествоПопыток = 5 Тогда
				ВызватьИсключение;
			КонецЕсли;
		КонецПопытки;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает общие параметры базовой функциональности.
//
// Возвращаемое значение: 
//  Структура - структура со свойствами:
//      * ИмяФормыПерсональныхНастроек            - Строка - имя формы для редактирования персональных настроек.
//                                                           Ранее определялись в
//                                                           ОбщегоНазначенияПереопределяемый.ИмяФормыПерсональныхНастроек.
//      * МинимальноНеобходимаяВерсияПлатформы    - Строка - полный номер версии платформы для запуска программы.
//                                                           Например, "8.3.4.365".
//                                                           Ранее определялись в
//                                                           ОбщегоНазначенияПереопределяемый.ПолучитьМинимальноНеобходимуюВерсиюПлатформы.
//      * РаботаВПрограммеЗапрещена               - Булево - Начальное значение Ложь.
//      * ЗапрашиватьПодтверждениеПриЗавершенииПрограммы - Булево - по умолчанию Истина. Если установить Ложь, то 
//                                                                  подтверждение при завершении работы программы не
//                                                                  будет запрашиваться,  если явно не разрешить в
//                                                                  персональных настройках программы.
//      * ОтключитьИдентификаторыОбъектовМетаданных - Булево - отключает заполнение справочников ИдентификаторыОбъектовМетаданных
//              и ИдентификаторыОбъектовРасширений, процедуру выгрузки и загрузки в узлах РИБ.
//              Для частичного встраивания отдельных функций библиотеки в конфигурации без постановки на поддержку.
//
Функция ОбщиеПараметрыБазовойФункциональности() Экспорт
	
	ОбщиеПараметры = Новый Структура;
	ОбщиеПараметры.Вставить("ИмяФормыПерсональныхНастроек", "");
	ОбщиеПараметры.Вставить("МинимальноНеобходимаяВерсияПлатформы", "8.3.6.2041");
	ОбщиеПараметры.Вставить("РаботаВПрограммеЗапрещена", Ложь); // Блокировать запуск, если версия ниже минимальной.
	ОбщиеПараметры.Вставить("ЗапрашиватьПодтверждениеПриЗавершенииПрограммы", Истина);
	ОбщиеПараметры.Вставить("ОтключитьИдентификаторыОбъектовМетаданных", Ложь);
	ОбщиеПараметры.Вставить("РекомендуемыйОбъемОперативнойПамяти", 2);
	
	ОбщегоНазначенияПереопределяемый.ПриОпределенииОбщихПараметровБазовойФункциональности(ОбщиеПараметры);
	
	Возврат ОбщиеПараметры;
	
КонецФункции

// Определяет, что эта информационная база является подчиненным узлом
// распределенной информационной базы (РИБ) с фильтром.
//
// Возвращаемое значение: 
//  Булево
//
Функция ЭтоПодчиненныйУзелРИБСФильтром() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ПланыОбмена.ГлавныйУзел() <> Неопределено
		И ПодсистемаСуществует("СтандартныеПодсистемы.ОбменДанными") Тогда
		ОбщийМодульОбменДаннымиСервер = ОбщийМодуль("ОбменДаннымиСервер");
		Если ОбщийМодульОбменДаннымиСервер.НазначениеПланаОбмена(ПланыОбмена.ГлавныйУзел().Метаданные().Имя) = "РИБСФильтром" Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Определяет, что эта информационная база является подчиненным узлом
// распределенной информационной базы (РИБ).
//
// Возвращаемое значение: 
//  Булево
//
Функция ЭтоПодчиненныйУзелРИБ() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат ПланыОбмена.ГлавныйУзел() <> Неопределено;
	
КонецФункции

// Возвращает признак принадлежности узла к плану обмена РИБ.
//
// Параметры:
//  УзелИнформационнойБазы - ПланОбменаСсылка - узел плана обмена, для которого требуется получить значение функции.
// 
//  Возвращаемое значение:
//   Истина - узел принадлежит плану обмена РИБ, иначе Ложь.
//
Функция ЭтоУзелРаспределеннойИнформационнойБазы(Знач УзелИнформационнойБазы) Экспорт

	Возврат ОбщегоНазначенияПовтИсп.ЭтоУзелРаспределеннойИнформационнойБазы(УзелИнформационнойБазы);
	
КонецФункции

// Возвращает Истина при необходимости обновления конфигурации информационной базы подчиненного узла РИБ.
// В главном узле всегда - Ложь.
//
// Возвращаемое значение: 
//  Булево
//
Функция ТребуетсяОбновлениеКонфигурацииПодчиненногоУзлаРИБ() Экспорт
	
	Возврат ЭтоПодчиненныйУзелРИБ() И КонфигурацияИзменена();
	
КонецФункции

// Возвращает Истина, если текущий сеанс выполняется на сервере, работающим под управлением ОС Linux.
//
// Возвращаемое значение:
//  Булево - Истина, если сервер работает под управлением ОС Linux.
//
Функция ЭтоLinuxСервер() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86 ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64;
	
КонецФункции

// Предназначена для вставки в начало обработчика ПриСозданииНаСервере управляемых форм, которые размещаются на рабочем
// столе.
//
// Предотвращает открытие формы в ряде особых случаев:
//  - если рабочий стол открывается до завершения обновления данных ИБ
//   (исключается возможность заведомо ошибочного обращения к еще необновленным данным);
//  - если в разделенную ИБ выполняется вход в сеансе с неустановленным значением разделителя
//  ОбластьДанныхОсновныеДанные
//   (исключается возможность заведомо ошибочного обращения к разделенным данным из неразделенного сеанса);
//
// Не следует использовать в формах, которые используются перед началом работы системы,
// а также в формах, предназначенных для работы в неразделенном сеансе.
//
// Параметры:
//  Форма - УправляемаяФорма - ссылка на форму, которая создается.
//  Отказ - Булево - параметр переданный в обработчик формы ПриСозданииНаСервере.
//  СтандартнаяОбработка - Булево - параметр переданный в обработчик формы ПриСозданииНаСервере.
//
// Возвращаемое значение:
//  Булево - если Ложь, значит установлен отказ создания формы.
//
Функция ПриСозданииНаСервере(Форма, Отказ, СтандартнаяОбработка) Экспорт
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено()
		И Не ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Отказ = Истина;
		Возврат Ложь;
	КонецЕсли;
	
	Если Форма.Параметры.Свойство("АвтоТест") Тогда
		// Возврат при получении формы для анализа.
		Возврат Ложь;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	Если ПараметрыСеанса.ПараметрыКлиентаНаСервере.Получить("СкрытьРабочийСтолПриНачалеРаботыСистемы") <> Неопределено Тогда
		Отказ = Истина;
		Возврат Ложь;
	КонецЕсли;
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат Истина;
	
КонецФункции

// Выполняет действия перед продолжением выполнения обработчика регламентного задания.
//
// Например, проверяет возможность выполнения обработчика регламентного задания.
// Если администратор не заблокировал выполнение регламентных заданий до
// окончания обновления ИБ, тогда требуется прекратить выполнение обработчика.
//
// Параметры:
//  РегламентноеЗадание - ОбъектМетаданных: РегламентноеЗадание - регламентное задание,
//    из которого был вызван данный метод. Необходимо передавать для проверки доступности
//    по функциональным опциям.
//
Процедура ПриНачалеВыполненияРегламентногоЗадания(РегламентноеЗадание = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Справочники.ВерсииРасширений.ЗарегистрироватьИспользованиеВерсииРасширений();
	УстановитьПривилегированныйРежим(Ложь);
	
	Если СтандартныеПодсистемыСервер.НеобходимоОбновлениеПараметровРаботыПрограммы() Тогда
		ВызватьИсключение
			НСтр("ru = 'Вход в программу временно невозможен в связи с обновлением на новую версию.
			           |Рекомендуется запрещать выполнение регламентных заданий на время обновления.'");
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ОбщегоНазначенияПовтИсп.РазделениеВключено()
	   И ПланыОбмена.ГлавныйУзел() = Неопределено
	   И ЗначениеЗаполнено(Константы.ГлавныйУзел.Получить()) Тогда
		
		ВызватьИсключение
			НСтр("ru = 'Вход в программу временно невозможен до восстановления связи с главным узлом.
			           |Рекомендуется запрещать выполнение регламентных заданий на время восстановления.'");
	КонецЕсли;
	
	Если РегламентноеЗадание <> Неопределено
		И ПодсистемаСуществует("СтандартныеПодсистемы.РегламентныеЗадания") Тогда
		МодульРегламентныеЗаданияСлужебный = ОбщийМодуль("РегламентныеЗаданияСлужебный");
		
		ЗависимостиЗаданий = Неопределено;
		МодульРегламентныеЗаданияСлужебный.ПроверитьВозможностьРаботыСВнешнимиРесурсами(
			РегламентноеЗадание, ЗависимостиЗаданий);
		
		Доступно = МодульРегламентныеЗаданияСлужебный.РегламентноеЗаданиеДоступноПоФункциональнымОпциям(
			РегламентноеЗадание, ЗависимостиЗаданий);
		Если Не Доступно Тогда
			ВызватьИсключение
				НСтр("ru = 'Регламентное задание недоступно по функциональным опциям
					|или не поддерживает работу в текущем режиме работы программы.
					|Выполнение прервано.'");
		КонецЕсли;
		
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает редакцию конфигурации.
// Редакцией принято называть две первые группы цифр полной версии конфигурации.
// Например, у версии "1.2.3.4" редакция "1.2".
//
// Возвращаемое значение:
//  Строка - номер редакции конфигурации.
//
Функция РедакцияКонфигурации() Экспорт
	
	Результат = "";
	ВерсияКонфигурации = Метаданные.Версия;
	
	Позиция = СтрНайти(ВерсияКонфигурации, ".");
	Если Позиция > 0 Тогда
		Результат = Лев(ВерсияКонфигурации, Позиция);
		ВерсияКонфигурации = Сред(ВерсияКонфигурации, Позиция + 1);
		Позиция = СтрНайти(ВерсияКонфигурации, ".");
		Если Позиция > 0 Тогда
			Результат = Результат + Лев(ВерсияКонфигурации, Позиция - 1);
		Иначе
			Результат = "";
		КонецЕсли;
	КонецЕсли;
	
	Если ПустаяСтрока(Результат) Тогда
		Результат = Метаданные.Версия;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает строковое представление интервала между переданными датами или
// относительно переданной даты и текущей даты сеанса.
//
// Параметры:
//  ВремяНачала    - Дата - начальная точка интервала.
//  ВремяОкончания - Дата - конечная точка интервала, если не задана - берется текущая дата сеанса.
//
Функция ИнтервалВремениСтрокой(ВремяНачала, ВремяОкончания = Неопределено) Экспорт
	
	Если ВремяОкончания = Неопределено Тогда
		ВремяОкончания = ТекущаяДатаСеанса();
	ИначеЕсли ВремяНачала > ВремяОкончания Тогда
		ВызватьИсключение НСтр("ru = 'Дата окончания интервала не может быть меньше даты начала.'");
	КонецЕсли;
	
	ВеличинаИнтервала = ВремяОкончания - ВремяНачала;
	ВеличинаИнтервалаВДнях = Цел(ВеличинаИнтервала/60/60/24);
	
	Если ВеличинаИнтервалаВДнях > 365 Тогда
		ОписаниеИнтервала = НСтр("ru = 'более года'");
	ИначеЕсли ВеличинаИнтервалаВДнях > 31 Тогда
		ОписаниеИнтервала = НСтр("ru = 'более месяца'");
	ИначеЕсли ВеличинаИнтервалаВДнях >= 1 Тогда
		ОписаниеИнтервала = Формат(ВеличинаИнтервалаВДнях, "ЧДЦ=0") + " "
			+ ПользователиСлужебныйКлиентСервер.ПредметЦелогоЧисла(ВеличинаИнтервалаВДнях,
				"Л = ru_RU", НСтр("ru = 'день,дня,дней,,,,,,0'"));
	Иначе
		ОписаниеИнтервала = НСтр("ru = 'менее одного дня'");
	КонецЕсли;
	
	Возврат ОписаниеИнтервала;
	
КонецФункции

// Возвращает фрагмент текста запроса, отделяющего один запрос от другого.
//
// Возвращаемое значение:
//  Строка - разделитель запросов.
//
Функция РазделительПакетаЗапросов() Экспорт
	
	Возврат "
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|";
		
КонецФункции

// Устарела. Следует использовать СклонениеПредставленийОбъектов.Просклонять
//
// Функция склоняет переданную фразу.
// Только для работы на ОС Windows.
//
// Параметры:
//  ФИО   - Строка - фамилия, имя и отчество в именительном падеже, 
//                   которые необходимо просклонять.
//  Падеж - Число  - падеж, в который необходимо поставить ФИО:
//                   1 - Именительный
//                   2 - Родительный
//                   3 - Дательный
//                   4 - Винительный
//                   5 - Творительный
//                   6 - Предложный
//  Результат - Строка - в этот параметр помещается результат склонения.
//                       Если ФИО не удалось просклонять, то возвращается значение ФИО.
//  Пол       - Число - пол физического лица, 1 - мужской, 2 - женский.
//
// Возвращаемое значение:
//   Булево - Истина, если ФИО удалось просклонять.
//
Функция Просклонять(Знач ФИО, Падеж, Результат, Пол = Неопределено) Экспорт
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.СклонениеПредставленийОбъектов") Тогда
		МодульСклонениеПредставленийОбъектов = ОбщийМодуль("СклонениеПредставленийОбъектов");
		
		Результат = МодульСклонениеПредставленийОбъектов.ПросклонятьФИО(ФИО, Падеж, , Пол);
		Если ЗначениеЗаполнено(Результат) Тогда
			Возврат Истина;
		Иначе
			Результат = ФИО;
			Возврат Ложь;
		КонецЕсли; 
			
	КонецЕсли;
	
	ВызватьИсключение НСтр("ru = 'Для вызова ОбщегоНазначения.Просклонять необходима подсистема «Склонение представлений объектов».'");
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с формами.

// Процедура предназначена для заполнения реквизита формы типа ДанныеФормыДерево.
//
// Параметры:
//  КоллекцияЭлементовДерева - ДанныеФормыДерево - реквизит, который нужно заполнить.
//  ДеревоЗначений           - ДеревоЗначений    - данные для заполнения.
// 
Процедура ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(КоллекцияЭлементовДерева, ДеревоЗначений) Экспорт
	
	Для Каждого Строка Из ДеревоЗначений.Строки Цикл
		
		ЭлементДерева = КоллекцияЭлементовДерева.Добавить();
		
		ЗаполнитьЗначенияСвойств(ЭлементДерева, Строка);
		
		Если Строка.Строки.Количество() > 0 Тогда
			
			ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(ЭлементДерева.ПолучитьЭлементы(), Строка);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Устарела. Следует использовать ОбщегоНазначенияКлиентСервер.КартинкаКомментария.
//
// Получает картинку для вывода на странице с комментарием в зависимости
// от наличия текста в комментарии.
//
// Параметры:
//  Комментарий  - Строка - текст комментария.
//
// Возвращаемое значение:
//  Картинка - Картинка, которая должна отображаться на странице с комментарием.
//
Функция ПолучитьКартинкуКомментария(Комментарий) Экспорт
	Возврат ОбщегоНазначенияКлиентСервер.КартинкаКомментария(Комментарий);
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с типами, объектами метаданных и их строковыми представлениями.

// Получает дерево метаданных конфигурации с заданным отбором по объектам метаданных.
//
// Параметры:
//   Отбор - Структура - содержит значения элементов отбора.
//						Если параметр задан, то будет получено дерево метаданных в соответствии с заданным отбором:
//						Ключ - Строка - имя свойства элемента метаданных;
//						Значение - Массив - множество значений для отбора.
//
// Пример инициализации переменной "Отбор":
//
// Массив = Новый Массив;
// Массив.Добавить("Константа.ИспользоватьСинхронизациюДанных");
// Массив.Добавить("Справочник.Валюты");
// Массив.Добавить("Справочник.Организации");
// Отбор = Новый Структура;
// Отбор.Вставить("ПолноеИмя", Массив);
// 
//  Возвращаемое значение:
//   ДеревоЗначений - дерево описания метаданных конфигурации.
//
Функция ДеревоМетаданныхКонфигурации(Отбор = Неопределено) Экспорт
	
	ИспользоватьОтбор = (Отбор <> Неопределено);
	
	КоллекцииОбъектовМетаданных = Новый ТаблицаЗначений;
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Имя");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Синоним");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Картинка");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("КартинкаОбъекта");
	
	НоваяСтрокаКоллекцииОбъектовМетаданных("Константы",               НСтр("ru = 'Константы'"),                 БиблиотекаКартинок.Константа,              БиблиотекаКартинок.Константа,                    КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Справочники",             НСтр("ru = 'Справочники'"),               БиблиотекаКартинок.Справочник,             БиблиотекаКартинок.Справочник,                   КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Документы",               НСтр("ru = 'Документы'"),                 БиблиотекаКартинок.Документ,               БиблиотекаКартинок.ДокументОбъект,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовХарактеристик", НСтр("ru = 'Планы видов характеристик'"), БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыСчетов",             НСтр("ru = 'Планы счетов'"),              БиблиотекаКартинок.ПланСчетов,             БиблиотекаКартинок.ПланСчетовОбъект,             КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовРасчета",       НСтр("ru = 'Планы видов расчета'"),       БиблиотекаКартинок.ПланВидовРасчета,       БиблиотекаКартинок.ПланВидовРасчетаОбъект,       КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыСведений",        НСтр("ru = 'Регистры сведений'"),         БиблиотекаКартинок.РегистрСведений,        БиблиотекаКартинок.РегистрСведений,              КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыНакопления",      НСтр("ru = 'Регистры накопления'"),       БиблиотекаКартинок.РегистрНакопления,      БиблиотекаКартинок.РегистрНакопления,            КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыБухгалтерии",     НСтр("ru = 'Регистры бухгалтерии'"),      БиблиотекаКартинок.РегистрБухгалтерии,     БиблиотекаКартинок.РегистрБухгалтерии,           КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыРасчета",         НСтр("ru = 'Регистры расчета'"),          БиблиотекаКартинок.РегистрРасчета,         БиблиотекаКартинок.РегистрРасчета,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("БизнесПроцессы",          НСтр("ru = 'Бизнес-процессы'"),           БиблиотекаКартинок.БизнесПроцесс,          БиблиотекаКартинок.БизнесПроцессОбъект,          КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Задачи",                  НСтр("ru = 'Задачи'"),                    БиблиотекаКартинок.Задача,                 БиблиотекаКартинок.ЗадачаОбъект,                 КоллекцииОбъектовМетаданных);
	
	// Возвращаемое значение функции.
	ДеревоМетаданных = Новый ДеревоЗначений;
	ДеревоМетаданных.Колонки.Добавить("Имя");
	ДеревоМетаданных.Колонки.Добавить("ПолноеИмя");
	ДеревоМетаданных.Колонки.Добавить("Синоним");
	ДеревоМетаданных.Колонки.Добавить("Картинка");
	
	Для Каждого СтрокаКоллекции Из КоллекцииОбъектовМетаданных Цикл
		
		СтрокаДерева = ДеревоМетаданных.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаДерева, СтрокаКоллекции);
		Для Каждого ОбъектМетаданных Из Метаданные[СтрокаКоллекции.Имя] Цикл
			
			Если ИспользоватьОтбор Тогда
				
				ОбъектПрошелФильтр = Истина;
				Для Каждого ЭлементОтбора Из Отбор Цикл
					
					Значение = ?(ВРег(ЭлементОтбора.Ключ) = ВРег("ПолноеИмя"), ОбъектМетаданных.ПолноеИмя(), ОбъектМетаданных[ЭлементОтбора.Ключ]);
					Если ЭлементОтбора.Значение.Найти(Значение) = Неопределено Тогда
						ОбъектПрошелФильтр = Ложь;
						Прервать;
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не ОбъектПрошелФильтр Тогда
					Продолжить;
				КонецЕсли;
				
			КонецЕсли;
			
			СтрокаДереваОМ = СтрокаДерева.Строки.Добавить();
			СтрокаДереваОМ.Имя       = ОбъектМетаданных.Имя;
			СтрокаДереваОМ.ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			СтрокаДереваОМ.Синоним   = ОбъектМетаданных.Синоним;
			СтрокаДереваОМ.Картинка  = СтрокаКоллекции.КартинкаОбъекта;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Удаляем строки без подчиненных элементов.
	Если ИспользоватьОтбор Тогда
		
		// Используем обратный порядок обхода дерева значений.
		КоличествоЭлементовКоллекции = ДеревоМетаданных.Строки.Количество();
		
		Для ОбратныйИндекс = 1 По КоличествоЭлементовКоллекции Цикл
			
			ТекущийИндекс = КоличествоЭлементовКоллекции - ОбратныйИндекс;
			СтрокаДерева = ДеревоМетаданных.Строки[ТекущийИндекс];
			Если СтрокаДерева.Строки.Количество() = 0 Тогда
				ДеревоМетаданных.Строки.Удалить(ТекущийИндекс);
			КонецЕсли;
			
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат ДеревоМетаданных;
	
КонецФункции

// Получить представление физического места размещения информационной базы для отображения администратору.
//
// Возвращаемое значение:
//   Строка - представление информационной базы.
//
// Пример возвращаемого результата:
// - для ИБ в файлом режиме: \\FileServer\1c_ib\
// - для ИБ в серверном режиме: ServerName:1111 / information_base_name.
//
Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
	
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
	
	Если ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
		Возврат Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
	КонецЕсли;
		
	// Прибавить к имени сервера имя пути информационной базы.
	ПозицияПоиска = СтрНайти(ВРег(СтрокаСоединенияСБД), "SRVR=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПозицияТочкиСЗапятой = СтрНайти(СтрокаСоединенияСБД, ";");
	НачальнаяПозицияКопирования = 6 + 1;
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	
	СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
	
	// Позиция имени сервера
	ПозицияПоиска = СтрНайти(ВРег(СтрокаСоединенияСБД), "REF=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НачальнаяПозицияКопирования = 6;
	ПозицияТочкиСЗапятой = СтрНайти(СтрокаСоединенияСБД, ";");
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	ПутьКБД = ИмяСервера + "/ " + ИмяИБНаСервере;
	Возврат ПутьКБД;
	
КонецФункции

// Возвращает строку реквизитов объекта метаданных с заданным типом.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка на элемент базы данных, для которого требуется получить результат функции;
//  Тип    - Тип - тип значения реквизита.
// 
// Возвращаемое значение:
//  Строка - строка реквизитов объекта метаданных конфигурации, разделенные символом ",".
//
Функция ИменаРеквизитовПоТипу(Ссылка, Тип) Экспорт
	
	Результат = "";
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		Если Реквизит.Тип.СодержитТип(Тип) Тогда
			Результат = Результат + ?(ПустаяСтрока(Результат), "", ", ") + Реквизит.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Возвращает имя базового типа по переданному значению объекта метаданных.
//
// Параметры:
//  ОбъектМетаданных - объект метаданных, по которому необходимо определить базовый тип.
// 
// Возвращаемое значение:
//  Строка - имя базового типа по переданному значению объекта метаданных.
//
Функция ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) Экспорт
	
	Если Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаДокументы();
		
	ИначеЕсли Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаСправочники();
		
	ИначеЕсли Метаданные.Перечисления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПеречисления();
		
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыСведений();
		
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыНакопления();
		
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыБухгалтерии();
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыРасчета();
		
	ИначеЕсли Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыОбмена();
		
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовХарактеристик();
		
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаБизнесПроцессы();
		
	ИначеЕсли Метаданные.Задачи.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЗадачи();
		
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыСчетов();
		
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовРасчета();
		
	ИначеЕсли Метаданные.Константы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаКонстанты();
		
	ИначеЕсли Метаданные.ЖурналыДокументов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЖурналыДокументов();
		
	ИначеЕсли Метаданные.Последовательности.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПоследовательности();
		
	ИначеЕсли Метаданные.РегламентныеЗадания.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегламентныеЗадания();
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных.Родитель())
		И ОбъектМетаданных.Родитель().Перерасчеты.Найти(ОбъектМетаданных.Имя) = ОбъектМетаданных Тогда
		Возврат ИмяТипаПерерасчеты();
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

// Возвращает менеджер объекта по полному имени объекта метаданных.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных. Пример: "Справочник.Организации".
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер.
// 
Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	Перем КлассОМ, ИмяОМ, Менеджер;
	
	ЧастиИмени = СтрРазделить(ПолноеИмя, ".");
	
	Если ЧастиИмени.Количество() >= 2 Тогда
		КлассОМ = ЧастиИмени[0];
		ИмяОМ  = ЧастиИмени[1];
	КонецЕсли;
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Менеджер = ПланыОбмена;
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Менеджер = Справочники;
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Менеджер = Документы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Менеджер = ЖурналыДокументов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Менеджер = Перечисления;
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Менеджер = Отчеты;
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Менеджер = Обработки;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Менеджер = ПланыВидовХарактеристик;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Менеджер = ПланыСчетов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Менеджер = ПланыВидовРасчета;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Менеджер = РегистрыСведений;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Менеджер = РегистрыНакопления;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Менеджер = РегистрыБухгалтерии;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Если ЧастиИмени.Количество() = 2 Тогда
			// Регистр расчета
			Менеджер = РегистрыРасчета;
		Иначе
			КлассПодчиненногоОМ = ЧастиИмени[2];
			ИмяПодчиненногоОМ = ЧастиИмени[3];
			Если ВРег(КлассПодчиненногоОМ) = "ПЕРЕРАСЧЕТ" Тогда
				// Перерасчет
				Попытка
					Менеджер = РегистрыРасчета[ИмяОМ].Перерасчеты;
					ИмяОм = ИмяПодчиненногоОМ;
				Исключение
					Менеджер = Неопределено;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Менеджер = БизнесПроцессы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Менеджер = Задачи;
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Менеджер = Константы;
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Менеджер = Последовательности;
	КонецЕсли;
	
	Если Менеджер <> Неопределено Тогда
		Попытка
			Возврат Менеджер[ИмяОМ];
		Исключение
			Менеджер = Неопределено;
		КонецПопытки;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неизвестный тип объекта метаданных ""%1""'"), ПолноеИмя);
	
КонецФункции

// Возвращает менеджер объекта по ссылке на объект.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, менеджер которого требуется получить.
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер.
// 
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Справочники[ИмяОбъекта];
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Документы[ИмяОбъекта];
		
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
		
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
		
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Задачи[ИмяОбъекта];
		
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Перечисления[ИмяОбъекта];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Создает и возвращает экземпляр объекта по полному имени объекта метаданных.
// Ограничение: поддерживаются только отчеты и обработки.
//
// Параметры:
//   ПолноеИмя - Строка - полное имя объекта метаданных. Пример: "Отчет.БизнесПроцессы".
//
// Возвращаемое значение:
//   ОтчетОбъект, ОбработкаОбъект.
// 
Функция ОбъектПоПолномуИмени(ПолноеИмя) Экспорт
	МассивСтрок = СтрРазделить(ПолноеИмя, ".");
	
	Если МассивСтрок.Количество() >= 2 Тогда
		Вид = ВРег(МассивСтрок[0]);
		Имя = МассивСтрок[1];
	Иначе
		ВызватьИсключение СтрЗаменить(НСтр("ru = 'Некорректное полное имя отчета или обработки ""%1"".'"), "%1", ПолноеИмя);
	КонецЕсли;
	
	Если Вид = "ОТЧЕТ" Тогда
		Возврат Отчеты[Имя].Создать();
	ИначеЕсли Вид = "ОБРАБОТКА" Тогда
		Возврат Обработки[Имя].Создать();
	ИначеЕсли Вид = "ВНЕШНИЙОТЧЕТ" Тогда
		Возврат ВнешниеОтчеты.Создать(Имя);
	ИначеЕсли Вид = "ВНЕШНЯЯОБРАБОТКА" Тогда
		Возврат ВнешниеОбработки.Создать(Имя);
	Иначе
		ВызватьИсключение СтрЗаменить(НСтр("ru = '""%1"" не является отчетом или обработкой.'"), "%1", ПолноеИмя);
	КонецЕсли;
КонецФункции

// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки.
//
// Параметры:
//  ЛюбаяСсылка - значение любой ссылки информационной базы данных.
// 
// Возвращаемое значение:
//  Булево.
//
Функция СсылкаСуществует(ЛюбаяСсылка) Экспорт
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Ссылка КАК Ссылка
	|ИЗ
	|	[ИмяТаблицы]
	|ГДЕ
	|	Ссылка = &Ссылка
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(ЛюбаяСсылка));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Возвращает имя вида объектов метаданных по ссылке на объект.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, вид которого требуется получить.
//
// Возвращаемое значение:
//  Строка - имя вида объектов метаданных. Например: "Справочник", "Документ".
// 
Функция ВидОбъектаПоСсылке(Ссылка) Экспорт
	
	Возврат ВидОбъектаПоТипу(ТипЗнч(Ссылка));
	
КонецФункции 

// Возвращает имя вида объектов метаданных по типу объекта.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Тип - Тип - Тип прикладного объекта, определенный в конфигурации .
//
// Возвращаемое значение:
//  Строка - имя вида объектов метаданных. Например: "Справочник", "Документ".
// 
Функция ВидОбъектаПоТипу(Тип) Экспорт
	
	Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Справочник";
	
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Документ";
	
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "БизнесПроцесс";
	
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовХарактеристик";
	
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланСчетов";
	
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовРасчета";
	
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Задача";
	
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланОбмена";
	
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Перечисление";
	
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Неверный тип значения параметра (%1)'"), Строка(Тип));
	
	КонецЕсли;
	
КонецФункции 

// Возвращает полное имя объекта метаданных по переданному значению ссылки.
// Примеры:
//  "Справочник.Номенклатура";
//  "Документ.ПриходнаяНакладная".
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, для которого необходимо получить имя таблицы ИБ.
// 
// Возвращаемое значение:
//  Строка - полное имя объекта метаданных для указанного объекта.
//
Функция ИмяТаблицыПоСсылке(Ссылка) Экспорт
	
	Возврат Ссылка.Метаданные().ПолноеИмя();
	
КонецФункции

// Проверить, что значение имеет ссылочный тип данных.
//
// Параметры:
//  Значение - Произвольный - проверяемое значение.
//
// Возвращаемое значение:
//  Булево - Истина, если тип значения ссылочный.
//
Функция ЗначениеСсылочногоТипа(Значение) Экспорт
	
	Возврат ЭтоСсылка(ТипЗнч(Значение));
	
КонецФункции

// Проверка того, что переданный тип является ссылочным типом данных.
// Для типа "Неопределено" возвращается Ложь.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоСсылка(Тип) Экспорт
	
	Возврат Тип <> Тип("Неопределено") 
		И (Справочники.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Документы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
		ИЛИ Задачи.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип));
	
КонецФункции

// Проверяет, является ли объект группой элементов.
//
// Параметры:
//  Объект - ЛюбаяСсылка, Объект - проверяемый объект.
//
// Возвращаемое значение:
//  Булево.
//
Функция ОбъектЯвляетсяГруппой(Объект) Экспорт
	
	Если ЗначениеСсылочногоТипа(Объект) Тогда
		Ссылка = Объект;
	Иначе
		Ссылка = Объект.Ссылка;
	КонецЕсли;
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Если ЭтоСправочник(МетаданныеОбъекта) Тогда
		
		Если НЕ МетаданныеОбъекта.Иерархический
		 ИЛИ МетаданныеОбъекта.ВидИерархии
		     <> Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
			
			Возврат Ложь;
		КонецЕсли;
		
	ИначеЕсли НЕ ЭтоПланВидовХарактеристик(МетаданныеОбъекта) Тогда
		Возврат Ложь;
		
	ИначеЕсли НЕ МетаданныеОбъекта.Иерархический Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Ссылка <> Объект Тогда
		Возврат Объект.ЭтоГруппа;
	КонецЕсли;
	
	Возврат ЗначениеРеквизитаОбъекта(Ссылка, "ЭтоГруппа") = Истина;
	
КонецФункции

// Возвращает ссылку, соответствующую объекту метаданных, для
// использования в базе данных.
//  Например:
//  Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ТипЗнч(Ссылка));
//  Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных);
//  Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Справочник.Организации");
//
//  Поддерживаемые объекты метаданных:
// - Подсистемы (требуется программировать переименование).
// - Роли       (требуется программировать переименование).
// - ПланыОбмена
// - Константы
// - Справочники
// - Документы
// - ЖурналыДокументов
// - Отчеты
// - Обработки
// - ПланыВидовХарактеристик
// - ПланыСчетов
// - ПланыВидовРасчета
// - РегистрыСведений
// - РегистрыНакопления
// - РегистрыБухгалтерии
// - РегистрыРасчета
// - БизнесПроцессы
// - Задачи.
// 
// Подробнее см. в функции СвойстваКоллекцийОбъектовМетаданных()
// модуля менеджера справочника ИдентификаторыОбъектовМетаданных.
//
// Параметры:
//  ОписаниеОбъектаМетаданных - ОбъектМетаданных - объект метаданных конфигурации;
//                            - Тип - тип, который можно успешно использовать в функции Метаданные.НайтиПоТипу();
//                            - Строка - полное имя объекта метаданных, которое можно успешно использовать
//                              в функции Метаданные.НайтиПоПолномуИмени().
// Возвращаемое значение:
//  СправочникСсылка.ИдентификаторыОбъектовМетаданных, СправочникСсылка.ИдентификаторыОбъектовРасширений.
//
Функция ИдентификаторОбъектаМетаданных(ОписаниеОбъектаМетаданных) Экспорт
	
	Возврат Справочники.ИдентификаторыОбъектовМетаданных.ИдентификаторОбъектаМетаданных(ОписаниеОбъектаМетаданных);
	
КонецФункции

// Возвращает объект метаданных по переданному идентификатору.
//
// Параметры:
//  Идентификатор - СправочникСсылка.ИдентификаторыОбъектовМетаданных,
//                  СправочникСсылка.ИдентификаторыОбъектовРасширений - идентификатор
//                    объекта метаданных конфигурации или расширения.
//
// Возвращаемое значение:
//  ОбъектМетаданных - для типа СправочникСсылка.ИдентификаторыОбъектовМетаданных.
//  ОбъектМетаданных, Неопределено - для типа СправочникСсылка.ИдентификаторыОбъектовРасширений.
//   Если расширение не подключено, тогда объект метаданных невозможно вернуть и возвращается Неопределено.
//   Неопределено означает, что в справочнике ИдентификаторыОбъектовРасширений найден действующий
//   идентификатор, но объекта метаданных, который ему соответствует, найти не удалось.
//
Функция ОбъектМетаданныхПоИдентификатору(Идентификатор) Экспорт
	
	Возврат Справочники.ИдентификаторыОбъектовМетаданных.ОбъектМетаданныхПоИдентификатору(Идентификатор);
	
КонецФункции

// Возвращает Истина, если объект метаданных, которому соответствует
// идентификатор объектов расширений существует в справочнике и
// не помечен на удаление, но отсутствует в кэше метаданных расширений.
//
// Параметры:
//  Идентификатор - СправочникСсылка.ИдентификаторыОбъектовРасширений - идентификатор
//                    объекта метаданных расширения.
//
// Возвращаемое значение:
// Булево.
//
Функция ОбъектРасширенияОтключен(Идентификатор) Экспорт
	
	Возврат Справочники.ИдентификаторыОбъектовРасширений.ОбъектРасширенияОтключен(Идентификатор);
	
КонецФункции

// Для использования в процедуре ПриДобавленииПереименованийОбъектовМетаданных
// общего модуля ОбщегоНазначенияПереопределяемый для описания переименований объектов метаданных.
// 
// Параметры:
//   Итог                    - Структура - передается в процедуру подсистемой БазоваяФункциональность.
//   ВерсияИБ                - Строка    - версия при переходе на которую нужно выполнить переименование.
//   СтароеПолноеИмя         - Строка    - старое полное имя объекта метаданных,    которое нужно переименовать.
//   НовоеПолноеИмя          - Строка    - новое  полное имя объекта метаданных, на которое нужно переименовать.
//   ИдентификаторБиблиотеки - Строка    - внутренний идентификатор библиотеки, к которой относится ВерсияИБ.
//                                         Для основной конфигурации не требуется.
// 
Процедура ДобавитьПереименование(Итог, ВерсияИБ, СтароеПолноеИмя, НовоеПолноеИмя, ИдентификаторБиблиотеки = "") Экспорт
	
	Справочники.ИдентификаторыОбъектовМетаданных.ДобавитьПереименование(Итог,
		ВерсияИБ, СтароеПолноеИмя, НовоеПолноеИмя, ИдентификаторБиблиотеки);
	
КонецПроцедуры

// Возвращает строковое представление типа. 
// Для ссылочных типов возвращает в формате "СправочникСсылка.ИмяОбъекта" или "ДокументСсылка.ИмяОбъекта".
// Для остальных типов приводит тип к строке, например "Число".
//
// Возвращаемое значение:
//  Строка.
//
Функция СтроковоеПредставлениеТипа(Тип) Экспорт
	
	Представление = "";
	
	Если ЭтоСсылка(Тип) Тогда
	
		ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
		ИмяОбъекта = СтрРазделить(ПолноеИмя, ".")[1];
		
		Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "СправочникСсылка";
		
		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ДокументСсылка";
		
		ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "БизнесПроцессСсылка";
		
		ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовХарактеристикСсылка";
		
		ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланСчетовСсылка";
		
		ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовРасчетаСсылка";
		
		ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ЗадачаСсылка";
		
		ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланОбменаСсылка";
		
		ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПеречислениеСсылка";
		
		КонецЕсли;
		
		Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);
		
	Иначе
		
		Результат = Строка(Тип);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверить, что описание типа состоит из единственного типа значения и 
// совпадает с нужным типом.
//
// Параметры:
//   ОписаниеТипа - ОписаниеТипов - проверяемая коллекция типов;
//   ТипЗначения  - Тип - проверяемый тип.
//
// Возвращаемое значение:
//   Булево      - Истина, если совпадает.
//
Функция ОписаниеТипаСостоитИзТипа(ОписаниеТипа, ТипЗначения) Экспорт
	
	Если ОписаниеТипа.Типы().Количество() = 1
	   И ОписаниеТипа.Типы().Получить(0) = ТипЗначения Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет наличие табличной части у справочника.
//
// Параметры:
//  ИмяСправочника    - Строка - имя справочника, для которого осуществляется проверка.
//  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
//
// Возвращаемое значение:
//  Булево - Истина, если табличная часть есть.
//
// Пример:
//  Если НЕ ОбщегоНазначения.НаличиеТабличнойЧастиУСправочника(ИмяСправочника,"КонтактнаяИнформация") Тогда
//  	Возврат;
//  КонецЕсли;
//
Функция НаличиеТабличнойЧастиУСправочника(ИмяСправочника, ИмяТабличнойЧасти) Экспорт
	
	Возврат (Метаданные.Справочники[ИмяСправочника].ТабличныеЧасти.Найти(ИмяТабличнойЧасти) <> Неопределено);
	
КонецФункции 

// Возвращает признак того, что реквизит входит в подмножество стандартных реквизитов.
//
// Параметры:
//  СтандартныеРеквизиты - ОписанияСтандартныхРеквизитов - тип и значение описывает коллекцию настроек различных
//                                                         стандартных реквизитов;
//  ИмяРеквизита         - Строка - реквизит который необходимо проверить на принадлежность множеству стандартных
//                                  реквизитов;
// 
// Возвращаемое значение:
//   Булево - Истина, если реквизит входит в подмножество стандартных реквизитов.
//
Функция ЭтоСтандартныйРеквизит(СтандартныеРеквизиты, ИмяРеквизита) Экспорт
	
	Для Каждого Реквизит Из СтандартныеРеквизиты Цикл
		Если Реквизит.Имя = ИмяРеквизита Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
	
КонецФункции

// Получает таблицу значений с описанием требуемых свойств всех реквизитов объекта метаданного.
// Получает значения свойств стандартных реквизитов и пользовательских реквизитов (созданных в режиме конфигуратора).
//
// Параметры:
//  ОбъектМетаданных  - ОбъектМетаданных - объект, для которого необходимо получить значение свойств реквизитов.
//                      Например: Метаданные.Документ.РеализацияТоваровИУслуг
//  Свойства - Строка - свойства реквизитов, перечисленные через запятую, значение которых необходимо получить.
//                      Например: "Имя, Тип, Синоним, Подсказка".
//
// Возвращаемое значение:
//  ТаблицаЗначений - описание требуемых свойств всех реквизитов объекта метаданных.
//
Функция ПолучитьТаблицуОписанияСвойствОбъекта(ОбъектМетаданных, Свойства) Экспорт
	
	МассивСвойств = СтрРазделить(Свойства, ",");
	
	// Возвращаемое значение функции.
	ТаблицаОписанияСвойствОбъекта = Новый ТаблицаЗначений;
	
	// Добавляем в таблицу поля согласно именам переданных свойств.
	Для Каждого ИмяСвойства Из МассивСвойств Цикл
		ТаблицаОписанияСвойствОбъекта.Колонки.Добавить(СокрЛП(ИмяСвойства));
	КонецЦикла;
	
	// Заполняем строку таблицы свойствами реквизитов объекта метаданных.
	Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	// Заполняем строку таблицы свойствами стандартных реквизитов объекта метаданных.
	Для Каждого Реквизит Из ОбъектМетаданных.СтандартныеРеквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	Возврат ТаблицаОписанияСвойствОбъекта;
	
КонецФункции

// Возвращает состояние использования элемента состава общего реквизита.
//
// Параметры:
//  ЭлементСостава            - ОбъектМетаданных - элемент состава общего реквизита, использование которого требуется
//                                                 проверить.
//  МетаданныеОбщегоРеквизита - ОбъектМетаданных - объект метаданных общего реквизита, которому принадлежит
//                                                 ЭлементСостава.
//
// Возвращаемое значение:
//  Булево - Истина, если элемент состава используется, иначе Ложь.
//
Функция ЭлементСоставаОбщегоРеквизитаИспользуется(Знач ЭлементСостава, Знач МетаданныеОбщегоРеквизита) Экспорт
	
	Если ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Использовать Тогда
		Возврат Истина;
	ИначеЕсли ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.НеИспользовать Тогда
		Возврат Ложь;
	Иначе
		Возврат МетаданныеОбщегоРеквизита.АвтоИспользование = Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
	КонецЕсли;
	
КонецФункции

// Возвращает признак того, что объект метаданных используется в общих реквизитах-разделителях.
//
// Параметры:
//  ОбъектМетаданных - Строка, ОбъектМетаданных - Если объект метаданных задан строкой, происходит обращение к модулю
//                     повторного использования.
//  Разделитель      - Строка - имя общего реквизита-разделителя, на разделение которыми проверяется объект метаданных.
//
// Возвращаемое значение:
//  Булево - Истина, если объект метаданных используется хотя бы в одном общем разделителе.
//
Функция ЭтоРазделенныйОбъектМетаданных(Знач ОбъектМетаданных, Знач Разделитель) Экспорт
	
	Если ТипЗнч(ОбъектМетаданных) = Тип("Строка") Тогда
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных;
	Иначе
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	КонецЕсли;
	
	РазделенныеОбъектыМетаданных = ОбщегоНазначенияПовтИсп.РазделенныеОбъектыМетаданных(Разделитель);
	Возврат РазделенныеОбъектыМетаданных.Получить(ПолноеИмяОбъектаМетаданных) <> Неопределено;
	
КонецФункции

// Возвращает имя предопределенного элемента по указанной ссылке.
// Для использования вместо устаревшего метода ПолучитьИмяПредопределенного в
// конфигурациях, рассчитанных на платформу версии 8.2.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка на предопределенный элемент.
//
// Возвращаемое значение:
//  Строка - имя предопределенного элемента.
//
Функция ИмяПредопределенного(Знач Ссылка) Экспорт
	
	Возврат ЗначениеРеквизитаОбъекта(Ссылка, "ИмяПредопределенныхДанных");
	
КонецФункции

// Конструктор объекта ОписаниеТипов, содержащего тип Строка.
//
// Параметры:
//  ДлинаСтроки - Число.
//
// ВозвращаемоеЗначение:
//  ОписаниеТипов.
Функция ОписаниеТипаСтрока(ДлинаСтроки) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Строка"));

	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);

	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);

КонецФункции

// Конструктор объекта ОписаниеТипов, содержащего тип Число.
//
// Параметры:
//  Разрядность - Число - общее количество разрядов числа (количество разрядов
//                        целой части плюс количество разрядов дробной части).
//  РазрядностьДробнойЧасти - Число - число разрядов дробной части.
//  ЗнакЧисла - ДопустимыйЗнак - допустимый знак числа.
//
// ВозвращаемоеЗначение:
//  ОписаниеТипов.
Функция ОписаниеТипаЧисло(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт

	Если ЗнакЧисла = Неопределено Тогда
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
	Иначе
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;

	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);

КонецФункции

// Конструктор объекта ОписаниеТипов, содержащего тип Дата.
//
// Параметры:
//  ЧастиДаты - ЧастиДаты - набор вариантов использования значений типа Дата.
//
// ВозвращаемоеЗначение:
//  ОписаниеТипов.
Функция ОписаниеТипаДата(ЧастиДаты) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));

	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);

	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);

КонецФункции

// Позволяет определить, есть ли среди реквизитов объекта реквизит с переданным именем.
//
// Параметры:
//  ИмяРеквизита - Строка - имя реквизита;
//  МетаданныеОбъекта - ОбъектМетаданных - объект, в котором требуется проверить наличие реквизита.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьРеквизитОбъекта(ИмяРеквизита, МетаданныеОбъекта) Экспорт

	Возврат НЕ (МетаданныеОбъекта.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции определения типов объектов метаданных.

// Ссылочные типы данных

// Определяет принадлежность объекта метаданных к общему типу "Документ".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоДокумент(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Документы.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Справочник".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоСправочник(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Справочники.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Перечисление".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПеречисление(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Перечисления.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План обмена".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПланОбмена(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов характеристик".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПланВидовХарактеристик(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Бизнес-процесс".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоБизнесПроцесс(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Задача".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоЗадача(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Задачи.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План счетов".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПланСчетов(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов расчета".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПланВидовРасчета(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных);
	
КонецФункции

// Регистры

// Определяет принадлежность объекта метаданных к общему типу "Регистр сведений".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистрСведений(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр накопления".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистрНакопления(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр бухгалтерии".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистрБухгалтерии(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр расчета".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистрРасчета(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных);
	
КонецФункции

// Константы

// Определяет принадлежность объекта метаданных к общему типу "Константа".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоКонстанта(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Константы.Содержит(ОбъектМетаданных);
	
КонецФункции

// Журналы документов

// Определяет принадлежность объекта метаданных к общему типу "Журнал документов".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоЖурналДокументов(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ЖурналыДокументов.Содержит(ОбъектМетаданных);
	
КонецФункции

// Последовательности

// Определяет принадлежность объекта метаданных к общему типу "Последовательности".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПоследовательность(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Последовательности.Содержит(ОбъектМетаданных);
	
КонецФункции

// РегламентныеЗадания

// Определяет принадлежность объекта метаданных к общему типу "Регламентные задания".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегламентноеЗадание(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегламентныеЗадания.Содержит(ОбъектМетаданных);
	
КонецФункции

// Общие

// Определяет принадлежность объекта метаданных к типу регистр.
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистр(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных)
		Или Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных)
		Или Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных)
		Или Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных);
		
КонецФункции

// Определяет принадлежность объекта метаданных к ссылочному типу.
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоОбъектСсылочногоТипа(ОбъектМетаданных) Экспорт
	
	ИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	Позиция = СтрНайти(ИмяОбъектаМетаданных, ".");
	Если Позиция > 0 Тогда 
		ИмяБазовогоТипа = Лев(ИмяОбъектаМетаданных, Позиция - 1);
		Возврат ИмяБазовогоТипа = "Справочник"
			Или ИмяБазовогоТипа = "Документ"
			Или ИмяБазовогоТипа = "БизнесПроцесс"
			Или ИмяБазовогоТипа = "Задача"
			Или ИмяБазовогоТипа = "ПланСчетов"
			Или ИмяБазовогоТипа = "ПланОбмена"
			Или ИмяБазовогоТипа = "ПланВидовХарактеристик"
			Или ИмяБазовогоТипа = "ПланВидовРасчета";
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Имена типов.

// Возвращает значение для идентификации общего типа "Регистры сведений".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыСведений() Экспорт
	
	Возврат "РегистрыСведений";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры накопления".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыНакопления() Экспорт
	
	Возврат "РегистрыНакопления";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры бухгалтерии".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыБухгалтерии() Экспорт
	
	Возврат "РегистрыБухгалтерии";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры расчета".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыРасчета() Экспорт
	
	Возврат "РегистрыРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Документы".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаДокументы() Экспорт
	
	Возврат "Документы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Справочники".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаСправочники() Экспорт
	
	Возврат "Справочники";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Перечисления".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПеречисления() Экспорт
	
	Возврат "Перечисления";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Отчеты".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаОтчеты() Экспорт
	
	Возврат "Отчеты";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Обработки".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаОбработки() Экспорт
	
	Возврат "Обработки";
	
КонецФункции

// Возвращает значение для идентификации общего типа "ПланыОбмена".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыОбмена() Экспорт
	
	Возврат "ПланыОбмена";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов характеристик".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыВидовХарактеристик() Экспорт
	
	Возврат "ПланыВидовХарактеристик";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Бизнес-процессы".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаБизнесПроцессы() Экспорт
	
	Возврат "БизнесПроцессы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Задачи".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаЗадачи() Экспорт
	
	Возврат "Задачи";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы счетов".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыСчетов() Экспорт
	
	Возврат "ПланыСчетов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов расчета".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыВидовРасчета() Экспорт
	
	Возврат "ПланыВидовРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Константы".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаКонстанты() Экспорт
	
	Возврат "Константы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Журналы документов".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаЖурналыДокументов() Экспорт
	
	Возврат "ЖурналыДокументов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Последовательности".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПоследовательности() Экспорт
	
	Возврат "Последовательности";
	
КонецФункции

// Возвращает значение для идентификации общего типа "РегламентныеЗадания".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегламентныеЗадания() Экспорт
	
	Возврат "РегламентныеЗадания";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Перерасчеты".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПерерасчеты() Экспорт
	
	Возврат "Перерасчеты";
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Сохранение, чтение и удаление настроек из хранилищ.

// Сохраняет настройку в хранилище общих настроек.
//
// Параметры:
//   КлючОбъекта       - Строка - Ключ объекта настройки.
//   КлючНастроек      - Строка - Ключ сохраняемых настроек.
//   Значение          - Произвольный     - Настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  - ОписаниеНастроек - Вспомогательная информация о настройке.
//   ИмяПользователя   - Строка - Имя пользователя, настройки которого сохраняются.
//       Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения - Булево - Сбросить кэши модулей ПовтИсп.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Сохранить" в синтакс-помощнике.
//
Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		Значение,
		ОписаниеНастроек,
		ИмяПользователя,
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища общих настроек.
//
// Параметры:
//   КлючОбъекта  - Строка - Ключ объекта настройки.
//   КлючНастроек - Строка - Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный.
//       Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек - ОписаниеНастроек - Необязательный. При чтении значения настройки в данный параметр
//       записывается вспомогательная информация о настройке.
//   ИмяПользователя - Строка - Необязательный. Имя пользователя, настройки которого загружаются.
//       Если не указано, то загружается настройки текущего пользователя.
//
// Возвращаемое значение: 
//   Произвольный - Настройки, загруженные из хранилища.
//   Неопределено - Если настройки не найдены и параметр ЗначениеПоУмолчанию не указан.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Загрузить" в синтакс-помощнике.
//
Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		ОписаниеНастроек,
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища общих настроек.
//
// Параметры:
//   КлючОбъекта  - Строка       - Ключ объекта настройки. 
//                - Неопределено - Удаляются настройки для всех объектов.
//   КлючНастроек - Строка       - Ключ сохраняемых настроек.
//                - Неопределено - Удаляются настройки со всеми ключами.
//   ИмяПользователя - Строка       - Имя пользователя, настройки которого загружается.
//                   - Неопределено - Удаляются настройки всех пользователей.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Удалить" в синтакс-помощнике.
//
Процедура ХранилищеОбщихНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур. 
// Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//    НужноОбновитьПовторноИспользуемыеЗначения - Булево - требуется обновить повторно используемые значения.
//
Процедура ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур,
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Элемент Из МассивСтруктур Цикл
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, КлючНастроек(Элемент.Настройка), Элемент.Значение);
	КонецЦикла;
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур и обновляет повторно
//   используемые значения. Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//
Процедура ХранилищеОбщихНастроекСохранитьМассивИОбновитьПовторноИспользуемыеЗначения(МассивСтруктур) Экспорт
	
	ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур, Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище общих настроек и обновляет повторно используемые 
//   значения.
// 
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроекСохранить.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить().
//
Процедура ХранилищеОбщихНастроекСохранитьИОбновитьПовторноИспользуемыеЗначения(КлючОбъекта, КлючНастроек, Значение) Экспорт
	
	ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,,,Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище системных настроек.
//
// Параметры:
//   КлючОбъекта       - Строка - Ключ объекта настройки.
//   КлючНастроек      - Строка - Ключ сохраняемых настроек.
//   Значение          - Произвольный     - Настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  - ОписаниеНастроек - Вспомогательная информация о настройке.
//   ИмяПользователя   - Строка - Имя пользователя, настройки которого сохраняются.
//       Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения - Булево - Сбросить кэши модулей ПовтИсп.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Сохранить" в синтакс-помощнике.
//
Процедура ХранилищеСистемныхНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища системных настроек.
//
// Параметры:
//   КлючОбъекта  - Строка - Ключ объекта настройки.
//   КлючНастроек - Строка - Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный.
//       Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек - ОписаниеНастроек - Необязательный. При чтении значения настройки в данный параметр
//       записывается вспомогательная информация о настройке.
//   ИмяПользователя - Строка - Необязательный. Имя пользователя, настройки которого загружаются.
//       Если не указано, то загружается настройки текущего пользователя.
//
// Возвращаемое значение: 
//   Произвольный - Настройки, загруженные из хранилища.
//   Неопределено - Если настройки не найдены и параметр ЗначениеПоУмолчанию не указан.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Загрузить" в синтакс-помощнике.
//
Функция ХранилищеСистемныхНастроекЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища системных настроек.
//
// Параметры:
//   КлючОбъекта  - Строка       - Ключ объекта настройки. 
//                - Неопределено - Удаляются настройки для всех объектов.
//   КлючНастроек - Строка       - Ключ сохраняемых настроек.
//                - Неопределено - Удаляются настройки со всеми ключами.
//   ИмяПользователя - Строка       - Имя пользователя, настройки которого загружается.
//                   - Неопределено - Удаляются настройки всех пользователей.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Удалить" в синтакс-помощнике.
//
Процедура ХранилищеСистемныхНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеСистемныхНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек данных форм.
//
// Параметры:
//   КлючОбъекта       - Строка - Ключ объекта настройки.
//   КлючНастроек      - Строка - Ключ сохраняемых настроек.
//   Значение          - Произвольный     - Настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  - ОписаниеНастроек - Вспомогательная информация о настройке.
//   ИмяПользователя   - Строка - Имя пользователя, настройки которого сохраняются.
//       Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения - Булево - Сбросить кэши модулей ПовтИсп.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Сохранить" в синтакс-помощнике.
//
Процедура ХранилищеНастроекДанныхФормСохранить(КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища настроек данных форм.
//
// Параметры:
//   КлючОбъекта  - Строка - Ключ объекта настройки.
//   КлючНастроек - Строка - Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный.
//       Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек - ОписаниеНастроек - Необязательный. При чтении значения настройки в данный параметр
//       записывается вспомогательная информация о настройке.
//   ИмяПользователя - Строка - Необязательный. Имя пользователя, настройки которого загружаются.
//       Если не указано, то загружается настройки текущего пользователя.
//
// Возвращаемое значение: 
//   Произвольный - Настройки, загруженные из хранилища.
//   Неопределено - Если настройки не найдены и параметр ЗначениеПоУмолчанию не указан.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Загрузить" в синтакс-помощнике.
//
Функция ХранилищеНастроекДанныхФормЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища настроек данных форм.
//
// Параметры:
//   КлючОбъекта  - Строка       - Ключ объекта настройки. 
//                - Неопределено - Удаляются настройки для всех объектов.
//   КлючНастроек - Строка       - Ключ сохраняемых настроек.
//                - Неопределено - Удаляются настройки со всеми ключами.
//   ИмяПользователя - Строка       - Имя пользователя, настройки которого загружается.
//                   - Неопределено - Удаляются настройки всех пользователей.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Удалить" в синтакс-помощнике.
//
Процедура ХранилищеНастроекДанныхФормУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеНастроекДанныхФорм,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища - СтандартноеХранилищеНастроекМенеджер - Хранилище, в котором сохраняется настройка.
//   КлючОбъекта       - Строка - Ключ объекта настройки.
//   КлючНастроек      - Строка - Ключ сохраняемых настроек.
//   Значение          - Произвольный     - Настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  - ОписаниеНастроек - Вспомогательная информация о настройке.
//   ИмяПользователя   - Строка - Имя пользователя, настройки которого сохраняются.
//       Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения - Булево - Сбросить кэши модулей ПовтИсп.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Сохранить" в синтакс-помощнике.
//   "Настройки, автоматически сохраняемые в системном хранилище" в синтакс-помощнике.
//
Процедура ХранилищеСохранить(МенеджерХранилища, КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек, ИмяПользователя, НужноОбновитьПовторноИспользуемыеЗначения)
	
	Если НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек(КлючНастроек), Значение, ОписаниеНастроек, ИмяПользователя);
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Загружает настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища - СтандартноеХранилищеНастроекМенеджер - Хранилище, из которого загружается настройка.
//   КлючОбъекта  - Строка - Ключ объекта настройки.
//   КлючНастроек - Строка - Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный.
//       Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек - ОписаниеНастроек - Необязательный. При чтении значения настройки в данный параметр
//       записывается вспомогательная информация о настройке.
//   ИмяПользователя - Строка - Необязательный. Имя пользователя, настройки которого загружаются.
//       Если не указано, то загружается настройки текущего пользователя.
//
// Возвращаемое значение: 
//   Произвольный - Настройки, загруженные из хранилища.
//   Неопределено - Если настройки не найдены и параметр ЗначениеПоУмолчанию не указан.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Загрузить" в синтакс-помощнике.
//   "Настройки, автоматически сохраняемые в системном хранилище" в синтакс-помощнике.
//
Функция ХранилищеЗагрузить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию,
	ОписаниеНастроек, ИмяПользователя)
	
	Результат = Неопределено;
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек(КлючНастроек), ОписаниеНастроек, ИмяПользователя);
	КонецЕсли;
	
	Если Результат = Неопределено Тогда
		Результат = ЗначениеПоУмолчанию;
	Иначе
		УстановитьПривилегированныйРежим(Истина);
		Если УдалитьБитыеСсылки(Результат) Тогда
			Результат = ЗначениеПоУмолчанию;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Удаляет битые ссылки из переменной.
//
// Параметры:
//   СсылкаИлиКоллекция - ЛюбаяСсылка, Произвольный - Проверяемый объект или очищаемая коллекция.
//
// Возвращаемое значение: 
//   Булево - 
//       * Истина - СсылкаИлиКоллекция ссылочного типа и объект не найден в базе данных.
//       * Ложь - Когда СсылкаИлиКоллекция не ссылочного типа или объект найден в базе данных.
//
Функция УдалитьБитыеСсылки(СсылкаИлиКоллекция)
	
	Тип = ТипЗнч(СсылкаИлиКоллекция);
	
	Если Тип = Тип("Неопределено")
		Или Тип = Тип("Булево")
		Или Тип = Тип("Строка")
		Или Тип = Тип("Число")
		Или Тип = Тип("Дата") Тогда // Оптимизация - часто используемые примитивные типы.
		
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли Тип = Тип("Массив") Тогда
		
		Количество = СсылкаИлиКоллекция.Количество();
		Для Номер = 1 По Количество Цикл
			ОбратныйИндекс = Количество - Номер;
			Значение = СсылкаИлиКоллекция[ОбратныйИндекс];
			Если УдалитьБитыеСсылки(Значение) Тогда
				СсылкаИлиКоллекция.Удалить(ОбратныйИндекс);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли Тип = Тип("Структура")
		Или Тип = Тип("Соответствие") Тогда
		
		Для Каждого КлючИЗначение Из СсылкаИлиКоллекция Цикл
			Значение = КлючИЗначение.Значение;
			Если УдалитьБитыеСсылки(Значение) Тогда
				СсылкаИлиКоллекция.Вставить(КлючИЗначение.Ключ, Неопределено);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип)
		Или Справочники.ТипВсеСсылки().СодержитТип(Тип)
		Или Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип)
		Или БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		Или Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		// Ссылочный тип, исключая ТочкаМаршрутаБизнесПроцессаСсылка.
		
		Если СсылкаИлиКоллекция.Пустая() Тогда
			Возврат Ложь; // Ссылка пустая.
		ИначеЕсли ЗначениеРеквизитаОбъекта(СсылкаИлиКоллекция, "Ссылка") = Неопределено Тогда
			СсылкаИлиКоллекция = Неопределено;
			Возврат Истина; // "Битая" ссылка.
		Иначе
			Возврат Ложь; // Объект найден.
		КонецЕсли;
		
	Иначе
		
		Возврат Ложь; // Не ссылка.
		
	КонецЕсли;
	
КонецФункции

// Удаляет настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища - СтандартноеХранилищеНастроекМенеджер - Хранилище, из которого удаляется настройка.
//   КлючОбъекта  - Строка       - Ключ объекта настройки. 
//                - Неопределено - Удаляются настройки для всех объектов.
//   КлючНастроек - Строка       - Ключ сохраняемых настроек.
//                - Неопределено - Удаляются настройки со всеми ключами.
//   ИмяПользователя - Строка       - Имя пользователя, настройки которого загружается.
//                   - Неопределено - Удаляются настройки всех пользователей.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Удалить" в синтакс-помощнике.
//   "Настройки, автоматически сохраняемые в системном хранилище" в синтакс-помощнике.
//
Процедура ХранилищеУдалить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ИмяПользователя)
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		МенеджерХранилища.Удалить(КлючОбъекта, КлючНастроек(КлючНастроек), ИмяПользователя);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с настройкой рабочей даты.

// Сохраняет настройку рабочей даты пользователя.
//
// Параметры:
//	НоваяРабочаяДата - Дата - Дата, которую необходимо установить в качестве рабочей даты пользователя.
//	ИмяПользователя - Строка - Имя пользователя, для которого устанавливается рабочая дата.
//		Если не задано, то устанавливается для текущего пользователя.
//			
Процедура УстановитьРабочуюДатуПользователя(НоваяРабочаяДата, ИмяПользователя = Неопределено) Экспорт

	КлючОбъекта = ВРег("РабочаяДата");
	
	ХранилищеОбщихНастроекСохранить(КлючОбъекта, "", НоваяРабочаяДата, , ИмяПользователя);

КонецПроцедуры

// Возвращает значение настройки рабочей даты для пользователя.
//
// Параметры:
//	ИмяПользователя - Строка - Имя пользователя, для которого запрашивается рабочая дата.
//		Если не задано, то устанавливается для текущего пользователя.
//
// Возвращаемое значение:
//	Дата - Значение настройки рабочей даты пользователя или пустая дата, если настройка не задана.
//
Функция РабочаяДатаПользователя(ИмяПользователя = Неопределено) Экспорт

	КлючОбъекта = ВРег("РабочаяДата");

	Результат = ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, "", '0001-01-01', , ИмяПользователя);
	
	Если ТипЗнч(Результат) <> Тип("Дата") Тогда
		Результат = '0001-01-01';
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение настройки рабочей даты для пользователя или текущей даты сеанса,
// если рабочая дата пользователя не задана.
//
// Параметры:
//	ИмяПользователя - Строка - Имя пользователя, для которого запрашивается рабочая дата.
//		Если не задано, то устанавливается для текущего пользователя.
//
// Возвращаемое значение:
//	Дата - Значение настройки рабочей даты пользователя или текущая дата сеанса, если настройка не задана.
//
Функция ТекущаяДатаПользователя(ИмяПользователя = Неопределено) Экспорт

	Результат = РабочаяДатаПользователя(ИмяПользователя);
	
	Если НЕ ЗначениеЗаполнено(Результат) Тогда
		Результат = ТекущаяДатаСеанса();
	КонецЕсли;
	
	Возврат НачалоДня(Результат);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с табличными документами.

// Проверяет, умещаются ли переданные табличные документы на страницу при печати.
//
// Параметры:
//  ТабДокумент        - ТабличныйДокумент - табличный документ.
//  ВыводимыеОбласти   - Массив, ТабличныйДокумент - массив из проверяемых таблиц или табличный документ. 
//  РезультатПриОшибке - Булево - какой возвращать результат при возникновении ошибки.
//
// Возвращаемое значение:
//   Булево   - умещаются или нет переданные документы.
//
Функция ПроверитьВыводТабличногоДокумента(ТабДокумент, ВыводимыеОбласти, РезультатПриОшибке = Истина) Экспорт

	Попытка
		Возврат ТабДокумент.ПроверитьВывод(ВыводимыеОбласти);
	Исключение
		Возврат РезультатПриОшибке;
	КонецПопытки;

КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы в режиме разделения данных.

// Устанавливает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе
// начинает транзакцию и устанавливает исключительную управляемую блокировку
// на пространства блокировок всех объектов метаданных, входящих в состав разделителя ОбластьДанных.
//
// В других случаях (например, в локальном режиме работы) устанавливает монопольный режим. 
//
// Параметры:
//   ПроверитьОтсутствиеДругихСеансов - Булево - проверить отсутствие других
//          пользовательских сеансов со значением разделителя равным текущему.
//          В случае обнаружения других сеансов будет выдано исключение.
//          Параметр используется только при работе в модели сервиса.
//
Процедура ЗаблокироватьИБ(Знач ПроверитьОтсутствиеДругихСеансов = Истина) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если НЕ МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Истина);
		КонецЕсли;
	Иначе
		Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
			МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
			МодульРаботаВМоделиСервиса.ЗаблокироватьТекущуюОбластьДанных(ПроверитьОтсутствиеДругихСеансов);
		Иначе
			ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
		КонецЕсли;
	КонецЕсли;
		
КонецПроцедуры

// Снимает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе,
// - если вызов делается внутри обработчика исключения (из секции Исключении...)
//   отменяет транзакцию;
// - иначе фиксирует транзакцию.
//
// В других случаях (например, в локальном режиме работы) снимает монопольный режим. 
//
Процедура РазблокироватьИБ() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
	Иначе
		Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
			МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
			МодульРаботаВМоделиСервиса.РазблокироватьТекущуюОбластьДанных();
		Иначе
			ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает разделение сеанса.
//
// Параметры:
//   Использование - Булево - Использование разделителя ОбластьДанных в сеансе.
//   ОбластьДанных - Число - Значение разделителя ОбластьДанных.
//
Процедура УстановитьРазделениеСеанса(Знач Использование, Знач ОбластьДанных = Неопределено) Экспорт
	
	ПриУстановкеРазделенияСеанса(Использование, ОбластьДанных);
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Возвращаемое значение: 
//   Тип значения разделителя - значение разделителя текущей области данных. 
// 
Функция ЗначениеРазделителяСеанса() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат 0;
	Иначе
		ЗначениеРазделителя = Неопределено;
		ПриПолученииЗначенияРазделителяСеанса(ЗначениеРазделителя);
		Возврат ЗначениеРазделителя;
	КонецЕсли;
	
КонецФункции

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Возвращаемое значение: 
//   Булево - Истина, если разделение используется.
// 
Функция ИспользованиеРазделителяСеанса() Экспорт
	
	ИспользованиеРазделителя = Неопределено;
	ПриПолученииИспользованияРазделителяСеанса(ИспользованиеРазделителя);
	Возврат ИспользованиеРазделителя;
	
КонецФункции

// Процедура инициализации разделенной информационной базы.
// 
// Параметры:
//   ВключитьРазделение - Булево - признак включения разделения в информационной базе.
//
Процедура УстановитьПараметрыРазделенияИнформационнойБазы(Знач ВключитьРазделение = Ложь) Экспорт
	
	Если ВключитьРазделение Тогда
		Константы.ИспользоватьРазделениеПоОбластямДанных.Установить(Истина);
	Иначе
		Константы.ИспользоватьРазделениеПоОбластямДанных.Установить(Ложь);
	КонецЕсли;
	
КонецПроцедуры

// Выполняет запись значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - ЛюбаяСсылка, УдалениеОбъекта - значение ссылочного типа или УдалениеОбъекта.
//
Процедура ЗаписатьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		МодульРаботаВМоделиСервиса.ЗаписатьВспомогательныеДанные(ОбъектВспомогательныхДанных);
	Иначе
		ОбъектВспомогательныхДанных.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Выполняет удаление значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - ЛюбаяСсылка - значение ссылочного типа.
//
Процедура УдалитьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		МодульРаботаВМоделиСервиса.УдалитьВспомогательныеДанные(ОбъектВспомогательныхДанных);
	Иначе
		ОбъектВспомогательныхДанных.Удалить();
	КонецЕсли;
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////
// Версионирование программных интерфейсов.

// Возвращает массив номеров версий, поддерживаемых интерфейсом удаленной системы.
//
// Параметры:
//  Адрес - Строка - адрес web-сервиса версионирования интерфейсов;
//  Пользователь - Строка - имя пользователя;
//  Пароль - Строка - пароль пользователя;
//  Интерфейс - Строка - имя интерфейса.
//
// Возвращаемое значение:
//   ФиксированныйМассив - массив строк, каждая строка является представлением номера версии интерфейса. Например,
//                         "1.0.2.1".
//
// Пример использования:
//	  ПараметрыПодключения = Новый Структура;
//	  ПараметрыПодключения.Вставить("URL", "http://vsrvx/sm");
//	  ПараметрыПодключения.Вставить("UserName", "ivanov");
//	  МассивВерсий = ПолучитьВерсииИнтерфейса(ПараметрыПодключения, "СервисПередачиФайлов");
//
// Примечание: при получении версий используется кэш, время обновления которого составляет
//  одни сутки. Если для целей отладки требуется обновить значения в кэше, раньше этого 
//  времени, следует удалить из регистра сведений КэшПрограммныхИнтерфейсов соответствующие 
//  записи.
//
Функция ПолучитьВерсииИнтерфейса(Знач Адрес, Знач Пользователь, Знач Пароль = Неопределено, Знач Интерфейс = Неопределено) Экспорт
	
	Если ТипЗнч(Адрес) = Тип("Структура") Тогда
		ПараметрыПодключения = Адрес;
		ИмяИнтерфейса = Пользователь;
	Иначе
		ПараметрыПодключения = Новый Структура;
		ПараметрыПодключения.Вставить("URL", Адрес);
		ПараметрыПодключения.Вставить("UserName", Пользователь);
		ПараметрыПодключения.Вставить("Password", Пароль);
		ИмяИнтерфейса = Интерфейс;
	КонецЕсли;
	
	Если Не ПараметрыПодключения.Свойство("URL") 
		Или Не ЗначениеЗаполнено(ПараметрыПодключения.URL) Тогда
		
		ВызватьИсключение(НСтр("ru = 'Не задан URL сервиса.'"));
	КонецЕсли;
	
	ПараметрыПолучения = Новый Массив;
	ПараметрыПолучения.Добавить(ПараметрыПодключения);
	ПараметрыПолучения.Добавить(ИмяИнтерфейса);
	
	Возврат ОбщегоНазначенияПовтИсп.ДанныеКэшаВерсий(
		ИдентификаторЗаписиКэшаВерсий(ПараметрыПодключения.URL, ИмяИнтерфейса), 
		Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ВерсииИнтерфейса, 
		ЗначениеВСтрокуXML(ПараметрыПолучения),
		Истина);
	
КонецФункции

// Возвращает массив номеров версий, поддерживаемых интерфейсом системы, подключенной через внешнее соединение.
//
// Параметры:
//   ВнешнееСоединение - COMОбъект - объект COM-соединение, которое используется для работы с корреспондентом.
//   ИмяИнтерфейса - Строка -.
//
// Возвращаемое значение:
//   ФиксированныйМассив - массив строк, каждая строка является представлением номера версии интерфейса. Например,
//                         "1.0.2.1".
//
// Пример использования:
//  Параметры = ...
//  ВнешнееСоединение = ОбщегоНазначения.УстановитьВнешнееСоединение(Параметры);
//  МассивВерсий = ОбщегоНазначения.ПолучитьВерсииИнтерфейсаЧерезВнешнееСоединение(ВнешнееСоединение, "ОбменДанными");
//
Функция ПолучитьВерсииИнтерфейсаЧерезВнешнееСоединение(ВнешнееСоединение, Знач ИмяИнтерфейса) Экспорт
	Попытка
		ВерсииИнтерфейсаXML = ВнешнееСоединение.СтандартныеПодсистемыСервер.ПоддерживаемыеВерсии(ИмяИнтерфейса);
	Исключение
		СтрокаСообщения = НСтр("ru = 'Корреспондент не поддерживает версионирование интерфейсов подсистем.
			|Описание ошибки: %1'");
		СтрокаСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение версий интерфейса'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , СтрокаСообщения);
		
		Возврат Новый ФиксированныйМассив(Новый Массив);
	КонецПопытки;
	
	Возврат Новый ФиксированныйМассив(ЗначениеИзСтрокиXML(ВерсииИнтерфейсаXML));
КонецФункции

// Удаляет записи кэша версий содержащих в идентификаторе указанную
// подстроку. В качестве подстроки может использоваться, например,
// имя интерфейса более не используемого в конфигурации.
//
// Параметры:
//  ПодстрокаПоискаИдентификаторов - Строка - подстрока поиска 
//   идентификаторов. Строка не может содержать символов
//   %, _ и [.
//
Процедура УдалитьЗаписиКэшаВерсий(Знач ПодстрокаПоискаИдентификаторов) Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить("РегистрСведений.КэшПрограммныхИнтерфейсов");
		ПодстрокаПоиска = СформироватьСтрокуДляПоискаВЗапросе(ПодстрокаПоискаИдентификаторов);

		ТекстЗапроса =
			"ВЫБРАТЬ
			|	ТаблицаКэша.Идентификатор КАК Идентификатор,
			|	ТаблицаКэша.ТипДанных КАК ТипДанных
			|ИЗ
			|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК ТаблицаКэша
			|ГДЕ
			|	ТаблицаКэша.Идентификатор ПОДОБНО ""%" + ПодстрокаПоиска + "%""
			|		СПЕЦСИМВОЛ ""~""";
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Результат = Запрос.Выполнить();
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			Запись = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьМенеджерЗаписи();
			Запись.Идентификатор = Выборка.Идентификатор;
			Запись.ТипДанных = Выборка.ТипДанных;
			
			Запись.Удалить();
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с хранилищем паролей.

// Записывает конфиденциальные данные в безопасное хранилище.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Параметры:
//  Владелец - ПланОбменаСсылка, СправочникСсылка - ссылка на объект информационной базы,
//              представляющий объект-владелец сохраняемого пароля.
//              Для объектов других типов в качестве Владельца рекомендуется использовать ссылку на 
//              элемент метаданных этого типа в справочнике ИдентификаторыОбъектовМетаданных.
//              Например, Владелец = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("РегистрСведений.АдресныеОбъекты");
//  Данные  - Произвольный - Данные помещаемые в безопасное хранилище. Неопределенно - удаляет данные.
//  Ключ    - Строка       - Ключ сохраняемых настроек, по умолчанию "Пароль".
//
Процедура ЗаписатьДанныеВБезопасноеХранилище(Владелец, Данные, Ключ = "Пароль") Экспорт
	
	ОбщегоНазначенияКлиентСервер.Проверить(ЗначениеЗаполнено(Владелец), 
		СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Недопустимое значение параметра %1 в %2. 
		|параметр должен содержать ссылку; передано значение: %3 (тип %4).'"),
			"Владелец", "ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище", Владелец, ТипЗнч(Владелец)));
	
	ЭтоОбластьДанных = ОбщегоНазначенияПовтИсп.РазделениеВключено() И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных();
	Если ЭтоОбластьДанных Тогда
		БезопасноеХранилищеДанных = РегистрыСведений.БезопасноеХранилищеДанныхОбластейДанных.СоздатьМенеджерЗаписи();
	Иначе
		БезопасноеХранилищеДанных = РегистрыСведений.БезопасноеХранилищеДанных.СоздатьМенеджерЗаписи();
	КонецЕсли;
	
	Отбор = Новый Структура("Владелец", Владелец);
	БезопасноеХранилищеДанных.Владелец = Владелец;
	БезопасноеХранилищеДанных.Прочитать();
	Если Данные <> Неопределено Тогда
		Если БезопасноеХранилищеДанных.Выбран() Тогда
			ДанныеДляСохранения = БезопасноеХранилищеДанных.Данные.Получить();
			Если ТипЗнч(ДанныеДляСохранения) <> Тип("Структура") Тогда
				ДанныеДляСохранения = Новый Структура();
			КонецЕсли;
			ДанныеДляСохранения.Вставить(Ключ, Данные);
			ДанныеДляХранилищеЗначения = Новый ХранилищеЗначения(ДанныеДляСохранения, Новый СжатиеДанных(6));
			БезопасноеХранилищеДанных.Данные = ДанныеДляХранилищеЗначения;
			БезопасноеХранилищеДанных.Записать();
		Иначе
			ДанныеДляСохранения = Новый Структура(Ключ, Данные);
			ДанныеДляХранилищеЗначения = Новый ХранилищеЗначения(ДанныеДляСохранения, Новый СжатиеДанных(6));
			БезопасноеХранилищеДанных.Данные = ДанныеДляХранилищеЗначения;
			БезопасноеХранилищеДанных.Владелец = Владелец;
			БезопасноеХранилищеДанных.Записать();
		КонецЕсли;
	Иначе
		БезопасноеХранилищеДанных.Удалить();
	КонецЕсли;
	
КонецПроцедуры

// Возвращает данные из безопасного хранилища.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Параметры:
//  Владелец    -  ПланОбменаСсылка, СправочникСсылка - ссылка на объект информационной базы,
//                            представляющий объект-владелец сохраняемого пароля.
//  Ключи       - Строка - Содержит список имен сохраненных данных, указанных через запятую.
//  ОбщиеДанные - Булево - Истина, если требуется в модели сервиса получить данные из общих данных в разделенном режиме.
// 
// Возвращаемое значение:
//  Произвольный, Структура - Данные из безопасного хранилища. Если указан один ключ,
//                            то возвращается его значение, иначе структура.
//                            Если данные отсутствуют - Неопределенно.
//
Функция ПрочитатьДанныеИзБезопасногоХранилища(Владелец, Ключи = "Пароль", ОбщиеДанные = Неопределено) Экспорт
	
	ОбщегоНазначенияКлиентСервер.Проверить(ЗначениеЗаполнено(Владелец), 
		СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Недопустимое значение параметра %1 в %2. 
		|параметр должен содержать ссылку; передано значение: %3 (тип %4).'"),
			"Владелец", "ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища", Владелец, ТипЗнч(Владелец)));
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено()
			И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Если ОбщиеДанные = Истина Тогда
			ИмяБезопасноеХранилищеДанных = "БезопасноеХранилищеДанных";
		Иначе
			ИмяБезопасноеХранилищеДанных = "БезопасноеХранилищеДанныхОбластейДанных";
		КонецЕсли;
	Иначе
		ИмяБезопасноеХранилищеДанных = "БезопасноеХранилищеДанных";
		
	КонецЕсли;
	Результат = ДанныеИзБезопасногоХранилища(Владелец, ИмяБезопасноеХранилищеДанных, Ключи);
	
	Если Результат <> Неопределено И Результат.Количество() = 1 Тогда
		Возврат ?(Результат.Свойство(Ключи), Результат[Ключи], Неопределено);
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

// Удаляет конфиденциальные данные в безопасное хранилище.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Параметры:
//  Владелец - ПланОбменаСсылка, СправочникСсылка - ссылка на объект информационной базы,
//                            представляющий объект-владелец сохраняемого пароля.
//  Ключи - Строка - Содержит список имен удаляемых данных, указанных через запятую. 
//                   Неопределенно - удаляет все данные.
//
Процедура УдалитьДанныеИзБезопасногоХранилища(Владелец, Ключи = Неопределено) Экспорт
	
	ОбщегоНазначенияКлиентСервер.Проверить(ЗначениеЗаполнено(Владелец), 
		СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Недопустимое значение параметра %1 в %2. 
		|параметр должен содержать ссылку; передано значение: %3 (тип %4).'"),
			"Владелец", "ОбщегоНазначения.УдалитьДанныеИзБезопасногоХранилища", Владелец, ТипЗнч(Владелец)));
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		БезопасноеХранилищеДанных = РегистрыСведений.БезопасноеХранилищеДанныхОбластейДанных.СоздатьМенеджерЗаписи();
	Иначе
		БезопасноеХранилищеДанных = РегистрыСведений.БезопасноеХранилищеДанных.СоздатьМенеджерЗаписи();
	КонецЕсли;
	
	Отбор = Новый Структура("Владелец", Владелец);
	БезопасноеХранилищеДанных.Владелец = Владелец;
	БезопасноеХранилищеДанных.Прочитать();
	Если Ключи <> Неопределено Тогда
		СписокКлючей = СтрРазделить(Ключи, ",", Ложь);
		Если БезопасноеХранилищеДанных.Выбран() И СписокКлючей.Количество() > 0 Тогда
			ДанныеДляСохранения = БезопасноеХранилищеДанных.Данные.Получить();
			Для каждого КлючДляУдаления Из СписокКлючей Цикл
				Если ДанныеДляСохранения.Свойство(КлючДляУдаления) Тогда
					ДанныеДляСохранения.Удалить(КлючДляУдаления);
				КонецЕсли;
			КонецЦикла;
			ДанныеДляХранилищеЗначения = Новый ХранилищеЗначения(ДанныеДляСохранения, Новый СжатиеДанных(6));
			БезопасноеХранилищеДанных.Данные = ДанныеДляХранилищеЗначения;
			БезопасноеХранилищеДанных.Записать();
		КонецЕсли;
	Иначе
		БезопасноеХранилищеДанных.Удалить();
	КонецЕсли;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для вызова необязательных подсистем.

// Возвращает Истина, если "функциональная" подсистема существует в конфигурации.
// Предназначена для реализации вызова необязательной подсистемы (условного вызова).
//
// У "функциональной" подсистемы снят флажок "Включать в командный интерфейс".
//
// Параметры:
//  ПолноеИмяПодсистемы - Строка - полное имя объекта метаданных подсистема
//                        без слов "Подсистема." и с учетом регистра символов.
//                        Например: "СтандартныеПодсистемы.ВариантыОтчетов".
//
// Пример:
//
//  Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ВариантыОтчетов") Тогда
//  	МодульВариантыОтчетов = ОбщегоНазначения.ОбщийМодуль("ВариантыОтчетов");
//  	МодульВариантыОтчетов.<Имя метода>();
//  КонецЕсли;
//
// Возвращаемое значение:
//  Булево.
//
Функция ПодсистемаСуществует(ПолноеИмяПодсистемы) Экспорт
	
	ИменаПодсистем = СтандартныеПодсистемыПовтИсп.ИменаПодсистем();
	Возврат ИменаПодсистем.Получить(ПолноеИмяПодсистемы) <> Неопределено;
	
КонецФункции

// Возвращает ссылку на общий модуль по имени.
//
// Параметры:
//  Имя          - Строка - имя общего модуля, например:
//                 "ОбщегоНазначения",
//                 "ОбщегоНазначенияКлиент".
//
// Возвращаемое значение:
//  ОбщийМодуль.
//
Функция ОбщийМодуль(Имя) Экспорт
	
	Если Метаданные.ОбщиеМодули.Найти(Имя) <> Неопределено Тогда
		Модуль = РаботаВБезопасномРежиме.ВычислитьВБезопасномРежиме(Имя);
	ИначеЕсли СтрЧислоВхождений(Имя, ".") = 1 Тогда
		Возврат СерверныйМодульМенеджера(Имя);
	Иначе
		Модуль = Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(Модуль) <> Тип("ОбщийМодуль") Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Общий модуль ""%1"" не найден.'"), Имя);
	КонецЕсли;
	
	Возврат Модуль;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с буфером обмена.

// Помещает выделенные строки табличной части в буфер обмена.
//
// Параметры:
//  ТабличнаяЧасть   - ДанныеФормыКоллекция - Табличная часть, строки которой
//                                            необходимо поместить в буфер обмена.
//  ВыделенныеСтроки - Массив - Массив идентификаторов выделенных строк.
//  Источник         - Строка - Произвольный строковый идентификатор, например, имя объекта,
//                              строки табличной части которого помещаются в буфер обмена.
//
Процедура СкопироватьСтрокиВБуферОбмена(ТабличнаяЧасть, ВыделенныеСтроки, Источник = Неопределено) Экспорт
	
	Если ВыделенныеСтроки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаЗначений = ТабличнаяЧасть.Выгрузить();
	ТаблицаЗначений.Очистить();
	
	УдаляемыеКолонки = Новый Массив;
	УдаляемыеКолонки.Добавить("ИсходныйНомерСтроки");
	УдаляемыеКолонки.Добавить("НомерСтроки");
	
	Для Каждого ИмяКолонки Из УдаляемыеКолонки Цикл
		Колонка = ТаблицаЗначений.Колонки.Найти(ИмяКолонки);
		Если Колонка = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ТаблицаЗначений.Колонки.Удалить(Колонка);
	КонецЦикла;
	
	Для Каждого ИдентификаторСтроки Из ВыделенныеСтроки Цикл
		КопируемаяСтрока = ТабличнаяЧасть.НайтиПоИдентификатору(ИдентификаторСтроки);
		ЗаполнитьЗначенияСвойств(ТаблицаЗначений.Добавить(), КопируемаяСтрока);
	КонецЦикла;
	
	СкопироватьВБуферОбмена(ТаблицаЗначений, Источник);
	
КонецПроцедуры

// Помещает произвольные данные в буфер обмена.
//
// Параметры:
//  Данные           - Произвольный - Данные, которые необходимо поместить в буфер обмена.
//  Источник         - Строка       - Произвольный строковый идентификатор, например, имя объекта,
//                                    строки табличной части которого помещаются в буфер обмена.
//
Процедура СкопироватьВБуферОбмена(Данные, Источник = Неопределено) Экспорт
	
	ТекущийБуферОбмена = ПараметрыСеанса.БуферОбмена;
	
	Если ЗначениеЗаполнено(ТекущийБуферОбмена.Данные) Тогда
		Адрес = ТекущийБуферОбмена.Данные;
	Иначе
		Адрес = Новый УникальныйИдентификатор;
	КонецЕсли;
	
	ДанныеВХранилище = ПоместитьВоВременноеХранилище(Данные, Адрес);
	
	СтруктураБуфераОбмена = Новый Структура;
	СтруктураБуфераОбмена.Вставить("Источник", Источник);
	СтруктураБуфераОбмена.Вставить("Данные", ДанныеВХранилище);
	
	ПараметрыСеанса.БуферОбмена = Новый ФиксированнаяСтруктура(СтруктураБуфераОбмена);
	
КонецПроцедуры

// Получает строки табличной части, помещенные в буфер обмена.
//
// Возвращаемое значение:
//  Структура - со свойствами:
//     * Данные   - Произвольный - Данные из буфера обмена. 
//                                 Например, ТаблицаЗначений при вызове СкопироватьСтрокиВБуферОбмена. 
//     * Источник - Строка       - Объект, к которому относятся данные.
//                                 Если при помещении в буфер не был указан, то Неопределено.
//
Функция СтрокиИзБуфераОбмена() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Источник", Неопределено);
	Результат.Вставить("Данные", Неопределено);
	
	Если ПустойБуферОбмена() Тогда
		Возврат Результат;
	КонецЕсли;
	
	ТекущийБуферОбмена = ПараметрыСеанса.БуферОбмена;
	Результат.Источник = ТекущийБуферОбмена.Источник;
	Результат.Данные = ПолучитьИзВременногоХранилища(ТекущийБуферОбмена.Данные);
	
	Возврат Результат;
КонецФункции

// Проверяет наличие сохраненных данных в буфере обмена.
//
// Параметры:
//  Источник - Строка - Если передан, то проверяется наличие данных
//             в буфере обмена с этим ключем.
//             По умолчанию - Неопределено.
// Возвращаемое значение:
//   Булево.
//
Функция ПустойБуферОбмена(Источник = Неопределено) Экспорт
	
	ТекущийБуферОбмена = ПараметрыСеанса.БуферОбмена;
	ИсточникСовпадает = Истина;
	Если Источник <> Неопределено Тогда
		ИсточникСовпадает = (Источник = ТекущийБуферОбмена.Источник);
	КонецЕсли;
	Возврат (Не ИсточникСовпадает Или Не ЗначениеЗаполнено(ТекущийБуферОбмена.Данные));
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для обработки служебных событий.

// Возвращает обработчики указанного серверного служебного события.
//
// Параметры:
//  Событие  - Строка - например,
//             "СтандартныеПодсистемы.БазоваяФункциональность\ПриОпределенииПоддерживаемыхВерсийПрограммныхИнтерфейсов".
//
// Возвращаемое значение:
//  ФиксированныйМассив со значениями типа ФиксированнаяСтруктура со свойствами:
//    * Версия - Строка      - версия обработчика, например, "2.1.3.4". Пустая строка, если не указана.
//    * Модуль - ОбщийМодуль - серверный общий модуль.
// 
Функция ОбработчикиСлужебногоСобытия(Событие) Экспорт
	
	Возврат СтандартныеПодсистемыПовтИсп.ОбработчикиСерверногоСобытия(Событие, Истина);
	
КонецФункции

// Выгружает запрос в строку XML, которую можно вставить в Консоль запросов.
//   Для переноса запроса и всех его параметров в Консоль запросов, необходимо вызвать функцию в окне
//   «Вычислить выражение»(Shift + F9), скопировать полученный XML в поле "Текст запроса"
//   консоли запросов и выполнить команду "Заполнить из XML" из меню "Еще".
//   Подробнее об использование функции смотрите в справке к консоли запросов.
//
// Параметры:
//   Запрос - Запрос - Запрос, который необходимо выгрузить в формат строки XML.
//
// Возвращаемое значение:
//   Строка - строка в формате XML, которую можно извлечь при помощи метода "ОбщегоНазначения.ЗначениеИзСтрокиXML".
//       После извлечения получится объект типа "Структура" с полями:
//       * Текст     - Строка - Текст запроса.
//       * Параметры - Структура - Параметры запроса.
//
Функция ЗапросВСтрокуXML(Запрос) Экспорт
	Структура = Новый Структура("Текст, Параметры");
	ЗаполнитьЗначенияСвойств(Структура, Запрос);
	Возврат ЗначениеВСтрокуXML(Структура);
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Обновляет данные в кэше версий.
//
// Параметры:
//  Идентификатор      - Строка - идентификатор записи кэша.
//  ТипДанных          - ПеречислениеСсылка.ТипыДанныхКэшаПрограммныхИнтерфейсов - тип обновляемых данных.
//  ПараметрыПолучения - Массив - дополнительные параметры получения данных в кэш.
//
Процедура ОбновитьДанныеКэшаВерсий(Знач Идентификатор, Знач ТипДанных, Знач ПараметрыПолучения) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	СтруктураКлюча = Новый Структура("Идентификатор, ТипДанных", Идентификатор, ТипДанных);
	Ключ = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьКлючЗаписи(СтруктураКлюча);
	
	Попытка
		ЗаблокироватьДанныеДляРедактирования(Ключ);
	Исключение
		// Данные уже обновляются из другого сеанса.
		Возврат;
	КонецПопытки;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	ТаблицаКэша.ДатаОбновления КАК ДатаОбновления,
		|	ТаблицаКэша.Данные КАК Данные,
		|	ТаблицаКэша.ТипДанных КАК ТипДанных
		|ИЗ
		|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК ТаблицаКэша
		|ГДЕ
		|	ТаблицаКэша.Идентификатор = &Идентификатор
		|	И ТаблицаКэша.ТипДанных = &ТипДанных";
	Идентификатор = Идентификатор;
	Запрос.УстановитьПараметр("Идентификатор", Идентификатор);
	Запрос.УстановитьПараметр("ТипДанных", ТипДанных);
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КэшПрограммныхИнтерфейсов");
		ЭлементБлокировки.УстановитьЗначение("Идентификатор", Идентификатор);
		ЭлементБлокировки.УстановитьЗначение("ТипДанных", ТипДанных);
		Блокировка.Заблокировать();
		
		Результат = Запрос.Выполнить();
		
		// Не удерживаем транзакцию для того, чтобы другие сеансы могли выполнять чтение данных.
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		РазблокироватьДанныеДляРедактирования(Ключ);
		ВызватьИсключение;
		
	КонецПопытки;
	
	Попытка	
		// Убедимся, что данные требуют обновления.
		Если Не Результат.Пустой() Тогда
			
			Выборка = Результат.Выбрать();
			Выборка.Следующий();
			Если Не ЗаписьКэшаВерсийУстарела(Выборка) Тогда
				РазблокироватьДанныеДляРедактирования(Ключ);
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
		
		Набор = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьНаборЗаписей();
		Набор.Отбор.Идентификатор.Установить(Идентификатор);
		Набор.Отбор.ТипДанных.Установить(ТипДанных);
		
		Запись = Набор.Добавить();
		Запись.Идентификатор = Идентификатор;
		Запись.ТипДанных = ТипДанных;
		Запись.ДатаОбновления = ТекущаяУниверсальнаяДата();
		
		Набор.ДополнительныеСвойства.Вставить("ПараметрыПолучения", ПараметрыПолучения);
		Набор.ПодготовитьДанныеДляЗаписи();
		
		Набор.Записать();
		
		РазблокироватьДанныеДляРедактирования(Ключ);
		
	Исключение
		
		РазблокироватьДанныеДляРедактирования(Ключ);
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Подготавливает данные для кэша программных интерфейсов.
//
// Параметры:
//  ТипДанных          - ПеречислениеСсылка.ТипыДанныхКэшаПрограммныхИнтерфейсов - тип обновляемых данных.
//  ПараметрыПолучения - Массив - дополнительные параметры получения данных в кэш.
//
Функция ПодготовитьДанныеКэшаВерсий(Знач ТипДанных, Знач ПараметрыПолучения) Экспорт
	
	Если ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ВерсииИнтерфейса Тогда
		Данные = ПолучитьВерсииИнтерфейсаВКэш(ПараметрыПолучения[0], ПараметрыПолучения[1]);
	ИначеЕсли ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса Тогда
		Данные = ПолучитьWSDL(ПараметрыПолучения[0], ПараметрыПолучения[1], ПараметрыПолучения[2], ПараметрыПолучения[3]);
	Иначе
		ШаблонТекста = НСтр("ru = 'Неизвестный тип данных кэша версий: %1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонТекста, ТипДанных);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Возвращает факт устаревания записи кэша версий.
//
// Параметры:
//  Запись - РегистрСведенийМенеджерЗаписи.КэшПрограммныхИнтерфейсов - запись, факт устаревания которой требуется
//                                                                     проверить.
//
// Возвращаемое значение:
//  Булево - признак устаревания записи.
//
Функция ЗаписьКэшаВерсийУстарела(Знач Запись) Экспорт
	
	Если Запись.ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса Тогда
		Возврат НЕ ЗначениеЗаполнено(Запись.ДатаОбновления)
	Иначе
		Возврат Запись.ДатаОбновления + 86400 < ТекущаяУниверсальнаяДата();
	КонецЕсли;
	
КонецФункции

// Формирует идентификатор записи кэша версий из адреса сервера и имени ресурса.
//
// Параметры:
//  Адрес - Строка - адрес сервера.
//  Имя   - Строка - имя ресурса.
//
// Возвращаемое значение:
//  Строка - идентификатор записи кэша версий.
//
Функция ИдентификаторЗаписиКэшаВерсий(Знач Адрес, Знач Имя)
	
	Возврат Адрес + "|" + Имя;
	
КонецФункции

// Функция возвращает объект WSОпределения созданный с переданными параметрами.
//
// Примечание: при получении определения используется кэш, обновление которого осуществляется
//  при смене версии конфигурации. Если для целей отладки требуется обновить
//  значения в кэше, раньше этого времени, следует удалить из регистра сведений.
//  КэшПрограммныхИнтерфейсов соответствующие записи.
//
// Параметры:
//  АдресWSDL       - Строка - месторасположение wsdl.
//  ИмяПользователя - Строка - имя пользователя для входа на сервер.
//  Пароль          - Строка - пароль пользователя.
//  Таймаут         - Число  - таймаут на получение wsdl.
//
// Возвращаемое значение:
//  WSОпределения 
//
Функция WSОпределения(Знач АдресWSDL, Знач ИмяПользователя, Знач Пароль, Знач Таймаут = 10) Экспорт
	
	Если Не ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		Возврат Новый WSОпределения(АдресWSDL, ИмяПользователя, Пароль, ,Таймаут);
	КонецЕсли;
	
	ПараметрыПолучения = Новый Массив;
	ПараметрыПолучения.Добавить(АдресWSDL);
	ПараметрыПолучения.Добавить(ИмяПользователя);
	ПараметрыПолучения.Добавить(Пароль);
	ПараметрыПолучения.Добавить(Таймаут);
	
	ДанныеWSDL = ОбщегоНазначенияПовтИсп.ДанныеКэшаВерсий(
		АдресWSDL, 
		Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса, 
		ЗначениеВСтрокуXML(ПараметрыПолучения),
		Ложь);
		
	ИмяФайлаWSDL = ПолучитьИмяВременногоФайла("wsdl");
	
	ДанныеWSDL.Записать(ИмяФайлаWSDL);
	
	ИнтернетПрокси = Неопределено;
	Если ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернетаКлиентСервер = ОбщийМодуль("ПолучениеФайловИзИнтернетаКлиентСервер");
		ИнтернетПрокси = МодульПолучениеФайловИзИнтернетаКлиентСервер.ПолучитьПрокси(АдресWSDL);
	КонецЕсли;
	Определения = Новый WSОпределения(ИмяФайлаWSDL, ИмяПользователя, Пароль, ИнтернетПрокси, Таймаут);
	
	Попытка
		УдалитьФайлы(ИмяФайлаWSDL);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение WSDL'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат Определения;
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL           - Строка - месторасположение wsdl.
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса.
//  ИмяСервиса          - Строка - имя сервиса.
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap.
//  ИмяПользователя     - Строка - имя пользователя для входа на сервер.
//  Пароль              - Строка - пароль пользователя.
//  Таймаут             - Число  - таймаут на операции выполняемые через полученное прокси.
//
// Возвращаемое значение:
//  WSПрокси
//
Функция ВнутренняяWSПрокси(Знач АдресWSDL, Знач URIПространстваИмен, Знач ИмяСервиса,
	Знач ИмяТочкиПодключения, Знач ИмяПользователя, Знач Пароль, Знач Таймаут) Экспорт
	
	WSОпределения = ОбщегоНазначенияПовтИсп.WSОпределения(АдресWSDL, ИмяПользователя, Пароль);
	
	Если ПустаяСтрока(ИмяТочкиПодключения) Тогда
		ИмяТочкиПодключения = ИмяСервиса + "Soap";
	КонецЕсли;
	
	ИнтернетПрокси = Неопределено;
	Если ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернетаКлиентСервер = ОбщийМодуль("ПолучениеФайловИзИнтернетаКлиентСервер");
		ИнтернетПрокси = МодульПолучениеФайловИзИнтернетаКлиентСервер.ПолучитьПрокси(АдресWSDL);
	КонецЕсли;
	
	Протокол = "";
	Позиция = СтрНайти(АдресWSDL, "://");
	Если Позиция > 0 Тогда
		Протокол = НРег(Лев(АдресWSDL, Позиция - 1));
	КонецЕсли;
	
	ЗащищенноеСоединение = Неопределено;
	Если (Протокол = "https" Или Протокол = "ftps")  Тогда
		ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL;
	КонецЕсли;
	
	Прокси = Новый WSПрокси(WSОпределения, URIПространстваИмен, ИмяСервиса, ИмяТочкиПодключения, ИнтернетПрокси, Таймаут, ЗащищенноеСоединение);
	Прокси.Пользователь = ИмяПользователя;
	Прокси.Пароль       = Пароль;
	
	Возврат Прокси;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Функция ДанныеИзБезопасногоХранилища(Владелец, ИмяБезопасноеХранилищеДанных, Ключ)
	
	Результат = Новый Структура(Ключ);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	БезопасноеХранилищеДанных.Данные КАК Данные
	|ИЗ
	|	РегистрСведений." + ИмяБезопасноеХранилищеДанных + " КАК БезопасноеХранилищеДанных
	|ГДЕ
	|	БезопасноеХранилищеДанных.Владелец = &Владелец";
	
	Запрос.УстановитьПараметр("Владелец", Владелец);
	РезультатЗапроса = Запрос.Выполнить().Выбрать();
	
	Если РезультатЗапроса.Следующий() Тогда
		Если ЗначениеЗаполнено(РезультатЗапроса.Данные) Тогда
			СохраненныеДанные = РезультатЗапроса.Данные.Получить();
			Если ЗначениеЗаполнено(СохраненныеДанные) Тогда
				ЗаполнитьЗначенияСвойств(Результат, СохраненныеДанные);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Процедура НоваяСтрокаКоллекцииОбъектовМетаданных(Имя, Синоним, Картинка, КартинкаОбъекта, Таб)
	
	НоваяСтрока = Таб.Добавить();
	НоваяСтрока.Имя               = Имя;
	НоваяСтрока.Синоним           = Синоним;
	НоваяСтрока.Картинка          = Картинка;
	НоваяСтрока.КартинкаОбъекта   = КартинкаОбъекта;
	
КонецПроцедуры

Функция ПолучитьВерсииИнтерфейсаВКэш(Знач ПараметрыПодключения, Знач ИмяИнтерфейса)
	
	Если Не ПараметрыПодключения.Свойство("URL") 
		Или Не ЗначениеЗаполнено(ПараметрыПодключения.URL) Тогда
		
		ВызватьИсключение(НСтр("ru = 'Не задан URL сервиса.'"));
	КонецЕсли;
	
	Если ПараметрыПодключения.Свойство("UserName")
		И ЗначениеЗаполнено(ПараметрыПодключения.UserName) Тогда
		
		ИмяПользователя = ПараметрыПодключения.UserName;
		
		Если ПараметрыПодключения.Свойство("Password") Тогда
			ПарольПользователя = ПараметрыПодключения.Password;
		Иначе
			ПарольПользователя = Неопределено;
		КонецЕсли;
		
	Иначе
		ИмяПользователя = Неопределено;
		ПарольПользователя = Неопределено;
	КонецЕсли;
	
	АдресСервиса = ПараметрыПодключения.URL + "/ws/InterfaceVersion?wsdl";
	
	ПроксиВерсионирования = WSПрокси(АдресСервиса, "http://www.1c.ru/SaaS/1.0/WS",
		"InterfaceVersion", , ИмяПользователя, ПарольПользователя, 3);
		
	МассивXDTO = ПроксиВерсионирования.GetVersions(ИмяИнтерфейса);
	Если МассивXDTO = Неопределено Тогда
		Возврат Новый ФиксированныйМассив(Новый Массив);
	Иначе	
		Сериализатор = Новый СериализаторXDTO(ПроксиВерсионирования.ФабрикаXDTO);
		Возврат Новый ФиксированныйМассив(Сериализатор.ПрочитатьXDTO(МассивXDTO));
	КонецЕсли;
	
КонецФункции

Функция ПолучитьWSDL(Знач Адрес, Знач ИмяПользователя, Знач Пароль, Знач Таймаут)
	
	ПараметрыПолучения = Новый Структура;
	Если НЕ ПустаяСтрока(ИмяПользователя) Тогда
		ПараметрыПолучения.Вставить("Пользователь", ИмяПользователя);
		ПараметрыПолучения.Вставить("Пароль", Пароль);
	КонецЕсли;
	ПараметрыПолучения.Вставить("Таймаут", Таймаут);
	
	ОписаниеФайла = Неопределено;
	
	ПриСкачиванииФайлаНаСервере(Адрес, ПараметрыПолучения, ОписаниеФайла);
	
	Если НЕ ОписаниеФайла.Статус Тогда
		ВызватьИсключение(НСтр("ru = 'Ошибка получения файла описания web-сервиса:'") + Символы.ПС + ОписаниеФайла.СообщениеОбОшибке)
	КонецЕсли;
	
	ИнтернетПрокси = Неопределено;
	Если ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернетаКлиентСервер = ОбщийМодуль("ПолучениеФайловИзИнтернетаКлиентСервер");
		ИнтернетПрокси = МодульПолучениеФайловИзИнтернетаКлиентСервер.ПолучитьПрокси(Адрес);
	КонецЕсли;
	Определения = Новый WSОпределения(ОписаниеФайла.Путь, ИмяПользователя, Пароль, ИнтернетПрокси, Таймаут);
	
	Если Определения.Сервисы.Количество() = 0 Тогда
		ШаблонСообщения = НСтр("ru = 'Ошибка получения файла описания web-сервиса:
			|В полученном файле не содержится ни одного описания сервиса.
			|
			|Возможно, адрес файла описания указан неверно:
			|%1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Адрес);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	Определения = Неопределено;
	
	ДанныеФайла = Новый ДвоичныеДанные(ОписаниеФайла.Путь);
	
	Попытка
		УдалитьФайлы(ОписаниеФайла.Путь);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение WSDL'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат ДанныеФайла;
	
КонецФункции

Процедура ПроверкаФиксированностиДанных(Данные, ДанныеВЗначенииФиксированныхТипов = Ложь)
	
	ТипДанных = ТипЗнч(Данные);
	
	Если ТипДанных = Тип("ХранилищеЗначения")
	 ИЛИ ТипДанных = Тип("ФиксированныйМассив")
	 ИЛИ ТипДанных = Тип("ФиксированнаяСтруктура")
	 ИЛИ ТипДанных = Тип("ФиксированноеСоответствие") Тогда
		
		Возврат;
	КонецЕсли;
	
	Если ДанныеВЗначенииФиксированныхТипов Тогда
		
		Если ТипДанных = Тип("Булево")
		 ИЛИ ТипДанных = Тип("Строка")
		 ИЛИ ТипДанных = Тип("Число")
		 ИЛИ ТипДанных = Тип("Дата")
		 ИЛИ ТипДанных = Тип("Неопределено")
		 ИЛИ ТипДанных = Тип("УникальныйИдентификатор")
		 ИЛИ ТипДанных = Тип("Null")
		 ИЛИ ТипДанных = Тип("Тип")
		 ИЛИ ТипДанных = Тип("ХранилищеЗначения")
		 ИЛИ ТипДанных = Тип("ОбщийМодуль")
		 ИЛИ ТипДанных = Тип("ОбъектМетаданных")
		 ИЛИ ТипДанных = Тип("ТипЗначенияXDTO")
		 ИЛИ ТипДанных = Тип("ТипОбъектаXDTO")
		 ИЛИ ЭтоСсылка(ТипДанных) Тогда
			
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Ошибка в функции ФиксированныеДанные общего модуля ОбщегоНазначения.
		           |Данные типа ""%1"" не могут быть зафиксированы.'"),
		Строка(ТипДанных) );
	
КонецПроцедуры

Процедура ДобавитьИсключенияПоискаСсылок(Результат, МассивИсключений)
	Для Каждого ЭлементМассива Из МассивИсключений Цикл
		Если ТипЗнч(ЭлементМассива) = Тип("Строка") Тогда
			ЭлементМетаданные = Метаданные.НайтиПоПолномуИмени(ЭлементМассива);
		Иначе
			ЭлементМетаданные = ЭлементМассива;
		КонецЕсли;
		
		РодительМетаданные = ЭлементМетаданные.Родитель();
		
		// Регистрация исключаемого объекта метаданных целиком (всех ссылок, которые он может содержать).
		Если ТипЗнч(РодительМетаданные) = Тип("ОбъектМетаданныхКонфигурация") Тогда
			Результат.Вставить(ЭлементМетаданные, "*");
			Продолжить;
		КонецЕсли;
		
		// Регистрация исключаемого реквизита объекта метаданных.
		ОтносительныйПутьКРеквизиту = ЭлементМетаданные.Имя;
		РодительРодителя = РодительМетаданные.Родитель();
		Пока ТипЗнч(РодительРодителя) <> Тип("ОбъектМетаданныхКонфигурация") Цикл
			ОтносительныйПутьКРеквизиту = РодительМетаданные.Имя + "." + ОтносительныйПутьКРеквизиту;
			РодительМетаданные = РодительРодителя;
			РодительРодителя   = РодительМетаданные.Родитель();
		КонецЦикла;
		
		ПутиКРеквизитам = Результат.Получить(РодительМетаданные);
		Если ПутиКРеквизитам = "*" Тогда
			Продолжить; // - Пропуск, если весь объект метаданных уже исключен.
		ИначеЕсли ПутиКРеквизитам = Неопределено Тогда
			ПутиКРеквизитам = Новый Массив;
		КонецЕсли;
		ПутиКРеквизитам.Добавить(ОтносительныйПутьКРеквизиту);
		
		Результат.Вставить(РодительМетаданные, ПутиКРеквизитам);
	КонецЦикла;
КонецПроцедуры

// Возвращает строку ключа настроек, не превышающую допустимую длину.
// Проверяет длину строки на входе и, в случае превышения 128, преобразует ее конец по алгоритму MD5 в короткий
// вариант, в результате чего строка становится длиной 128 символов.
// Если исходная строка менее 128 символов, она возвращается в неизменном виде.
//
// Параметры:
//  Строка - Строка - строка произвольной длины.
//
Функция КлючНастроек(Знач Строка)
	Результат = Строка;
	Если СтрДлина(Строка) > 128 Тогда // Ключ более 128 символов вызовет исключение при обращении к хранилищу настроек.
		Результат = Лев(Строка, 96);
		ХешированиеДанных = Новый ХешированиеДанных(ХешФункция.MD5);
		ХешированиеДанных.Добавить(Сред(Строка, 97));
		Результат = Результат + СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Возвращает серверный модуль менеджера по имени объекта.
Функция СерверныйМодульМенеджера(Имя)
	ОбъектНайден = Ложь;
	
	ЧастиИмени = СтрРазделить(Имя, ".");
	Если ЧастиИмени.Количество() = 2 Тогда
		
		ИмяВида = ВРег(ЧастиИмени[0]);
		ИмяОбъекта = ЧастиИмени[1];
		
		Если ИмяВида = ВРег(ИмяТипаКонстанты()) Тогда
			Если Метаданные.Константы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаРегистрыСведений()) Тогда
			Если Метаданные.РегистрыСведений.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаРегистрыНакопления()) Тогда
			Если Метаданные.РегистрыНакопления.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаРегистрыБухгалтерии()) Тогда
			Если Метаданные.РегистрыБухгалтерии.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаРегистрыРасчета()) Тогда
			Если Метаданные.РегистрыРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаСправочники()) Тогда
			Если Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаДокументы()) Тогда
			Если Метаданные.Документы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаОтчеты()) Тогда
			Если Метаданные.Отчеты.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаОбработки()) Тогда
			Если Метаданные.Обработки.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаБизнесПроцессы()) Тогда
			Если Метаданные.БизнесПроцессы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаЖурналыДокументов()) Тогда
			Если Метаданные.ЖурналыДокументов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаЗадачи()) Тогда
			Если Метаданные.Задачи.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаПланыСчетов()) Тогда
			Если Метаданные.ПланыСчетов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаПланыОбмена()) Тогда
			Если Метаданные.ПланыОбмена.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаПланыВидовХарактеристик()) Тогда
			Если Метаданные.ПланыВидовХарактеристик.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаПланыВидовРасчета()) Тогда
			Если Метаданные.ПланыВидовРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ОбъектНайден Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Объект метаданных ""%1"" не найден,
			|либо для него не поддерживается получение модуля менеджера.'"), Имя);
	КонецЕсли;
	
	Модуль = РаботаВБезопасномРежиме.ВычислитьВБезопасномРежиме(Имя);
	
	Возврат Модуль;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в другие подсистемы.

// Получить файл из Интернета по протоколу http(s), либо ftp и сохранить его во временный файл.
//
// Параметры:
//   URL                  - Строка - url файла в формате.
//                                   [Протокол://]<Сервер>/<Путь к файлу на сервере>.
//   ПараметрыПолучения   - Структура со свойствами.
//     ПутьДляСохранения    - Строка - путь на сервере (включая имя файла), для сохранения скачанного файла.
//     Пользователь         - Строка - пользователь от имени которого установлено соединение.
//     Пароль               - Строка - пароль пользователя от которого установлено соединение.
//     Порт                 - Число  - порт сервера с которым установлено соединение.
//     ЗащищенноеСоединение - Булево - для случая http загрузки флаг указывает,
//                                     что соединение должно производиться через https.
//     ПассивноеСоединение  - Булево - для случая ftp загрузки флаг указывает,
//                                     что соединение должно пассивным (или активным).
//   ВозвращаемоеЗначение - (выходной параметр).
//     Структура, со свойствами.
//       Статус - Булево - ключ присутствует в структуре всегда, значения.
//                         Истина - вызов функции успешно завершен.
//                         Ложь   - вызов функции завершен неудачно.
//       Путь   - Строка - путь к файлу на сервере, ключ используется только
//                         если статус Истина.
//       СообщениеОбОшибке - Строка - сообщение об ошибке, если статус Ложь.
//
Процедура ПриСкачиванииФайлаНаСервере(Знач Адрес, Знач ПараметрыПолучения, ВозвращаемоеЗначение)
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернета = ОбщийМодуль("ПолучениеФайловИзИнтернета");
		ВозвращаемоеЗначение = МодульПолучениеФайловИзИнтернета.СкачатьФайлНаСервере(Адрес, ПараметрыПолучения);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает разделение сеанса.
//
// Параметры:
// Использование - Булево - Использование разделителя ОбластьДанных в сеансе.
// ОбластьДанных - Число - Значение разделителя ОбластьДанных.
//
Процедура ПриУстановкеРазделенияСеанса(Знач Использование, Знач ОбластьДанных = Неопределено)
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		МодульРаботаВМоделиСервиса.УстановитьРазделениеСеанса(Использование, ОбластьДанных);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Параметры:
//  ЗначениеРазделителя - Значение разделителя текущей области данных. Возвращаемый параметр.
//
Процедура ПриПолученииЗначенияРазделителяСеанса(ЗначениеРазделителя)
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		ЗначениеРазделителя = МодульРаботаВМоделиСервиса.ЗначениеРазделителяСеанса();
	Иначе
		ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
	
КонецПроцедуры

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Параметры:
// ИспользованиеРазделителя - Булево - Истина разделение используется, иначе нет. Возвращаемый параметр.
// 
Процедура ПриПолученииИспользованияРазделителяСеанса(ИспользованиеРазделителя)
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		ИспользованиеРазделителя = МодульРаботаВМоделиСервиса.ИспользованиеРазделителяСеанса();
	Иначе
		ВызватьИсключение(НСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ Замена ссылок.

Функция ОписаниеТипаКлючиЗаписей()
	
	ДобавляемыеТипы = Новый Массив;
	Для Каждого Мета Из Метаданные.РегистрыСведений Цикл
		ДобавляемыеТипы.Добавить(Тип("РегистрСведенийКлючЗаписи." + Мета.Имя));
	КонецЦикла;
	Для Каждого Мета Из Метаданные.РегистрыНакопления Цикл
		ДобавляемыеТипы.Добавить(Тип("РегистрНакопленияКлючЗаписи." + Мета.Имя));
	КонецЦикла;
	Для Каждого Мета Из Метаданные.РегистрыБухгалтерии Цикл
		ДобавляемыеТипы.Добавить(Тип("РегистрБухгалтерииКлючЗаписи." + Мета.Имя));
	КонецЦикла;
	Для Каждого Мета Из Метаданные.РегистрыРасчета Цикл
		ДобавляемыеТипы.Добавить(Тип("РегистрРасчетаКлючЗаписи." + Мета.Имя));
	КонецЦикла;
	
	Возврат Новый ОписаниеТипов(ДобавляемыеТипы); 
КонецФункции

Функция РазметитьМестаИспользования(Знач ПараметрыВыполнения, Знач Ссылка, Знач ЦелеваяСсылка, Знач ТаблицаПоиска)
	УстановитьПривилегированныйРежим(Истина);
	
	// Устанавливаем порядок известных и проверяем наличие неопознанных объектов.
	Результат = Новый Структура;
	Результат.Вставить("МестаИспользования", ТаблицаПоиска.НайтиСтроки(Новый Структура("Ссылка", Ссылка)));
	Результат.Вставить("ОшибкиРазметки",     Новый Массив);
	Результат.Вставить("Успех",              Истина);
	
	Для Каждого МестоИспользования Из Результат.МестаИспользования Цикл
		Если МестоИспользования.ВспомогательныеДанные Тогда
			Продолжить; // Зависимые данные не обрабатываются.
		КонецЕсли;
		
		Информация = ИнформацияОТипе(МестоИспользования.Метаданные, ПараметрыВыполнения);
		Если Информация.Вид = "КОНСТАНТА" Тогда
			МестоИспользования.КлючЗамены = "Константа";
			МестоИспользования.ЦелеваяСсылка = ЦелеваяСсылка;
			
		ИначеЕсли Информация.Вид = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
			МестоИспользования.КлючЗамены = "Последовательность";
			МестоИспользования.ЦелеваяСсылка = ЦелеваяСсылка;
			
		ИначеЕсли Информация.Вид = "РЕГИСТРСВЕДЕНИЙ" Тогда
			МестоИспользования.КлючЗамены = "РегистрСведений";
			МестоИспользования.ЦелеваяСсылка = ЦелеваяСсылка;
			
		ИначеЕсли Информация.Вид = "РЕГИСТРБУХГАЛТЕРИИ"
			Или Информация.Вид = "РЕГИСТРНАКОПЛЕНИЯ"
			Или Информация.Вид = "РЕГИСТРРАСЧЕТА" Тогда
			МестоИспользования.КлючЗамены = "КлючЗаписи";
			МестоИспользования.ЦелеваяСсылка = ЦелеваяСсылка;
			
		ИначеЕсли Информация.Ссылочный Тогда
			МестоИспользования.КлючЗамены = "Объект";
			МестоИспользования.ЦелеваяСсылка = ЦелеваяСсылка;
			
		Иначе
			// Неизвестный объект для замены ссылок.
			Результат.Успех = Ложь;
			Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Замена ссылок в ""%1"" не поддерживается.'"), Информация.ПолноеИмя);
			ОписаниеОшибки = Новый Структура("Объект, Текст", МестоИспользования.Данные, Текст);
			Результат.ОшибкиРазметки.Добавить(ОписаниеОшибки);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Процедура ПроизвестиЗаменуВКонстанте(Результат, Знач МестоИспользования, Знач ПараметрыЗаписи, Знач ВнутренняяТранзакция = Истина)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Данные = МестоИспользования.Данные;
	Мета   = МестоИспользования.Метаданные;
	
	ПредставлениеДанных = Строка(Данные);
	
	// Будем производить сразу все замены для этих данных.
	Фильтр = Новый Структура("Данные, КлючЗамены", Данные, "Константа");
	ОбрабатываемыеСтроки = МестоИспользования.Владелец().НайтиСтроки(Фильтр);
	
	СостояниеОперации = "";
	
	Если ВнутренняяТранзакция Тогда
		НачатьТранзакцию();
		
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить(Мета.ПолноеИмя());
	
		Попытка
			Блокировка.Заблокировать();
		Исключение
			// Добавляем запись в результат о неудачной попытке блокировке.
			Ошибка = НСтр("ru = 'Не удалось заблокировать константу %1'");
			Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
			
			СостояниеОперации = "ОшибкаБлокировки";
		КонецПопытки;
		
	КонецЕсли;	// Необходимость блокировки
	
	Если СостояниеОперации = "" Тогда
		Менеджер = Константы[Мета.Имя].СоздатьМенеджерЗначения();
		Менеджер.Прочитать();
		
		ЗаменаПроизведена = Истина;
		Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
			Если Менеджер.Значение = Строка.Ссылка Тогда
				Менеджер.Значение = Строка.ЦелеваяСсылка;
				ЗаменаПроизведена = Истина;
			КонецЕсли;
		КонецЦикла;
		
		Если ЗаменаПроизведена Тогда
			// Пытаемся сохранить
			Если Не ПараметрыЗаписи.ПривилегированнаяЗапись Тогда
				УстановитьПривилегированныйРежим(Ложь);
			КонецЕсли;
			
			Попытка
				ЗаписатьОбъект(Менеджер, ПараметрыЗаписи);
			Исключение
				// Сохраняем причину
				Информация = ИнформацияОбОшибке();
				ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииЗаменыСсылок(),
					УровеньЖурналаРегистрации.Ошибка, Мета, ПодробноеПредставлениеОшибки(Информация));
				
				// Добавляем запись в результат о ошибке записи.
				ОписаниеОшибки = КраткоеПредставлениеОшибки(Информация);
				Если ПустаяСтрока(ОписаниеОшибки) Тогда
					ОписаниеОшибки = Информация.Описание;
				КонецЕсли;
				
				Ошибка = НСтр("ru = 'Не удалось записать %1 по причине: %2'");
				Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
				Ошибка = СтрЗаменить(Ошибка, "%2", ОписаниеОшибки);
				
				Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
					ЗарегистрироватьОшибкуЗамены(Результат, Строка.Ссылка, 
						ОписаниеОшибкиЗамены("ОшибкаЗаписи", Данные, ПредставлениеДанных, Ошибка));
				КонецЦикла;
				
				СостояниеОперации = "ОшибкаЗаписи";
			КонецПопытки;
			
			Если Не ПараметрыЗаписи.ПривилегированнаяЗапись Тогда
				УстановитьПривилегированныйРежим(Истина);
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если ВнутренняяТранзакция Тогда
		Если СостояниеОперации = "" Тогда
			ЗафиксироватьТранзакцию();
		Иначе
			ОтменитьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
	// Помечаем как обработанные
	Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
		Строка.КлючЗамены = "";
	КонецЦикла;

КонецПроцедуры

Процедура ПроизвестиЗаменуВОбъекте(Результат, Знач МестоИспользования, Знач ПараметрыВыполнения, Знач ВнутренняяТранзакция = Истина)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Данные = МестоИспользования.Данные;
	
	// Будем производить сразу все замены для этих данных.
	Фильтр = Новый Структура("Данные, КлючЗамены", Данные, "Объект");
	ОбрабатываемыеСтроки = МестоИспользования.Владелец().НайтиСтроки(Фильтр);
	
	ПредставлениеДанных = ПредметСтрокой(Данные);
	
	СостояниеОперации = "";
	
	Если ВнутренняяТранзакция Тогда
		НачатьТранзакцию();
		
		Блокировка = Новый БлокировкаДанных;
		ЗаблокироватьМестоИспользования(ПараметрыВыполнения, Блокировка, МестоИспользования);
		
		ИнформацияОбОшибке = Неопределено;
		Попытка
			Блокировка.Заблокировать();
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		Если ИнформацияОбОшибке <> Неопределено Тогда
			СостояниеОперации = "ОшибкаБлокировки";
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не удалось заблокировать объект ""%1"":
				|%2'"),
				ПредставлениеДанных,
				СтандартныеПодсистемыКлиентСервер.ИсходнаяПричинаОшибки(ИнформацияОбОшибке));
			ОписаниеОшибки = ОписаниеОшибкиЗамены("ОшибкаБлокировки", Данные, ПредставлениеДанных, ТекстОшибки);
			ЗарегистрироватьОшибкуЗамены(Результат, МестоИспользования.Ссылка, ОписаниеОшибки);
			Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
				ЗарегистрироватьОшибкуЗамены(Результат, Строка.Ссылка, ОписаниеОшибки);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Если СостояниеОперации = "" Тогда
		ОбъектыЗаписи = ИзмененныеОбъектыПриЗаменеВОбъекте(ПараметрыВыполнения, МестоИспользования, ОбрабатываемыеСтроки);
		
		// Пытаемся сохранить, сам объект идет последним.
		Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
			УстановитьПривилегированныйРежим(Ложь);
		КонецЕсли;
		
		Попытка
			Если ПараметрыВыполнения.ВключатьБизнесЛогику Тогда
				// Первая запись без контроля, чтобы устранить циклические ссылки.
				НовыеПараметрыВыполнения = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(ПараметрыВыполнения);
				НовыеПараметрыВыполнения.ВключатьБизнесЛогику = Ложь;
				Для Каждого КлючЗначение Из ОбъектыЗаписи Цикл
					ЗаписатьОбъект(КлючЗначение.Ключ, НовыеПараметрыВыполнения);
				КонецЦикла;
				// Вторая запись c контролем.
				НовыеПараметрыВыполнения.ВключатьБизнесЛогику = Истина;
				Для Каждого КлючЗначение Из ОбъектыЗаписи Цикл
					ЗаписатьОбъект(КлючЗначение.Ключ, НовыеПараметрыВыполнения);
				КонецЦикла;
			Иначе
				// Запись без контроля бизнес-логики.
				Для Каждого КлючЗначение Из ОбъектыЗаписи Цикл
					ЗаписатьОбъект(КлючЗначение.Ключ, ПараметрыВыполнения);
				КонецЦикла;
			КонецЕсли;
		Исключение
			// Сохраняем причину
			Информация = ИнформацияОбОшибке();
			ЗаписьЖурналаРегистрации(
				СобытиеЖурналаРегистрацииЗаменыСсылок(),
				УровеньЖурналаРегистрации.Ошибка,
				МестоИспользования.Метаданные,
				ПодробноеПредставлениеОшибки(Информация));
			
			ОписаниеОшибки = КраткоеПредставлениеОшибки(Информация);
			Если ПустаяСтрока(ОписаниеОшибки) Тогда
				ОписаниеОшибки = Информация.Описание;
			КонецЕсли;
			
			// Добавляем запись в результат о ошибке записи.
			Ошибка = НСтр("ru = 'Не удалось записать %1 по причине: %2'");
			Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
			Ошибка = СтрЗаменить(Ошибка, "%2", ОписаниеОшибки);
			
			Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
				ЗарегистрироватьОшибкуЗамены(Результат, Строка.Ссылка, 
					ОписаниеОшибкиЗамены("ОшибкаЗаписи", Данные, ПредставлениеДанных, Ошибка));
			КонецЦикла;
			
			СостояниеОперации = "ОшибкаЗаписи";
		КонецПопытки;
		
		Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
			УстановитьПривилегированныйРежим(Истина);
		КонецЕсли;
		
		// Удаляем обработанные движения и последовательности из таблицы поиска.
	КонецЕсли;
	
	Если ВнутренняяТранзакция Тогда
		Если СостояниеОперации = "" Тогда
			ЗафиксироватьТранзакцию();
		Иначе
			ОтменитьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
	// Помечаем как обработанные
	Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
		Строка.КлючЗамены = "";
	КонецЦикла;
	
КонецПроцедуры

Процедура ПроизвестиЗаменуВНаборе(Результат, Знач МестоИспользования, Знач ПараметрыВыполнения, Знач ВнутренняяТранзакция = Истина)
	УстановитьПривилегированныйРежим(Истина);
	
	Данные = МестоИспользования.Данные;
	Мета   = МестоИспользования.Метаданные;
	
	ПредставлениеДанных = Строка(Данные);
	
	// Будем производить сразу все замены для этих данных.
	Фильтр = Новый Структура("Данные, КлючЗамены");
	ЗаполнитьЗначенияСвойств(Фильтр, МестоИспользования);
	ОбрабатываемыеСтроки = МестоИспользования.Владелец().НайтиСтроки(Фильтр);
	
	ОписаниеНабора = ОписаниеКлючаЗаписи(Мета);
	НаборЗаписей = ОписаниеНабора.НаборЗаписей;
	
	ПарыЗамен = Новый Соответствие;
	Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
		ПарыЗамен.Вставить(Строка.Ссылка, Строка.ЦелеваяСсылка);
	КонецЦикла;
	
	СостояниеОперации = "";
	
	Если ВнутренняяТранзакция Тогда
		НачатьТранзакцию();
		
		// Блокировка и подготовка набора.
		Блокировка = Новый БлокировкаДанных;
		Для Каждого КлючЗначение Из ОписаниеНабора.СписокИзмерений Цикл
			ТипИзмерения = КлючЗначение.Значение;
			Имя          = КлючЗначение.Ключ;
			Значение     = Данные[Имя];
			
			Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
				ТекущаяСсылка = Строка.Ссылка;
				Если ТипИзмерения.СодержитТип(ТипЗнч(ТекущаяСсылка)) Тогда
					Блокировка.Добавить(ОписаниеНабора.ПространствоБлокировки).УстановитьЗначение(Имя, ТекущаяСсылка);
				КонецЕсли;
			КонецЦикла;
			
			НаборЗаписей.Отбор[Имя].Установить(Значение);
		КонецЦикла;
		
		Попытка
			Блокировка.Заблокировать();
		Исключение
			// Добавляем запись в результат о неудачной попытке блокировке.
			Ошибка = НСтр("ru = 'Не удалось заблокировать набор  %1'");
			Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
			
			СостояниеОперации = "ОшибкаБлокировки";
		КонецПопытки;
		
	КонецЕсли;	// Необходимость блокировки
		
	Если СостояниеОперации = "" Тогда
		НаборЗаписей.Прочитать();
		ЗаменитьВКоллекцииСтрок("НаборЗаписей", "НаборЗаписей", НаборЗаписей, НаборЗаписей, ОписаниеНабора.СписокПолей, ПарыЗамен);
		
		Если НаборЗаписей.Модифицированность() Тогда
			// Пытаемся сохранить
			Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
				УстановитьПривилегированныйРежим(Ложь);
			КонецЕсли;
			
			Попытка
				ЗаписатьОбъект(НаборЗаписей, ПараметрыВыполнения);
			Исключение
				// Сохраняем причину
				Информация = ИнформацияОбОшибке();
				ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииЗаменыСсылок(),
					УровеньЖурналаРегистрации.Ошибка, Мета, ПодробноеПредставлениеОшибки(Информация));
					
				ОписаниеОшибки = КраткоеПредставлениеОшибки(Информация);
				Если ПустаяСтрока(ОписаниеОшибки) Тогда
					ОписаниеОшибки = Информация.Описание;
				КонецЕсли;
				
				// Добавляем запись в результат о ошибке записи.
				Ошибка = НСтр("ru = 'Не удалось записать %1 по причине: %2'");
				Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
				Ошибка = СтрЗаменить(Ошибка, "%2", ОписаниеОшибки);
				
				Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
					ЗарегистрироватьОшибкуЗамены(Результат, Строка.Ссылка, 
						ОписаниеОшибкиЗамены("ОшибкаЗаписи", Данные, ПредставлениеДанных, Ошибка));
				КонецЦикла;
				
				СостояниеОперации = "ОшибкаЗаписи";
			КонецПопытки;
			
			Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
				УстановитьПривилегированныйРежим(Истина);
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если ВнутренняяТранзакция Тогда
		Если СостояниеОперации = "" Тогда
			ЗафиксироватьТранзакцию();
		Иначе
			ОтменитьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
	// Помечаем как обработанные
	Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
		Строка.КлючЗамены = "";
	КонецЦикла;
	
КонецПроцедуры

Процедура ПроизвестиЗаменуВРегистреСведений(Результат, Знач МестоИспользования, Знач ПараметрыВыполнения, Знач ВнутренняяТранзакция = Истина)
	Если МестоИспользования.Обработано Тогда
		Возврат;
	КонецЕсли;
	МестоИспользования.Обработано = Истина;
	
	// В случае, если дубль указан в измерениях набора, тогда используется 2 набора записей:
	//     НаборЗаписейДубля - чтение старых значений (по старым измерениям) и удаление старых значений.
	//     НаборЗаписейОригинала - чтение актуальных значений (по новым измерениям) и запись новых значений.
	//     Данные дублей и оригиналов объединяются по правилам:
	//         Приоритет у данных оригинала.
	//         Если в оригинале нет данных, то берутся данные из дубля.
	//     Набор оригинала записывается, а набор дубля удаляется.
	//
	// В случае, если дубль не указан в измерениях набора, тогда используется 1 набор записей:
	//     НаборЗаписейДубля - чтение старых значений и запись новых значений.
	//
	// Замена ссылок в ресурсах и реквизитах производится в обоих случаях.
	
	УстановитьПривилегированныйРежим(Истина);
	
	Дубль    = МестоИспользования.Ссылка;
	Оригинал = МестоИспользования.ЦелеваяСсылка;
	
	МетаданныеРегистра = МестоИспользования.Метаданные;
	КлючЗаписиРегистра = МестоИспользования.Данные;
	
	Информация = ИнформацияОТипе(МетаданныеРегистра, ПараметрыВыполнения);
	
	ТребуетсяДваНабора = Ложь;
	Для Каждого КлючЗначение Из Информация.Измерения Цикл
		ЗначениеИзмеренияДубля = КлючЗаписиРегистра[КлючЗначение.Ключ];
		Если ЗначениеИзмеренияДубля = Дубль
			Или ПараметрыВыполнения.УспешныеЗамены[ЗначениеИзмеренияДубля] = Дубль Тогда
			ТребуетсяДваНабора = Истина; // Дубль указан в измерениях.
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Менеджер = МенеджерОбъектаПоПолномуИмени(Информация.ПолноеИмя);
	НаборЗаписейДубля = Менеджер.СоздатьНаборЗаписей();
	
	Если ТребуетсяДваНабора Тогда
		ЗначенияИзмеренийОригинала = Новый Структура;
		НаборЗаписейОригинала = Менеджер.СоздатьНаборЗаписей();
	КонецЕсли;
	
	Если ВнутренняяТранзакция Тогда
		НачатьТранзакцию();
		Блокировка = Новый БлокировкаДанных;
		БлокировкаДубля = Блокировка.Добавить(Информация.ПолноеИмя);
		Если ТребуетсяДваНабора Тогда
			БлокировкаОригинала = Блокировка.Добавить(Информация.ПолноеИмя);
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого КлючЗначение Из Информация.Измерения Цикл
		ЗначениеИзмеренияДубля = КлючЗаписиРегистра[КлючЗначение.Ключ];
		
		// Для решения проблемы уникальности
		//   выполняется замена старых значений измерений ключа записи на актуальные.
		//   Соответствие старых и актуальных обеспечивает соответствием УспешныеЗамены.
		//   Данные соответствия актуальны на текущий момент времени,
		//   т.к. пополняются только после успешной обработки очередной пары и фиксации транзакции.
		НовоеЗначениеИзмеренияДубля = ПараметрыВыполнения.УспешныеЗамены[ЗначениеИзмеренияДубля];
		Если НовоеЗначениеИзмеренияДубля <> Неопределено Тогда
			ЗначениеИзмеренияДубля = НовоеЗначениеИзмеренияДубля;
		КонецЕсли;
		
		НаборЗаписейДубля.Отбор[КлючЗначение.Ключ].Установить(ЗначениеИзмеренияДубля);
		
		Если ВнутренняяТранзакция Тогда // Замена в конкретной паре и блокировка на конкретную замену
			БлокировкаДубля.УстановитьЗначение(КлючЗначение.Ключ, ЗначениеИзмеренияДубля);
		КонецЕсли;
		
		Если ТребуетсяДваНабора Тогда
			Если ЗначениеИзмеренияДубля = Дубль Тогда
				ЗначениеИзмеренияОригинала = Оригинал;
			Иначе
				ЗначениеИзмеренияОригинала = ЗначениеИзмеренияДубля;
			КонецЕсли;
			
			НаборЗаписейОригинала.Отбор[КлючЗначение.Ключ].Установить(ЗначениеИзмеренияОригинала);
			ЗначенияИзмеренийОригинала.Вставить(КлючЗначение.Ключ, ЗначениеИзмеренияОригинала);
			
			Если ВнутренняяТранзакция Тогда // Замена в конкретной паре и блокировка на конкретную замену
				БлокировкаОригинала.УстановитьЗначение(КлючЗначение.Ключ, ЗначениеИзмеренияОригинала);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Установка блокировки.
	Если ВнутренняяТранзакция Тогда
		ИнформацияОбОшибке = Неопределено;
		Попытка
			Блокировка.Заблокировать();
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		Если ИнформацияОбОшибке <> Неопределено Тогда
			ЗарегистрироватьОшибкуВТаблицу(Результат, Дубль, Оригинал, КлючЗаписиРегистра, Информация, "БлокировкаДляРегистра", ИнформацияОбОшибке);
			ОтменитьТранзакцию();
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	// Откуда читаем?
	НаборЗаписейДубля.Прочитать();
	Если НаборЗаписейДубля.Количество() = 0 Тогда // Нечего писать.
		Если ВнутренняяТранзакция Тогда
			ОтменитьТранзакцию(); // Замена не требуется.
		КонецЕсли;
		Возврат;
	КонецЕсли;
	ЗаписьДубля = НаборЗаписейДубля[0];
	
	// Куда пишем?
	ЗаписьОригиналаЭтоНовый = Ложь;
	Если ТребуетсяДваНабора Тогда
		// Пишем в набор с другими измерениями.
		НаборЗаписейОригинала.Прочитать();
		Если НаборЗаписейОригинала.Количество() = 0 Тогда
			ЗаписьОригиналаЭтоНовый = Истина;
			ЗаписьОригинала = НаборЗаписейОригинала.Добавить();
			ЗаполнитьЗначенияСвойств(ЗаписьОригинала, ЗаписьДубля);
			ЗаполнитьЗначенияСвойств(ЗаписьОригинала, ЗначенияИзмеренийОригинала);
		Иначе
			ЗаписьОригинала = НаборЗаписейОригинала[0];
		КонецЕсли;
	Иначе
		// Пишем туда-же, откуда и читаем.
		НаборЗаписейОригинала = НаборЗаписейДубля;
		ЗаписьОригинала = ЗаписьДубля; // Ситуация с нулевым количеством записей в наборе обработана выше.
	КонецЕсли;
	
	// Замена дубля на оригинал в ресурсах и реквизитах.
	Для Каждого КлючЗначение Из Информация.Ресурсы Цикл
		ЗначениеРеквизитаВОригинале = ЗаписьОригинала[КлючЗначение.Ключ];
		Если ЗначениеРеквизитаВОригинале = Дубль Тогда
			ЗаписьОригинала[КлючЗначение.Ключ] = Оригинал;
			Модифицированность = Истина;
		КонецЕсли;
	КонецЦикла;
	Для Каждого КлючЗначение Из Информация.Реквизиты Цикл
		ЗначениеРеквизитаВОригинале = ЗаписьОригинала[КлючЗначение.Ключ];
		Если ЗначениеРеквизитаВОригинале = Дубль Тогда
			ЗаписьОригинала[КлючЗначение.Ключ] = Оригинал;
			Модифицированность = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
		УстановитьПривилегированныйРежим(Ложь);
	КонецЕсли;
	
	ЕстьЧтоФиксировать = Ложь;
	
	// Удаление данных дубля.
	Если ТребуетсяДваНабора Тогда
		НаборЗаписейДубля.Очистить();
		ИнформацияОбОшибке = Неопределено;
		Попытка
			ЗаписатьОбъект(НаборЗаписейДубля, ПараметрыВыполнения);
			ЕстьЧтоФиксировать = Истина;
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		Если ИнформацияОбОшибке <> Неопределено Тогда
			ЗарегистрироватьОшибкуВТаблицу(Результат, Дубль, Оригинал, КлючЗаписиРегистра, Информация, "УдалитьНаборДубля", ИнформацияОбОшибке);
		КонецЕсли;
	КонецЕсли;
	
	// Запись данных оригинала.
	Если НаборЗаписейОригинала.Модифицированность() Тогда
		ИнформацияОбОшибке = Неопределено;
		Попытка
			ЗаписатьОбъект(НаборЗаписейОригинала, ПараметрыВыполнения);
			ЕстьЧтоФиксировать = Истина;
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		Если ИнформацияОбОшибке <> Неопределено Тогда
			ЗарегистрироватьОшибкуВТаблицу(Результат, Дубль, Оригинал, КлючЗаписиРегистра, Информация, "ЗаписатьНаборОригинала", ИнформацияОбОшибке);
		КонецЕсли;
	КонецЕсли;
	
	Если ВнутренняяТранзакция Тогда
		Если ЕстьЧтоФиксировать Тогда
			ЗафиксироватьТранзакцию();
		Иначе
			ОтменитьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция ИзмененныеОбъектыПриЗаменеВОбъекте(ПараметрыВыполнения, МестоИспользования, ОбрабатываемыеСтроки)
	Данные = МестоИспользования.Данные;
	ОписаниеПоследовательностей = ОписаниеПоследовательностей(МестоИспользования.Метаданные);
	ОписаниеДвижений            = ОписаниеДвижений(МестоИспользования.Метаданные);
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Возвращаем измененные обработанные объекты.
	Измененные = Новый Соответствие;
	
	// Считываем
	Описание = ОписаниеОбъекта(Данные.Метаданные());
	Попытка
		Объект = Данные.ПолучитьОбъект();
	Исключение
		// Был уже обработан с ошибками.
		Объект = Неопределено;
	КонецПопытки;
	
	Если Объект = Неопределено Тогда
		Возврат Измененные;
	КонецЕсли;
	
	Для Каждого ОписаниеДвижения Из ОписаниеДвижений Цикл
		ОписаниеДвижения.НаборЗаписей.Отбор.Регистратор.Установить(Данные);
		ОписаниеДвижения.НаборЗаписей.Прочитать();
	КонецЦикла;
	
	Для Каждого ОписаниеПоследовательности Из ОписаниеПоследовательностей Цикл
		ОписаниеПоследовательности.НаборЗаписей.Отбор.Регистратор.Установить(Данные);
		ОписаниеПоследовательности.НаборЗаписей.Прочитать();
	КонецЦикла;
	
	// Заменяем сразу все варианты.
	ПарыЗамен = Новый Соответствие;
	Для Каждого МестоИспользования Из ОбрабатываемыеСтроки Цикл
		ПарыЗамен.Вставить(МестоИспользования.Ссылка, МестоИспользования.ЦелеваяСсылка);
	КонецЦикла;
	
	// Реквизиты
	Для Каждого КлючЗначение Из Описание.Реквизиты Цикл
		Имя = КлючЗначение.Ключ;
		ЦелеваяСсылка = ПарыЗамен[ Объект[Имя] ];
		Если ЦелеваяСсылка <> Неопределено Тогда
			ЗарегистрироватьФактЗамены(Объект, Объект[Имя], ЦелеваяСсылка, "Реквизиты", Имя);
			Объект[Имя] = ЦелеваяСсылка;
		КонецЕсли;
	КонецЦикла;
	
	// Стандартные реквизиты
	Для Каждого КлючЗначение Из Описание.СтандартныеРеквизиты Цикл
		Имя = КлючЗначение.Ключ;
		ЦелеваяСсылка = ПарыЗамен[ Объект[Имя] ];
		Если ЦелеваяСсылка <> Неопределено Тогда
			ЗарегистрироватьФактЗамены(Объект, Объект[Имя], ЦелеваяСсылка, "СтандартныеРеквизиты", Имя);
			Объект[Имя] = ЦелеваяСсылка;
		КонецЕсли;
	КонецЦикла;
		
	// Табличные части
	Для Каждого Элемент Из Описание.ТабличныеЧасти Цикл
		ЗаменитьВКоллекцииСтрок(
			"ТабличныеЧасти",
			Элемент.Имя,
			Объект,
			Объект[Элемент.Имя],
			Элемент.СписокПолей,
			ПарыЗамен);
	КонецЦикла;
	
	// Стандартные табличные части.
	Для Каждого Элемент Из Описание.СтандартныеТабличныеЧасти Цикл
		ЗаменитьВКоллекцииСтрок(
			"СтандартныеТабличныеЧасти",
			Элемент.Имя,
			Объект,
			Объект[Элемент.Имя],
			Элемент.СписокПолей,
			ПарыЗамен);
	КонецЦикла;
		
	// Движения
	Для Каждого ОписаниеДвижения Из ОписаниеДвижений Цикл
		ЗаменитьВКоллекцииСтрок(
			"Движения",
			ОписаниеДвижения.ПространствоБлокировки,
			ОписаниеДвижения.НаборЗаписей,
			ОписаниеДвижения.НаборЗаписей,
			ОписаниеДвижения.СписокПолей,
			ПарыЗамен);
	КонецЦикла;
	
	// Последовательности
	Для Каждого ОписаниеПоследовательности Из ОписаниеПоследовательностей Цикл
		ЗаменитьВКоллекцииСтрок(
			"Последовательности",
			ОписаниеПоследовательности.ПространствоБлокировки,
			ОписаниеПоследовательности.НаборЗаписей,
			ОписаниеПоследовательности.НаборЗаписей,
			ОписаниеПоследовательности.СписокПолей,
			ПарыЗамен);
	КонецЦикла;
	
	Для Каждого ОписаниеДвижения Из ОписаниеДвижений Цикл
		Если ОписаниеДвижения.НаборЗаписей.Модифицированность() Тогда
			Измененные.Вставить(ОписаниеДвижения.НаборЗаписей, Ложь);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ОписаниеПоследовательности Из ОписаниеПоследовательностей Цикл
		Если ОписаниеПоследовательности.НаборЗаписей.Модифицированность() Тогда
			Измененные.Вставить(ОписаниеПоследовательности.НаборЗаписей, Ложь);
		КонецЕсли;
	КонецЦикла;
	
	// Сам объект последний - для возможного перепроведения.
	Если Объект.Модифицированность() Тогда
		Измененные.Вставить(Объект, Описание.МожетБытьПроведен);
	КонецЕсли;
	
	Возврат Измененные;
КонецФункции

Процедура ЗарегистрироватьФактЗамены(Объект, СсылкаДубля, СсылкаОригинала, ВидРеквизита, ИмяРеквизита, Индекс = Неопределено, ИмяКолонки = Неопределено)
	Структура = Новый Структура("ДополнительныеСвойства");
	ЗаполнитьЗначенияСвойств(Структура, Объект);
	Если ТипЗнч(Структура.ДополнительныеСвойства) <> Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	ДопСвойства = Объект.ДополнительныеСвойства;
	ДопСвойства.Вставить("ЗаменаСсылок", Истина);
	ВыполненныеЗамены = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ДопСвойства, "ВыполненныеЗамены");
	Если ВыполненныеЗамены = Неопределено Тогда
		ВыполненныеЗамены = Новый Массив;
		ДопСвойства.Вставить("ВыполненныеЗамены", ВыполненныеЗамены);
	КонецЕсли;
	ОписаниеЗамены = Новый Структура;
	ОписаниеЗамены.Вставить("СсылкаДубля", СсылкаДубля);
	ОписаниеЗамены.Вставить("СсылкаОригинала", СсылкаОригинала);
	ОписаниеЗамены.Вставить("ВидРеквизита", ВидРеквизита);
	ОписаниеЗамены.Вставить("ИмяРеквизита", ИмяРеквизита);
	ОписаниеЗамены.Вставить("Индекс", Индекс);
	ОписаниеЗамены.Вставить("ИмяКолонки", ИмяКолонки);
	ВыполненныеЗамены.Добавить(ОписаниеЗамены);
КонецПроцедуры

Процедура УдалитьСсылкиПометкой(Результат, Знач СписокСсылок, Знач ПараметрыВыполнения, Знач ВнутренняяТранзакция = Истина)
	
	УдалитьСсылкиНемонопольно(Результат, СписокСсылок, ПараметрыВыполнения, ВнутренняяТранзакция, Ложь);
	
КонецПроцедуры

Процедура УдалитьСсылкиНепосредственно(Результат, Знач СписокСсылок, Знач ПараметрыВыполнения, Знач ВнутренняяТранзакция = Истина)
	
	УдалитьСсылкиНемонопольно(Результат, СписокСсылок, ПараметрыВыполнения, ВнутренняяТранзакция, Истина);
	
КонецПроцедуры

Процедура УдалитьСсылкиНемонопольно(Результат, Знач СписокСсылок, Знач ПараметрыВыполнения, Знач ВнутренняяТранзакция, Знач УдалятьНепосредственно)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Удаляемые = Новый Массив;
	
	ЛокальнаяТранзакция = Не ТранзакцияАктивна();
	Если ЛокальнаяТранзакция Тогда
		НачатьТранзакцию();
	КонецЕсли;
	
	Для Каждого Ссылка Из СписокСсылок Цикл
		Информация = ИнформацияОТипе(ТипЗнч(Ссылка), ПараметрыВыполнения);
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить(Информация.ПолноеИмя).УстановитьЗначение("Ссылка", Ссылка);
		ИнформацияОбОшибке = Неопределено;
		Попытка
			Блокировка.Заблокировать();
			Удаляемые.Добавить(Ссылка);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		Если ИнформацияОбОшибке <> Неопределено Тогда
			ЗарегистрироватьОшибкуВТаблицу(Результат, Ссылка, Неопределено, Ссылка, Информация, "БлокировкаДляУдаленияДубля", ИнформацияОбОшибке);
		КонецЕсли;
	КонецЦикла;
	
	ТаблицаПоиска = МестаИспользования(Удаляемые);
	Фильтр = Новый Структура("Ссылка");
	
	Для Каждого Ссылка Из Удаляемые Цикл
		ПредставлениеСсылки = ПредметСтрокой(Ссылка);
		
		Фильтр.Ссылка = Ссылка;
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(Фильтр);
		
		Индекс = МестаИспользования.ВГраница();
		Пока Индекс >= 0 Цикл
			Если МестаИспользования[Индекс].ВспомогательныеДанные Тогда
				МестаИспользования.Удалить(Индекс);
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
		
		Если МестаИспользования.Количество() > 0 Тогда
			// Остались места использования, нельзя удалять.
			ДобавитьРезультатыЗаменыИзмененныхОбъектов(Результат, МестаИспользования);
			Продолжить;
		КонецЕсли;
		
		Объект = Ссылка.ПолучитьОбъект();
		Если Объект = Неопределено Тогда
			// Уже удален
			Продолжить;
		КонецЕсли;
			
		Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
			УстановитьПривилегированныйРежим(Ложь);
		КонецЕсли;
			
		Попытка
			Если УдалятьНепосредственно Тогда
				ОбработатьОбъектСПерехватомСообщений(Объект, "НепосредственноеУдаление", Неопределено, ПараметрыВыполнения);
			Иначе
				ОбработатьОбъектСПерехватомСообщений(Объект, "ПометкаУдаления", Неопределено, ПараметрыВыполнения);
			КонецЕсли;
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ЗарегистрироватьОшибкуЗамены(Результат, Ссылка, 
				ОписаниеОшибкиЗамены("ОшибкаУдаления", Ссылка, ПредставлениеСсылки,
				НСтр("ru = 'Ошибка удаления'") + Символы.ПС + СокрЛП( КраткоеПредставлениеОшибки(ИнформацияОбОшибке))));
		КонецПопытки;
			
		Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
			УстановитьПривилегированныйРежим(Истина);
		КонецЕсли;
	КонецЦикла;
	
	Если ЛокальнаяТранзакция Тогда
		ЗафиксироватьТранзакцию();
	КонецЕсли;
КонецПроцедуры

Процедура ДобавитьРезультатыЗаменыИзмененныхОбъектов(Результат, ТаблицаПовторногоПоиска)
	
	ТипКлючЗаписи = ОписаниеТипаКлючиЗаписей();
	
	Фильтр = Новый Структура("ТипОшибки, Ссылка, ОбъектОшибки", "");
	Для Каждого Строка Из ТаблицаПовторногоПоиска Цикл
		Тест = Новый Структура("ВспомогательныеДанные", Ложь);
		ЗаполнитьЗначенияСвойств(Тест, Строка);
		Если Тест.ВспомогательныеДанные Тогда
			Продолжить;
		КонецЕсли;
		
		Данные = Строка.Данные;
		Ссылка = Строка.Ссылка;
		
		ПредставлениеДанных = Строка(Данные);
		
		Фильтр.ОбъектОшибки = Данные;
		Фильтр.Ссылка       = Ссылка;
		Если Результат.Ошибки.НайтиСтроки(Фильтр).Количество() > 0 Тогда
			Продолжить; // По данной проблеме уже записана ошибка.
		КонецЕсли;
		ЗарегистрироватьОшибкуЗамены(Результат, Ссылка, 
			ОписаниеОшибкиЗамены("ДанныеИзменены", Данные, ПредставлениеДанных,
			НСтр("ru = 'Заменены не все места использования. Возможно места использования были добавлены или изменены другим пользователем.'")));
	КонецЦикла;
	
КонецПроцедуры

Функция ОписаниеИзмеренийНабора(Знач Мета, Кэш)
	
	ОписаниеИзмерений = Кэш[Мета];
	Если ОписаниеИзмерений<>Неопределено Тогда
		Возврат ОписаниеИзмерений;
	КонецЕсли;
	
	// Период и регистратор, если есть.
	ОписаниеИзмерений = Новый Структура;
	
	ДанныеИзмерения = Новый Структура("Ведущее, Представление, Формат, Тип", Ложь);
	
	Если Метаданные.РегистрыСведений.Содержит(Мета) Тогда
		// Возможно есть период
		МетаПериод = Мета.ПериодичностьРегистраСведений; 
		Периодичность = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений;
		
		Если МетаПериод = Периодичность.ПозицияРегистратора Тогда
			ДанныеИзмерения.Тип           = Документы.ТипВсеСсылки();
			ДанныеИзмерения.Представление = НСтр("ru='Регистратор'");
			ДанныеИзмерения.Ведущее       = Истина;
			ОписаниеИзмерений.Вставить("Регистратор", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.Год Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = НСтр("ru='Период'");
			ДанныеИзмерения.Формат        = "Л=ru_RU; ДФ='yyyy ""г.""'; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.День Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = НСтр("ru='Период'");
			ДанныеИзмерения.Формат        = "Л=ru_RU; ДЛФ=D; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.Квартал Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = НСтр("ru='Период'");
			ДанныеИзмерения.Формат        =  "Л=ru_RU; ДФ='к ""квартал ""yyyy ""г.""'; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.Месяц Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = НСтр("ru='Период'");
			ДанныеИзмерения.Формат        = "Л=ru_RU; ДФ='ММММ yyyy ""г.""'; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.Секунда Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = НСтр("ru='Период'");
			ДанныеИзмерения.Формат        = "Л=ru_RU; ДЛФ=DT; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		КонецЕсли;
		
	Иначе
		ДанныеИзмерения.Тип           = Документы.ТипВсеСсылки();
		ДанныеИзмерения.Представление = НСтр("ru='Регистратор'");
		ДанныеИзмерения.Ведущее       = Истина;
		ОписаниеИзмерений.Вставить("Регистратор", ДанныеИзмерения);
		
	КонецЕсли;
	
	// Все измерения
	Для Каждого МетаИзмерение Из Мета.Измерения Цикл
		ДанныеИзмерения = Новый Структура("Ведущее, Представление, Формат, Тип");
		ДанныеИзмерения.Тип           = МетаИзмерение.Тип;
		ДанныеИзмерения.Представление = МетаИзмерение.Представление();
		ДанныеИзмерения.Ведущее       = МетаИзмерение.Ведущее;
		ОписаниеИзмерений.Вставить(МетаИзмерение.Имя, ДанныеИзмерения);
	КонецЦикла;
	
	Кэш[Мета] = ОписаниеИзмерений;
	Возврат ОписаниеИзмерений;
КонецФункции

Функция ОписаниеДвижений(Знач Мета)
	// можно закэшировать по Мета
	
	ОписаниеДвижений = Новый Массив;
	Если Не Метаданные.Документы.Содержит(Мета) Тогда
		Возврат ОписаниеДвижений;
	КонецЕсли;
	
	Для Каждого Движение Из Мета.Движения Цикл
		
		Если Метаданные.РегистрыНакопления.Содержит(Движение) Тогда
			НаборЗаписей = РегистрыНакопления[Движение.Имя].СоздатьНаборЗаписей();
			ИсключатьПоля = "Активность, НомерСтроки, Период, Регистратор"; 
			
		ИначеЕсли Метаданные.РегистрыСведений.Содержит(Движение) Тогда
			НаборЗаписей = РегистрыСведений[Движение.Имя].СоздатьНаборЗаписей();
			ИсключатьПоля = "Активность, ВидДвижения, НомерСтроки, Период, Регистратор"; 
			
		ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Движение) Тогда
			НаборЗаписей = РегистрыБухгалтерии[Движение.Имя].СоздатьНаборЗаписей();
			ИсключатьПоля = "Активность, ВидДвижения, НомерСтроки, Период, Регистратор"; 
			
		ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Движение) Тогда
			НаборЗаписей = РегистрыРасчета[Движение.Имя].СоздатьНаборЗаписей();
			ИсключатьПоля = "Активность, БазовыйПериодКонец, БазовыйПериодНачало, НомерСтроки, ПериодДействия,
			                |ПериодДействияКонец, ПериодДействияНачало, ПериодРегистрации, Регистратор, Сторно,
			                |ФактическийПериодДействия";
		Иначе
			// Неизвестный тип
			Продолжить;
		КонецЕсли;
		
		// Поля ссылочного типа и измерения - кандидаты.
		Описание = СпискиПолейПоТипу(НаборЗаписей, Движение.Измерения, ИсключатьПоля);
		Если Описание.СписокПолей.Количество() = 0 Тогда
			// Незачем обрабатывать
			Продолжить;
		КонецЕсли;
		
		Описание.Вставить("НаборЗаписей", НаборЗаписей);
		Описание.Вставить("ПространствоБлокировки", Движение.ПолноеИмя() );
		
		ОписаниеДвижений.Добавить(Описание);
	КонецЦикла;	// Метаданные движений
	
	Возврат ОписаниеДвижений;
КонецФункции

Функция ОписаниеПоследовательностей(Знач Мета)
	
	ОписаниеПоследовательностей = Новый Массив;
	Если Не Метаданные.Документы.Содержит(Мета) Тогда
		Возврат ОписаниеПоследовательностей;
	КонецЕсли;
	
	Для Каждого Последовательность Из Метаданные.Последовательности Цикл
		Если Не Последовательность.Документы.Содержит(Мета) Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяТаблицы = Последовательность.ПолноеИмя();
		
		// Список полей и измерений
		Описание = СпискиПолейПоТипу(ИмяТаблицы, Последовательность.Измерения, "Регистратор");
		Если Описание.СписокПолей.Количество() > 0 Тогда
			
			Описание.Вставить("НаборЗаписей",           Последовательности[Последовательность.Имя].СоздатьНаборЗаписей());
			Описание.Вставить("ПространствоБлокировки", ИмяТаблицы + ".Записи");
			Описание.Вставить("Измерения",              Новый Структура);
			
			ОписаниеПоследовательностей.Добавить(Описание);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ОписаниеПоследовательностей;
КонецФункции

Функция ОписаниеОбъекта(Знач Мета)
	// можно закэшировать по Мета
	
	ТипВсеСсылки = ОписаниеТипаВсеСсылки();
	
	Кандидаты = Новый Структура("Реквизиты, СтандартныеРеквизиты, ТабличныеЧасти, СтандартныеТабличныеЧасти");
	ЗаполнитьЗначенияСвойств(Кандидаты, Мета);
	
	ОписаниеОбъекта = Новый Структура;
	
	ОписаниеОбъекта.Вставить("Реквизиты", Новый Структура);
	Если Кандидаты.Реквизиты <> Неопределено Тогда
		Для Каждого МетаРеквизит Из Кандидаты.Реквизиты Цикл
			Если ОписанияТиповПересекаются(МетаРеквизит.Тип, ТипВсеСсылки) Тогда
				ОписаниеОбъекта.Реквизиты.Вставить(МетаРеквизит.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ОписаниеОбъекта.Вставить("СтандартныеРеквизиты", Новый Структура);
	Если Кандидаты.СтандартныеРеквизиты <> Неопределено Тогда
		Исключаемые = Новый Структура("Ссылка");
		
		Для Каждого МетаРеквизит Из Кандидаты.СтандартныеРеквизиты Цикл
			Имя = МетаРеквизит.Имя;
			Если Не Исключаемые.Свойство(Имя) И ОписанияТиповПересекаются(МетаРеквизит.Тип, ТипВсеСсылки) Тогда
				ОписаниеОбъекта.Реквизиты.Вставить(МетаРеквизит.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ОписаниеОбъекта.Вставить("ТабличныеЧасти", Новый Массив);
	Если Кандидаты.ТабличныеЧасти <> Неопределено Тогда
		Для Каждого МетаТаблица Из Кандидаты.ТабличныеЧасти Цикл
			
			СписокПолей = Новый Структура;
			Для Каждого МетаРеквизит Из МетаТаблица.Реквизиты Цикл
				Если ОписанияТиповПересекаются(МетаРеквизит.Тип, ТипВсеСсылки) Тогда
					СписокПолей.Вставить(МетаРеквизит.Имя);
				КонецЕсли;
			КонецЦикла;
			
			Если СписокПолей.Количество() > 0 Тогда
				ОписаниеОбъекта.ТабличныеЧасти.Добавить(Новый Структура("Имя, СписокПолей", МетаТаблица.Имя, СписокПолей));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ОписаниеОбъекта.Вставить("СтандартныеТабличныеЧасти", Новый Массив);
	Если Кандидаты.СтандартныеТабличныеЧасти <> Неопределено Тогда
		Для Каждого МетаТаблица Из Кандидаты.СтандартныеТабличныеЧасти Цикл
			
			СписокПолей = Новый Структура;
			Для Каждого МетаРеквизит Из МетаТаблица.СтандартныеРеквизиты Цикл
				Если ОписанияТиповПересекаются(МетаРеквизит.Тип, ТипВсеСсылки) Тогда
					СписокПолей.Вставить(МетаРеквизит.Имя);
				КонецЕсли;
			КонецЦикла;
			
			Если СписокПолей.Количество() > 0 Тогда
				ОписаниеОбъекта.СтандартныеТабличныеЧасти.Добавить(Новый Структура("Имя, СписокПолей", МетаТаблица.Имя, СписокПолей));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ОписаниеОбъекта.Вставить("МожетБытьПроведен", Метаданные.Документы.Содержит(Мета));
	Возврат ОписаниеОбъекта;
КонецФункции

Функция ОписаниеКлючаЗаписи(Знач Мета)
	// можно закэшировать по Мета
	
	ИмяТаблицы = Мета.ПолноеИмя();
	
	// Поля ссылочного типа - кандидаты и набор измерений.
	ОписаниеКлюча = СпискиПолейПоТипу(ИмяТаблицы, Мета.Измерения, "Период, Регистратор");
	
	Если Метаданные.РегистрыСведений.Содержит(Мета) Тогда
		НаборЗаписей = РегистрыСведений[Мета.Имя].СоздатьНаборЗаписей();
	
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(Мета) Тогда
		НаборЗаписей = РегистрыНакопления[Мета.Имя].СоздатьНаборЗаписей();
	
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Мета) Тогда
		НаборЗаписей = РегистрыБухгалтерии[Мета.Имя].СоздатьНаборЗаписей();
	
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Мета) Тогда
		НаборЗаписей = РегистрыРасчета[Мета.Имя].СоздатьНаборЗаписей();
	
	ИначеЕсли Метаданные.Последовательности.Содержит(Мета) Тогда
		НаборЗаписей = Последовательности[Мета.Имя].СоздатьНаборЗаписей();
	
	Иначе
		НаборЗаписей = Неопределено;
	
	КонецЕсли;
	
	ОписаниеКлюча.Вставить("НаборЗаписей", НаборЗаписей);
	ОписаниеКлюча.Вставить("ПространствоБлокировки", ИмяТаблицы);
	
	Возврат ОписаниеКлюча;
КонецФункции

Функция ОписанияТиповПересекаются(Знач Описание1, Знач Описание2)
	
	Для Каждого Тип Из Описание1.Типы() Цикл
		Если Описание2.СодержитТип(Тип) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
КонецФункции

// Возвращает описание по имени таблицы или по набору записей.
Функция СпискиПолейПоТипу(Знач ИсточникДанных, Знач МетаИзмерения, Знач ИсключатьПоля)
	// можно закэшировать
	
	Описание = Новый Структура;
	Описание.Вставить("СписокПолей",     Новый Структура);
	Описание.Вставить("СтруктураИзмерений", Новый Структура);
	Описание.Вставить("СписокВедущих",   Новый Структура);
	
	ТипКонтроля = ОписаниеТипаВсеСсылки();
	Исключаемые = Новый Структура(ИсключатьПоля);
	
	ТипИсточникаДанных = ТипЗнч(ИсточникДанных);
	
	Если ТипИсточникаДанных = Тип("Строка") Тогда
		// Источник - имя таблицы, получаем поля запросом.
		Запрос = Новый Запрос("ВЫБРАТЬ * ИЗ " + ИсточникДанных + " ГДЕ ЛОЖЬ");
		ИсточникПолей = Запрос.Выполнить();
	Иначе
		// Источник - набор записей
		ИсточникПолей = ИсточникДанных.ВыгрузитьКолонки();
	КонецЕсли;
	
	Для Каждого Колонка Из ИсточникПолей.Колонки Цикл
		Имя = Колонка.Имя;
		Если Не Исключаемые.Свойство(Имя) И ОписанияТиповПересекаются(Колонка.ТипЗначения, ТипКонтроля) Тогда
			Описание.СписокПолей.Вставить(Имя);
			
			// И проверка на ведущее измерение.
			Мета = МетаИзмерения.Найти(Имя);
			Если Мета <> Неопределено Тогда
				Описание.СтруктураИзмерений.Вставить(Имя, Мета.Тип);
				Тест = Новый Структура("Ведущее", Ложь);
				ЗаполнитьЗначенияСвойств(Тест, Мета);
				Если Тест.Ведущее Тогда
					Описание.СписокВедущих.Вставить(Имя, Мета.Тип);
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Описание;
КонецФункции

Процедура ЗаменитьВКоллекцииСтрок(ВидКоллекции, ИмяКоллекции, Объект, Коллекция, Знач СписокПолей, Знач ПарыЗамен)
	РабочаяКоллекция = Коллекция.Выгрузить();
	Модифицировано = Ложь;
	
	Для Каждого Строка Из РабочаяКоллекция Цикл
		
		Для Каждого КлючЗначение Из СписокПолей Цикл
			Имя = КлючЗначение.Ключ;
			ЦелеваяСсылка = ПарыЗамен[ Строка[Имя] ];
			Если ЦелеваяСсылка <> Неопределено Тогда
				ЗарегистрироватьФактЗамены(Объект, Строка[Имя], ЦелеваяСсылка, ВидКоллекции, ИмяКоллекции, РабочаяКоллекция.Индекс(Строка), Имя);
				Строка[Имя] = ЦелеваяСсылка;
				Модифицировано = Истина;
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	Если Модифицировано Тогда
		Коллекция.Загрузить(РабочаяКоллекция);
	КонецЕсли;
КонецПроцедуры

Процедура СообщитьОтложенныеСообщения(Знач Сообщения)
	
	Для Каждого Сообщение Из Сообщения Цикл
		Сообщение.Сообщить();
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбработатьОбъектСПерехватомСообщений(Знач Объект, Знач Действие, Знач РежимЗаписи, Знач ПараметрыЗаписи)
	
	// Текущие сообщения до исключения запоминаем.
	ПредыдущиеСообщения = ПолучитьСообщенияПользователю(Истина);
	СообщатьПовторно    = ТекущийРежимЗапуска() <> Неопределено;
	
	Попытка
		
		Объект.ОбменДанными.Загрузка = Не ПараметрыЗаписи.ВключатьБизнесЛогику;
		
		Если Действие = "Запись" Тогда
			Если РежимЗаписи = Неопределено Тогда
				Объект.Записать();
			Иначе
				Объект.Записать(РежимЗаписи);
			КонецЕсли;
			
		ИначеЕсли Действие = "ПометкаУдаления" Тогда
			Объект.УстановитьПометкуУдаления(Истина, Ложь);
			
		ИначеЕсли Действие = "НепосредственноеУдаление" Тогда
			Объект.Удалить();
			
		КонецЕсли;
		
	Исключение
		Информация = ИнформацияОбОшибке(); 
		
		// Перехватываем все сообщенное при ошибке и добавляем их в одно исключение.
		ТекстИсключения = "";
		Для Каждого Сообщение Из ПолучитьСообщенияПользователю(Ложь) Цикл
			ТекстИсключения = ТекстИсключения + Символы.ПС + Сообщение.Текст;
		КонецЦикла;
		
		// Сообщаем предыдущие
		Если СообщатьПовторно Тогда
			СообщитьОтложенныеСообщения(ПредыдущиеСообщения);
		КонецЕсли;
		
		ВызватьИсключение СокрЛП(КраткоеПредставлениеОшибки(Информация) + Символы.ПС + СокрЛП(ТекстИсключения));
	КонецПопытки;
	
	Если СообщатьПовторно Тогда
		СообщитьОтложенныеСообщения(ПредыдущиеСообщения);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаписатьОбъект(Знач Объект, Знач ПараметрыЗаписи)
	
	МетаданныеОбъекта = Объект.Метаданные();
	
	Если ЭтоДокумент(МетаданныеОбъекта) Тогда
		ОбработатьОбъектСПерехватомСообщений(Объект, "Запись", РежимЗаписиДокумента.Запись, ПараметрыЗаписи);
		Возврат;
	КонецЕсли;
	
	// Проверка на возможные циклические ссылки.
	ТестРеквизитов= Новый Структура("Иерархический, ВидыСубконто, Владельцы", Ложь, Неопределено, Новый Массив);
	ЗаполнитьЗначенияСвойств(ТестРеквизитов, МетаданныеОбъекта);
	
	// По родителю
	Если ТестРеквизитов.Иерархический Или ТестРеквизитов.ВидыСубконто <> Неопределено Тогда 
		
		Если Объект.Родитель = Объект.Ссылка Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'При записи ""%1"" возникает циклическая ссылка в иерархии.'"),
				Строка(Объект));
			КонецЕсли;
			
	КонецЕсли;
	
	// По владельцу
	Для Каждого МетаВладелец Из ТестРеквизитов.Владельцы Цикл
		
		Если Объект.Владелец = Объект.Ссылка Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'При записи ""%1"" возникает циклическая ссылка в подчинении.'"),
				Строка(Объект));
		КонецЕсли;
		Прервать;
		
	КонецЦикла;
	
	// Для последовательностей право "Изменение" может отсутствовать даже у роли "АдминистраторСистемы".
	Если ЭтоПоследовательность(МетаданныеОбъекта)
		И Не ПравоДоступа("Изменение", МетаданныеОбъекта)
		И ОбщегоНазначенияПовтИсп.РежимРаботыПрограммы().ЭтоАдминистраторПрограммы Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	// Просто запись
	ОбработатьОбъектСПерехватомСообщений(Объект, "Запись", Неопределено, ПараметрыЗаписи);
КонецПроцедуры

Функция СобытиеЖурналаРегистрацииЗаменыСсылок()
	Возврат НСтр("ru='Поиск и удаление ссылок'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка());
КонецФункции

Процедура ЗаменитьСсылкиКороткимиТранзакциями(Результат, Знач ПараметрыВыполнения, Знач Дубли, Знач ТаблицаПоиска)
	
	// Основной цикл обработки
	ФильтрСсылок = Новый Структура("Ссылка, КлючЗамены");
	Для Каждого Дубль Из Дубли Цикл
		БылиОшибки = Результат.ЕстьОшибки;
		Результат.ЕстьОшибки = Ложь;
		
		ФильтрСсылок.Ссылка = Дубль;
		
		ФильтрСсылок.КлючЗамены = "Константа";
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(ФильтрСсылок);
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			ПроизвестиЗаменуВКонстанте(Результат, МестоИспользования, ПараметрыВыполнения, Истина);
		КонецЦикла;
		
		ФильтрСсылок.КлючЗамены = "Объект";
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(ФильтрСсылок);
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			ПроизвестиЗаменуВОбъекте(Результат, МестоИспользования, ПараметрыВыполнения, Истина);
		КонецЦикла;
		
		ФильтрСсылок.КлючЗамены = "КлючЗаписи";
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(ФильтрСсылок);
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			ПроизвестиЗаменуВНаборе(Результат, МестоИспользования, ПараметрыВыполнения, Истина);
		КонецЦикла;
		
		ФильтрСсылок.КлючЗамены = "Последовательность";
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(ФильтрСсылок);
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			ПроизвестиЗаменуВНаборе(Результат, МестоИспользования, ПараметрыВыполнения, Истина);
		КонецЦикла;
		
		ФильтрСсылок.КлючЗамены = "РегистрСведений";
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(ФильтрСсылок);
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			ПроизвестиЗаменуВРегистреСведений(Результат, МестоИспользования, ПараметрыВыполнения, Истина);
		КонецЦикла;
		
		Если Не Результат.ЕстьОшибки Тогда
			ПараметрыВыполнения.УспешныеЗамены.Вставить(Дубль, ПараметрыВыполнения.ПарыЗамен[Дубль]);
		КонецЕсли;
		Результат.ЕстьОшибки = Результат.ЕстьОшибки Или БылиОшибки;
		
	КонецЦикла;
	
	// Окончательные действия
	Если ПараметрыВыполнения.УдалятьНепосредственно Тогда
		УдалитьСсылкиНепосредственно(Результат, Дубли, ПараметрыВыполнения, Истина);
		
	ИначеЕсли ПараметрыВыполнения.ПомечатьНаУдаление Тогда
		УдалитьСсылкиПометкой(Результат, Дубли, ПараметрыВыполнения);
		
	Иначе
		// Поиск новых
		ТаблицаПовторногоПоиска = МестаИспользования(Дубли);
		ДобавитьРезультатыЗаменыИзмененныхОбъектов(Результат, ТаблицаПовторногоПоиска);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаменитьСсылкуДлиннойТранзакцией(Результат, Знач Дубль, Знач ПараметрыВыполнения, Знач ТаблицаПоиска)
	УстановитьПривилегированныйРежим(Истина);
	
	СостояниеОперации = "";
	
	// 1. Блокирование всех мест использования.
	Блокировка = Новый БлокировкаДанных;
	
	МестаИспользования = ТаблицаПоиска.НайтиСтроки(Новый Структура("Ссылка", Дубль));
	ЗаблокироватьМестаИспользования(ПараметрыВыполнения, Блокировка, МестаИспользования);
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
	Исключение
		// Добавляем запись в результат о неудачной попытке блокировке.
		ПредставлениеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Ошибка = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не удалось заблокировать все места использования %1:'") + Символы.ПС + ПредставлениеОшибки, Дубль);
		ЗарегистрироватьОшибкуЗамены(Результат, Дубль, 
			ОписаниеОшибкиЗамены("ОшибкаБлокировки", Неопределено, Неопределено, Ошибка));
		СостояниеОперации = "ОшибкаБлокировки";
	КонецПопытки;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	БылиОшибки = Результат.ЕстьОшибки;
	
	// 2. Замена везде до первой ошибки.
	Если СостояниеОперации = "" Тогда
		Результат.ЕстьОшибки = Ложь;
		
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			
			Если МестоИспользования.КлючЗамены = "Константа" Тогда
				
				ПроизвестиЗаменуВКонстанте(Результат, МестоИспользования, ПараметрыВыполнения, Ложь);
				
			ИначеЕсли МестоИспользования.КлючЗамены = "Объект" Тогда
				
				ПроизвестиЗаменуВОбъекте(Результат, МестоИспользования, ПараметрыВыполнения, Ложь);
				
			ИначеЕсли МестоИспользования.КлючЗамены = "Последовательность" Тогда
				
				ПроизвестиЗаменуВНаборе(Результат, МестоИспользования, ПараметрыВыполнения, Ложь);
				
			ИначеЕсли МестоИспользования.КлючЗамены = "КлючЗаписи" Тогда
				
				ПроизвестиЗаменуВНаборе(Результат, МестоИспользования, ПараметрыВыполнения, Ложь);
				
			ИначеЕсли МестоИспользования.КлючЗамены = "РегистрСведений" Тогда
				
				ПроизвестиЗаменуВРегистреСведений(Результат, МестоИспользования, ПараметрыВыполнения, Ложь);
				
			КонецЕсли;
			
			Если Результат.ЕстьОшибки Тогда
				СостояниеОперации = "ОшибкаЗаписи";
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	// 3. Удаление 
	ПроизводимыеЗамены = Новый Массив;
	ПроизводимыеЗамены.Добавить(Дубль);
	
	Если СостояниеОперации = "" Тогда
		Результат.ЕстьОшибки = Ложь;
		
		Если ПараметрыВыполнения.УдалятьНепосредственно Тогда
			УдалитьСсылкиНепосредственно(Результат, ПроизводимыеЗамены, ПараметрыВыполнения, Ложь);
			
		ИначеЕсли ПараметрыВыполнения.ПомечатьНаУдаление Тогда
			УдалитьСсылкиПометкой(Результат, ПроизводимыеЗамены, ПараметрыВыполнения, Ложь);
			
		Иначе 
			// Поиск новых
			ТаблицаПовторногоПоиска = МестаИспользования(ПроизводимыеЗамены);
			ДобавитьРезультатыЗаменыИзмененныхОбъектов(Результат, ТаблицаПовторногоПоиска);
		КонецЕсли;
		
		Если Результат.ЕстьОшибки Тогда
			СостояниеОперации = "ДанныеИзменены";
		КонецЕсли;
	КонецЕсли;
	
	Результат.ЕстьОшибки = Результат.ЕстьОшибки Или БылиОшибки;
	
	Если СостояниеОперации = "" Тогда
		ЗафиксироватьТранзакцию();
		ПараметрыВыполнения.УспешныеЗамены.Вставить(Дубль, ПараметрыВыполнения.ПарыЗамен[Дубль]);
	Иначе
		ОтменитьТранзакцию();
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаблокироватьМестаИспользования(ПараметрыВыполнения, Блокировка, МестаИспользования)
	
	Для Каждого МестоИспользования Из МестаИспользования Цикл
		
		ЗаблокироватьМестоИспользования(ПараметрыВыполнения, Блокировка, МестоИспользования);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаблокироватьМестоИспользования(ПараметрыВыполнения, Блокировка, МестоИспользования)
	
	Если МестоИспользования.КлючЗамены = "Константа" Тогда
		
		Блокировка.Добавить(МестоИспользования.Метаданные.ПолноеИмя());
		
	ИначеЕсли МестоИспользования.КлючЗамены = "Объект" Тогда
		
		СсылкаОбъекта     = МестоИспользования.Данные;
		МетаданныеОбъекта = МестоИспользования.Метаданные;
		
		// Сам объект.
		Блокировка.Добавить(МетаданныеОбъекта.ПолноеИмя()).УстановитьЗначение("Ссылка", СсылкаОбъекта);
		
		// Движения по регистратору.
		ОписаниеДвижений = ОписаниеДвижений(МетаданныеОбъекта);
		Для Каждого Элемент Из ОписаниеДвижений Цикл
			Блокировка.Добавить(Элемент.ПространствоБлокировки + ".НаборЗаписей").УстановитьЗначение("Регистратор", СсылкаОбъекта);
		КонецЦикла;
		
		// Последовательности.
		ОписаниеПоследовательностей = ОписаниеПоследовательностей(МетаданныеОбъекта);
		Для Каждого Элемент Из ОписаниеПоследовательностей Цикл
			Блокировка.Добавить(Элемент.ПространствоБлокировки).УстановитьЗначение("Регистратор", СсылкаОбъекта);
		КонецЦикла;
		
	ИначеЕсли МестоИспользования.КлючЗамены = "Последовательность" Тогда
		
		СсылкаОбъекта     = МестоИспользования.Данные;
		МетаданныеОбъекта = МестоИспользования.Метаданные;
		
		ОписаниеПоследовательностей = ОписаниеПоследовательностей(МетаданныеОбъекта);
		Для Каждого Элемент Из ОписаниеПоследовательностей Цикл
			Блокировка.Добавить(Элемент.ПространствоБлокировки).УстановитьЗначение("Регистратор", СсылкаОбъекта);
		КонецЦикла;
		
	ИначеЕсли МестоИспользования.КлючЗамены = "КлючЗаписи"
		Или МестоИспользования.КлючЗамены = "РегистрСведений" Тогда
		
		Информация = ИнформацияОТипе(МестоИспользования.Метаданные, ПараметрыВыполнения);
		ТипДубля = МестоИспользования.ТипСсылки;
		ТипОригинала = ТипЗнч(МестоИспользования.ЦелеваяСсылка);
		
		Для Каждого КлючЗначение Из Информация.Измерения Цикл
			ТипИзмерения = КлючЗначение.Значение.Тип;
			Если ТипИзмерения.СодержитТип(ТипДубля) Тогда
				БлокировкаПоИзмерению = Блокировка.Добавить(Информация.ПолноеИмя);
				БлокировкаПоИзмерению.УстановитьЗначение(КлючЗначение.Ключ, МестоИспользования.Ссылка);
			КонецЕсли;
			Если ТипИзмерения.СодержитТип(ТипОригинала) Тогда
				БлокировкаПоИзмерению = Блокировка.Добавить(Информация.ПолноеИмя);
				БлокировкаПоИзмерению.УстановитьЗначение(КлючЗначение.Ключ, МестоИспользования.ЦелеваяСсылка);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗарегистрироватьОшибкуЗамены(Результат, Знач Ссылка, Знач ОписаниеОшибки)
	
	Результат.ЕстьОшибки = Истина;
	
	Строка = Результат.Ошибки.Добавить();
	Строка.Ссылка = Ссылка;
	Строка.ПредставлениеОбъектаОшибки = ОписаниеОшибки.ПредставлениеОбъектаОшибки;
	Строка.ОбъектОшибки               = ОписаниеОшибки.ОбъектОшибки;
	Строка.ТекстОшибки                = ОписаниеОшибки.ТекстОшибки;
	Строка.ТипОшибки                  = ОписаниеОшибки.ТипОшибки;
	
КонецПроцедуры

Функция ОписаниеОшибкиЗамены(Знач ТипОшибки, Знач ОбъектОшибки, Знач ПредставлениеОбъектаОшибки, Знач ТекстОшибки)
	Результат = Новый Структура;
	
	Результат.Вставить("ТипОшибки",                  ТипОшибки);
	Результат.Вставить("ОбъектОшибки",               ОбъектОшибки);
	Результат.Вставить("ПредставлениеОбъектаОшибки", ПредставлениеОбъектаОшибки);
	Результат.Вставить("ТекстОшибки",                ТекстОшибки);
	
	Возврат Результат;
КонецФункции

Процедура ЗарегистрироватьОшибкуВТаблицу(Результат, Дубль, Оригинал, Данные, Информация, ТипОшибки, ИнформацияОбОшибке)
	Результат.ЕстьОшибки = Истина;
	
	ЗаписьЖурналаРегистрации(
		СобытиеЖурналаРегистрацииЗаменыСсылок(),
		УровеньЖурналаРегистрации.Ошибка,
		,
		ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
	
	ПолноеПредставлениеДанных = Строка(Данные) + " (" + Информация.ПредставлениеЭлемента + ")";
	
	Ошибка = Результат.Ошибки.Добавить();
	Ошибка.Ссылка       = Дубль;
	Ошибка.ОбъектОшибки = Данные;
	Ошибка.ПредставлениеОбъектаОшибки = ПолноеПредставлениеДанных;
	
	Если ТипОшибки = "БлокировкаДляРегистра" Тогда
		НовыйШаблон = НСтр("ru = 'Не удалось начать редактирование %1: %2'");
		Ошибка.ТипОшибки = "ОшибкаБлокировки";
	ИначеЕсли ТипОшибки = "БлокировкаДляУдаленияДубля" Тогда
		НовыйШаблон = НСтр("ru = 'Не удалось начать удаление: %2'");
		Ошибка.ТипОшибки = "ОшибкаБлокировки";
	ИначеЕсли ТипОшибки = "УдалитьНаборДубля" Тогда
		НовыйШаблон = НСтр("ru = 'Не удалось очистить сведения о дубле в %1: %2'");
		Ошибка.ТипОшибки = "ОшибкаЗаписи";
	ИначеЕсли ТипОшибки = "ЗаписатьНаборОригинала" Тогда
		НовыйШаблон = НСтр("ru = 'Не удалось обновить сведения в %1: %2'");
		Ошибка.ТипОшибки = "ОшибкаЗаписи";
	Иначе
		НовыйШаблон = ТипОшибки + " (%1): %2";
		Ошибка.ТипОшибки = ТипОшибки;
	КонецЕсли;
	
	НовыйШаблон = НовыйШаблон + Символы.ПС + Символы.ПС + НСтр("ru = 'Подробности в журнале регистрации.'");
	
	КраткоеПредставление = СтандартныеПодсистемыКлиентСервер.ИсходнаяПричинаОшибки(ИнформацияОбОшибке);
	Ошибка.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НовыйШаблон, ПолноеПредставлениеДанных, КраткоеПредставление);
	
КонецПроцедуры

// Формирует информацию о типе объекта метаданных, как то: полное имя, представления, вид и т.п.
Функция ИнформацияОТипе(ПолноеИмяИлиМетаданныеИлиТип, Кэш)
	ТипПервогоПараметра = ТипЗнч(ПолноеИмяИлиМетаданныеИлиТип);
	Если ТипПервогоПараметра = Тип("Строка") Тогда
		ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмяИлиМетаданныеИлиТип);
	Иначе
		Если ТипПервогоПараметра = Тип("Тип") Тогда // Поиск объекта метаданных.
			ОбъектМетаданных = Метаданные.НайтиПоТипу(ПолноеИмяИлиМетаданныеИлиТип);
		Иначе
			ОбъектМетаданных = ПолноеИмяИлиМетаданныеИлиТип;
		КонецЕсли;
	КонецЕсли;
	ПолноеИмя = ВРег(ОбъектМетаданных.ПолноеИмя());
	
	ИнформацияОТипах = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Кэш, "ИнформацияОТипах");
	Если ИнформацияОТипах = Неопределено Тогда
		ИнформацияОТипах = Новый Соответствие;
		Кэш.Вставить("ИнформацияОТипах", ИнформацияОТипах);
	Иначе
		Информация = ИнформацияОТипах.Получить(ПолноеИмя);
		Если Информация <> Неопределено Тогда
			Возврат Информация;
		КонецЕсли;
	КонецЕсли;
	
	Информация = Новый Структура("ПолноеИмя, ПредставлениеЭлемента, ПредставлениеСписка,
	|Вид, Ссылочный, Технический, Разделенный,
	|Иерархический,
	|ЕстьПодчиненные, ИменаПодчиненных,
	|Измерения, Реквизиты, Ресурсы");
	ИнформацияОТипах.Вставить(ПолноеИмя, Информация);
	
	// Заполнение базовой информации.
	Информация.ПолноеИмя = ПолноеИмя;
	
	// Представления: элемента и списка.
	СтандартныеСвойства = Новый Структура("ПредставлениеОбъекта, РасширенноеПредставлениеОбъекта, ПредставлениеСписка, РасширенноеПредставлениеСписка");
	ЗаполнитьЗначенияСвойств(СтандартныеСвойства, ОбъектМетаданных);
	Если ЗначениеЗаполнено(СтандартныеСвойства.ПредставлениеОбъекта) Тогда
		Информация.ПредставлениеЭлемента = СтандартныеСвойства.ПредставлениеОбъекта;
	ИначеЕсли ЗначениеЗаполнено(СтандартныеСвойства.РасширенноеПредставлениеОбъекта) Тогда
		Информация.ПредставлениеЭлемента = СтандартныеСвойства.РасширенноеПредставлениеОбъекта;
	Иначе
		Информация.ПредставлениеЭлемента = ОбъектМетаданных.Представление();
	КонецЕсли;
	Если ЗначениеЗаполнено(СтандартныеСвойства.ПредставлениеСписка) Тогда
		Информация.ПредставлениеСписка = СтандартныеСвойства.ПредставлениеСписка;
	ИначеЕсли ЗначениеЗаполнено(СтандартныеСвойства.РасширенноеПредставлениеСписка) Тогда
		Информация.ПредставлениеСписка = СтандартныеСвойства.РасширенноеПредставлениеСписка;
	Иначе
		Информация.ПредставлениеСписка = ОбъектМетаданных.Представление();
	КонецЕсли;
	
	// Вид и его свойства.
	Информация.Вид = Лев(Информация.ПолноеИмя, СтрНайти(Информация.ПолноеИмя, ".")-1);
	Если Информация.Вид = "СПРАВОЧНИК"
		Или Информация.Вид = "ДОКУМЕНТ"
		Или Информация.Вид = "ПЕРЕЧИСЛЕНИЕ"
		Или Информация.Вид = "ПЛАНВИДОВХАРАКТЕРИСТИК"
		Или Информация.Вид = "ПЛАНСЧЕТОВ"
		Или Информация.Вид = "ПЛАНВИДОВРАСЧЕТА"
		Или Информация.Вид = "БИЗНЕСПРОЦЕСС"
		Или Информация.Вид = "ЗАДАЧА"
		Или Информация.Вид = "ПЛАНОБМЕНА" Тогда
		Информация.Ссылочный = Истина;
	Иначе
		Информация.Ссылочный = Ложь;
	КонецЕсли;
	
	Если Информация.Вид = "СПРАВОЧНИК"
		Или Информация.Вид = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Информация.Иерархический = ОбъектМетаданных.Иерархический;
	ИначеЕсли Информация.Вид = "ПЛАНСЧЕТОВ" Тогда
		Информация.Иерархический = Истина;
	Иначе
		Информация.Иерархический = Ложь;
	КонецЕсли;
	
	Информация.ЕстьПодчиненные = Ложь;
	Если Информация.Вид = "СПРАВОЧНИК"
		Или Информация.Вид = "ПЛАНВИДОВХАРАКТЕРИСТИК"
		Или Информация.Вид = "ПЛАНОБМЕНА"
		Или Информация.Вид = "ПЛАНСЧЕТОВ"
		Или Информация.Вид = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Для Каждого Справочник Из Метаданные.Справочники Цикл
			Если Справочник.Владельцы.Содержит(ОбъектМетаданных) Тогда
				Если Информация.ЕстьПодчиненные = Ложь Тогда
					Информация.ЕстьПодчиненные = Истина;
					Информация.ИменаПодчиненных = Новый Массив;
				КонецЕсли;
				Информация.ИменаПодчиненных.Добавить(Справочник.ПолноеИмя());
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если Информация.ПолноеИмя = "СПРАВОЧНИК.ИДЕНТИФИКАТОРЫОБЪЕКТОВМЕТАДАННЫХ"
		Или Информация.ПолноеИмя = "СПРАВОЧНИК.ПРЕДОПРЕДЕЛЕННЫЕВАРИАНТЫОТЧЕТОВ" Тогда
		Информация.Технический = Истина;
		Информация.Разделенный = Ложь;
	Иначе
		Информация.Технический = Ложь;
		Если Не Кэш.Свойство("МодельСервиса") Тогда
			Кэш.Вставить("МодельСервиса", ОбщегоНазначенияПовтИсп.РазделениеВключено());
			Если Кэш.МодельСервиса Тогда
				Кэш.Вставить("ВОбластиДанных", ИспользованиеРазделителяСеанса());
				Кэш.Вставить("РазделительОсновныхДанных",        ОбщегоНазначенияПовтИсп.РазделительОсновныхДанных());
				Кэш.Вставить("РазделительВспомогательныхДанных", ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных());
			КонецЕсли;
		КонецЕсли;
		Если Кэш.МодельСервиса Тогда
			Информация.Разделенный = ЭтоРазделенныйОбъектМетаданных(ОбъектМетаданных, Кэш.РазделительОсновныхДанных)
				Или ЭтоРазделенныйОбъектМетаданных(ОбъектМетаданных, Кэш.РазделительВспомогательныхДанных);
		КонецЕсли;
	КонецЕсли;
	
	Информация.Измерения = Новый Структура;
	Информация.Реквизиты = Новый Структура;
	Информация.Ресурсы = Новый Структура;
	
	ВидыРеквизитов = Новый Структура("СтандартныеРеквизиты, Реквизиты, Измерения, Ресурсы");
	ЗаполнитьЗначенияСвойств(ВидыРеквизитов, ОбъектМетаданных);
	Для Каждого КлючИЗначение Из ВидыРеквизитов Цикл
		Коллекция = КлючИЗначение.Значение;
		Если ТипЗнч(Коллекция) = Тип("КоллекцияОбъектовМетаданных") Тогда
			КудаПишем = ?(Информация.Свойство(КлючИЗначение.Ключ), Информация[КлючИЗначение.Ключ], Информация.Реквизиты);
			Для Каждого Реквизит Из Коллекция Цикл
				КудаПишем.Вставить(Реквизит.Имя, ИнформацияПоРеквизиту(Реквизит));
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	Если Информация.Вид = "РЕГИСТРСВЕДЕНИЙ"
		И ОбъектМетаданных.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		ИнформацияПоРеквизиту = Новый Структура("Ведущее, Представление, Формат, Тип, ЗначениеПоУмолчанию, ЗаполнятьИзДанныхЗаполнения");
		ИнформацияПоРеквизиту.Ведущее = Ложь;
		ИнформацияПоРеквизиту.ЗаполнятьИзДанныхЗаполнения = Ложь;
		Если ОбъектМетаданных.ПериодичностьРегистраСведений = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.ПозицияРегистратора Тогда
			ИнформацияПоРеквизиту.Тип = Новый ОписаниеТипов("МоментВремени");
		ИначеЕсли ОбъектМетаданных.ПериодичностьРегистраСведений = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Секунда Тогда
			ИнформацияПоРеквизиту.Тип = Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя));
		Иначе
			ИнформацияПоРеквизиту.Тип = Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты.Дата));
		КонецЕсли;
		Информация.Измерения.Вставить("Период", ИнформацияПоРеквизиту);
	КонецЕсли;
	
	Возврат Информация;
КонецФункции

Функция ИнформацияПоРеквизиту(МетаданныеРеквизита)
	// ОписаниеСтандартногоРеквизита
	// ОбъектМетаданных: Измерение
	// ОбъектМетаданных: Ресурс
	// ОбъектМетаданных: Реквизит
	Информация = Новый Структура("Ведущее, Представление, Формат, Тип, ЗначениеПоУмолчанию, ЗаполнятьИзДанныхЗаполнения");
	ЗаполнитьЗначенияСвойств(Информация, МетаданныеРеквизита);
	Информация.Представление = МетаданныеРеквизита.Представление();
	Если Информация.ЗаполнятьИзДанныхЗаполнения = Истина Тогда
		Информация.ЗначениеПоУмолчанию = МетаданныеРеквизита.ЗначениеЗаполнения;
	Иначе
		Информация.ЗначениеПоУмолчанию = МетаданныеРеквизита.Тип.ПривестиЗначение();
	КонецЕсли;
	Возврат Информация;
КонецФункции

Функция ВычислитьЗначениеДанныхПоПути(Знач Данные, Знач ПутьДанных)
	Результат = Данные;
	
	Имена = СтрРазделить(ПутьДанных, ".", Ложь);
	Для Каждого ИмяРеквизита Из Имена Цикл
		Тест = Новый Структура(ИмяРеквизита, Неопределено);
		ЗаполнитьЗначенияСвойств(Тест, Результат);
		Если Тест[ИмяРеквизита] = Неопределено Тогда
			Тест[ИмяРеквизита] = -1;
			ЗаполнитьЗначенияСвойств(Тест, Результат);
			Если Тест[ИмяРеквизита] = Неопределено Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Ошибка вычисления %1 для объекта %2. Реквизит %3 не найден'"),
					ПутьДанных, Данные, ИмяРеквизита);
			КонецЕсли;
		КонецЕсли;
		
		Результат = Тест[ИмяРеквизита];
		Если Результат = Неопределено Тогда // Не можем дальше читать.
			Возврат Неопределено;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

#КонецОбласти
