#Область ПрограммныйИнтерфейс

// #240 Пиганов Г.В. 2020-09-08
// Возвращает настройки бота
//
// Возвращаемое значение:
//  Структура - структура с параметрами
//  * ТокенБота - Строка - токен телеграмм-бота
//  * ТекущийПрокси - Число,Неопределено - текущий индекс прокси. Заполняется в ЗаполнитьНастройкиПрокси
//
Функция НастройкиБота() Экспорт
	
	// {{ SLD - #261 - 2020-11-05 - ADD
	УстановитьПривилегированныйРежим(Истина);
	// }} SLD - #261 - 2020-11-05 - ADD
	НастройкиБота = Новый Структура;
	НастройкиБота.Вставить("ТокенБота", Константы.узТелеграмм_ТокенБота.Получить());
	НастройкиБота.Вставить("ТекущийПрокси", Неопределено);
	
	Возврат НастройкиБота;
	
КонецФункции

// #240 Пиганов Г.В. 2020-09-08
// Добавляет в настройки бота данные прокси
//
// Параметры:
//  НастройкиБота - Структура - структура настроек для заполнения
//
// Возвращаемое значение:
//  НастройкиБота - Структура - входящие настройки бота
//  * ТекущийПрокси - Число - Индекс текущего прокси. Равен 0 и изменяется при выполнении запросов
//  * Прокси - Массив структур - Массив доступных прокси. Задаются в регистре сведений узПроксиСерверы
//  ** Адрес - Строка - адрес прокси
//  ** Порт - Число - порт прокси
//  ** Логин - Строка - логин прокси
//  ** Пароль - Строка - пароль прокси
//
Процедура ЗаполнитьНастройкиПрокси(НастройкиБота) Экспорт
	
	Прокси = РегистрыСведений.узПроксиСерверы.ПолучитьМассивНастроекПроксиСерверов();
	Если Прокси.Количество() > 0 Тогда
		НастройкиБота.Вставить("Прокси", Прокси);
		НастройкиБота.ТекущийПрокси = 0;
	КонецЕсли;
	
КонецПроцедуры

// #240 Пиганов Г.В. 2020-09-08
// Возвращает новые сообщения относительно переданного ИД
//
// Параметры:
//  MaxMessageID - Необязательное. Идентификатор последнего полученного сообщения (не номер в чате).
//                 Сообщения получаются после этого номера. Если не указано, то значение
//                 получается из элемента-константы ТелеграмMaxMessangeID.
//  Ответ - HTTPОтвет - если указана переменная, то в нее помещается ответ, полученный при запросе
//  НеПолучатьПовторно - Булево - Если Истина, то последний идентификатор сообщения
//                                будет сохранен в элемент-константу ТелеграмMaxMessangeID
//
// Возвращаемое значение: 
//  Массив структур - Данные полученных сообщений:
//  * Номер - Строка - Номер сообщения в чате
//  * ДатаУниверсальная - Дата и время - дата сообщения (UTC+0:00)
//  * Дата - Дата и время - дата сообщения приведенная к текущему часовому поясу сеанса
//  * ПользовательПредставление - Строка - представление пользователя в телеграмм
//  * ПользовательИД - Строка - идентификатор пользователя телеграмм
//  * ПользовательИмя - Строка - имя пользователя в телеграмм. Может быть пустым
//  * Текст - Строка - Текст сообщения
//  * Пользователь - СправочникСсылка.Пользователи - ссылка на пользователя, найденная по данным ПользовательИД
//  * Файлы - Массив структур - Массив файлов сообщения:
//  ** Имя - Строка - имя файла с расширением. Для фото не задано
//  ** ИД - Строка - идентификатор файла. Используется для получения файла
//  ** Размер - Число - размер файла
//  ** Ширина - Число - ширина изображения. Задано только для фото
//  ** Высота - Число - высота изображения. Задано только для фото
//
Функция ПолучитьНовыеСообщения(MaxMessageID = "", Ответ = Неопределено, НеПолучатьПовторно = Истина) Экспорт
	
	ПолученныеСообщения = Новый Массив;
	
	НастройкиБота = НастройкиБота();
	Если ПустаяСтрока(НастройкиБота.ТокенБота) Тогда
		Возврат ПолученныеСообщения;
	КонецЕсли;
	ЗаполнитьНастройкиПрокси(НастройкиБота);
	
	Если ПустаяСтрока(MaxMessageID) Тогда
		ИДПоследнегоПринятогоСообщения = Справочники.узКонстанты.ПолучитьЗначениеКонстанты("ТелеграмMaxMessangeID", Тип("Строка"), , Ложь);
	Иначе
		ИДПоследнегоПринятогоСообщения = MaxMessageID;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ИДПоследнегоПринятогоСообщения) Тогда
		ИДПоследнегоПринятогоСообщения = "";
	КонецЕсли;
	
	ПараметрыЗапроса = Новый Соответствие;
	Если НЕ ПустаяСтрока(ИДПоследнегоПринятогоСообщения) Тогда
		ПараметрыЗапроса.Вставить("offset", ИДПоследнегоПринятогоСообщения);
	КонецЕсли;
	
	Если НЕ ВыполнитьЗапросHTTP(НастройкиБота, "getUpdates", ПараметрыЗапроса, Ответ) Тогда
		ЗаписьЖурналаРегистрации("Телеграм.ПолучениеСообщений", УровеньЖурналаРегистрации.Ошибка,,,
			"Не смогли получить сообщения телеграм");
		Возврат ПолученныеСообщения;
	КонецЕсли;
	
	ОтветСтрокаJSON = Ответ.ПолучитьТелоКакСтроку();
	ОтветСоответствие = СоответствиеИзСтрокиJSON(ОтветСтрокаJSON);
	Если ОтветСоответствие["ok"] <> Истина Тогда
		Возврат ПолученныеСообщения;
	КонецЕсли;
	
	ИндексыКУдалению = Новый СписокЗначений;
	ИндексыСообщений = Новый Соответствие;
	ИндексСообщения = 0;
	
	КэшПользователей = ВсеПользователиТелеграмм();
	ОтборПользователя = Новый Структура("ПользовательИД");
	
	Для Каждого Update Из ОтветСоответствие["result"] Цикл
		
		ИДСообщения = Формат(Update["update_id"] + 1, "ЧГ=");
		Если ИДПоследнегоПринятогоСообщения < ИДСообщения Тогда
			ИДПоследнегоПринятогоСообщения = ИДСообщения;
		КонецЕсли;
		
		ДанныеСообщения = Новый Структура;
		ДанныеСообщения.Вставить("Обработано", Ложь);
		ДанныеСообщения.Вставить("ИД", ИДСообщения);
		
		Message = Update["message"];
		Если Message = Неопределено Тогда
			EditedMessage = Update["edited_message"];
			Если EditedMessage <> Неопределено Тогда
				// Получено отредактированное сообщение
				Message = EditedMessage;
				ИндексИсходногоСообщения = ИндексыСообщений[Message["message_id"]];
				Если ИндексИсходногоСообщения = Неопределено Тогда
					// Исходное сообщение было в предыдущем запросе и уже обработано.
					// При текущей реализации такие отредактированные сообщения не обрабатываем
					Продолжить;
				КонецЕсли;
				// Отредактированные сообщения должны быть удалены после обработки
				ИндексыКУдалению.Добавить(ИндексИсходногоСообщения);
			КонецЕсли;
		КонецЕсли;
		
		Если Message <> Неопределено Тогда
			msgChat = Message["chat"]; // данные чата пользователя
			//msgFrom = Message["from"]; // данные пользователя сообщения
			
			ДанныеСообщения.Вставить("Номер", Message["message_id"]);
			
			ДанныеСообщения.Вставить("ДатаУниверсальная", '19700101' + Message["date"]);
			// Преобразование универсальной даты в местное время сеанса
			ДанныеСообщения.Вставить("Дата", МестноеВремя(ДанныеСообщения.ДатаУниверсальная));
			
			ДанныеСообщения.Вставить("ПользовательПредставление", msgChat["last_name"] + " " + msgChat["first_name"]);
			ДанныеСообщения.Вставить("ПользовательИД", msgChat["id"]);
			ДанныеСообщения.Вставить("ПользовательИмя", msgChat["username"]);
			
			ДанныеСообщения.Вставить("Текст", Строка(Message["text"]));
			
			// Добавление артинок и файлов
			ПрикрепленныеФайлы = Новый Массив;
			
			msgPhoto = Message["photo"]; // прикрепленные фото
			Если ТипЗнч(msgPhoto) = Тип("Массив") Тогда
				// Если в массиве 3 картинки, то это "превью маленькое" 320*190, "настоящая картинка", "превью большое" 800*475
				Если msgPhoto.Количество() = 3 Тогда
					msgPhoto = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(msgPhoto[1]);
				КонецЕсли;
				Для Каждого msgPhotoSize Из msgPhoto Цикл
					ДанныеФайла = Новый Структура;
					ДанныеФайла.Вставить("Имя", "");
					ДанныеФайла.Вставить("ИД", msgPhotoSize["file_id"]);
					ДанныеФайла.Вставить("Ширина", msgPhotoSize["width"]);
					ДанныеФайла.Вставить("Высота", msgPhotoSize["height"]);
					ДанныеФайла.Вставить("Размер", msgPhotoSize["file_size"]);
					ПрикрепленныеФайлы.Добавить(ДанныеФайла);
				КонецЦикла;
			КонецЕсли;
			
			msgDocument = Message["document"]; // прикрепленные документы и картинки как файлы
			Если ТипЗнч(msgDocument) = Тип("Соответствие") Тогда
				ДанныеФайла = Новый Структура;
				ДанныеФайла.Вставить("Имя", msgDocument["file_name"]);
				ДанныеФайла.Вставить("ИД", msgDocument["file_id"]);
				ДанныеФайла.Вставить("Размер", msgDocument["file_size"]);
				ПрикрепленныеФайлы.Добавить(ДанныеФайла);
			КонецЕсли;
			
			Если ПрикрепленныеФайлы.Количество() > 0 Тогда
				// Для файлов передается заголовок, а не текст
				ДанныеСообщения.Текст = Строка(Message["caption"]);
			КонецЕсли;
			ДанныеСообщения.Вставить("Файлы", ПрикрепленныеФайлы);
			
			// Поиск пользователя по ИД пользователя телеграмм
			ПользовательСсылка = Неопределено;
			ОтборПользователя.ПользовательИД = ДанныеСообщения.ПользовательИД;
			НайденныеСтроки = КэшПользователей.НайтиСтроки(ОтборПользователя);
			Если НайденныеСтроки.Количество() > 0 Тогда
				ПользовательСсылка = НайденныеСтроки[0].Ссылка;
			КонецЕсли;
			ДанныеСообщения.Вставить("Пользователь", ПользовательСсылка);
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(ДанныеСообщения.Текст) ИЛИ ДанныеСообщения.Файлы.Количество() > 0 Тогда
			ПолученныеСообщения.Добавить(ДанныеСообщения);
			
			ИндексыСообщений[ДанныеСообщения.Номер] = ИндексСообщения;
			ИндексСообщения = ИндексСообщения + 1;
		КонецЕсли;
	КонецЦикла;
	
	// Удаление исходных отредактированных сообщений
	ИндексыКУдалению.СортироватьПоЗначению(НаправлениеСортировки.Убыв);
	Для Каждого ЭлементСписка Из ИндексыКУдалению Цикл
		ПолученныеСообщения.Удалить(ЭлементСписка.Значение);
	КонецЦикла;
	
	Если НеПолучатьПовторно Тогда
		Справочники.узКонстанты.УстановитьЗначениеКонстанты("ТелеграмMaxMessangeID", ИДПоследнегоПринятогоСообщения);
	КонецЕсли;
	
	Возврат ПолученныеСообщения;
	
КонецФункции

// #240 Пиганов Г.В. 2020-09-08
// Скачивает и помещает во временное хранилище файл с указанным ИД
// Параметры:
//  ИД - Строка - идентификатор файла телеграмм. Передается с сообщением.
//  НастройкиБота - Структура - структура с настройками бота. Если передана
//                  не переменная, то в нее будут помещены настройки.
//
// Возвращаемое значение:
//  Строка - адрес во временном хранилище с двоичными данными файла
//
Функция ПолучитьФайл(ФайлИД, НастройкиБота = Неопределено) Экспорт
	
	Если НастройкиБота = Неопределено Тогда
		НастройкиБота = НастройкиБота();
	КонецЕсли;
	
	ПараметрыЗапроса = Новый Соответствие;
	ПараметрыЗапроса.Вставить("file_id", ФайлИД);
	
	Ответ = Неопределено;
	
	Если НЕ ВыполнитьЗапросHTTP(НастройкиБота, "getFile", ПараметрыЗапроса, Ответ) Тогда
		ЗаписьЖурналаРегистрации("Телеграм.ПолучениеСообщений", УровеньЖурналаРегистрации.Ошибка,,
			, "Не смогли получить файл телеграм");
		Возврат Неопределено;
	КонецЕсли;
	
	ОтветСоответствие = СоответствиеИзСтрокиJSON(Ответ.ПолучитьТелоКакСтроку());
	
	msgFile = ОтветСоответствие["result"];
	
	ФайлURL = "https://api.telegram.org/file/bot" + НастройкиБота.ТокенБота + "/" + msgFile["file_path"];
	
	ПараметрыПолучения = ПолучениеФайловИзИнтернетаКлиентСервер.ПараметрыПолученияФайла();
	ПараметрыПолучения.ЗащищенноеСоединение = Истина;
	ДанныеФайла = ПолучениеФайловИзИнтернета.СкачатьФайлВоВременноеХранилище(ФайлURL, ПараметрыПолучения, Истина);
	
	АдресФайла = ?(ДанныеФайла.Статус, ДанныеФайла.Путь, Неопределено);
	
	Возврат АдресФайла;
	
КонецФункции

// #240 Пиганов Г.В. 2020-09-08
// Отправляет текстовое сообщение переданным пользователям
//
// Параметры:
//  ТекстСообщения - Строка - Текст сообщения в формате markdown
//  Получатели - Массив, СправочникСсылка.Пользователь - массив пользователей для получения сообщения.
//               Сообщение отправляется только пользователям с заполненным ИД телеграмма
//               и с установленным флагом "Использовать рассылку через телеграмм"
//  Ответ - Структура или Соответствие - доп. параметры, которые должны быть переданы в параметры запроса
//
Процедура ОтправитьСообщение(ТекстСообщения, Получатели, УведомлятьПользователя = Ложь, Ответ = Неопределено) Экспорт
	
	Ответ = Неопределено;
	
	НастройкиБота = НастройкиБота();
	Если ПустаяСтрока(НастройкиБота.ТокенБота) Тогда
		Если УведомлятьПользователя Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
				"Сообщение не отправлено, т.к. не задан токен телеграмм-бота");
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Выборка = ВыборкаПользователейТелеграмДляОтправки(Получатели);
	Если Выборка.Количество() = 0 Тогда
		Если УведомлятьПользователя Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
				"Сообщение не отправлено, т.к. не заданы получатели или у получателей не включена рассылка через телеграмм");
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	ИспользоватьПрокси = Справочники.узКонстанты.ПолучитьЗначениеКонстанты(
		"ТелеграммИспользоватьПроксиДляОтправки", Тип("Булево"), Ложь, Истина, Истина);
	Если ИспользоватьПрокси Тогда
		ЗаполнитьНастройкиПрокси(НастройкиБота);
	КонецЕсли;
	
	ПараметрыЗапроса = Новый Соответствие;
	ПараметрыЗапроса.Вставить("parse_mode", "Markdown");
	ПараметрыЗапроса.Вставить("disable_web_page_preview", "true");
	ПараметрыЗапроса.Вставить("text", ТекстСообщения);
	
	Пока Выборка.Следующий() Цикл
		ПараметрыЗапроса.Вставить("chat_id", Формат(Выборка.ПользовательИД, "ЧГ="));
		ОтветУспешен = ВыполнитьЗапросHTTP(НастройкиБота, "sendMessage", ПараметрыЗапроса, Ответ);
		Если НЕ ОтветУспешен Тогда
			ЗаписьЖурналаРегистрации("Телеграмм.Отправка", УровеньЖурналаРегистрации.Ошибка,,
				, "Не смогли отправить пользователю <" + Выборка.ПользовательИД + ":" + Выборка.Пользователь + ">");
		КонецЕсли;
		Если УведомлятьПользователя Тогда
			Если ОтветУспешен Тогда
				ТекстСообщения = "Сообщение удачно отправлено" ;
			Иначе
				ТекстСообщения = "Не смогли отправить сообщение телеграм пользователю [" + Выборка.ПользовательИД + "]. Подробнее смотрите в журнале регистрации."
			КонецЕсли;
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// #240 Пиганов Г.В. 2020-09-08
// Заменяет в переданной строки символы для корректного отражения в строке URL
// Может быть использована при выполнении GET-запросов
//
Функция ЗаменитьЗарезервированныеСимволыURL(ОбрабатываемаяСтрока) Экспорт
	Если ПустаяСтрока(ОбрабатываемаяСтрока) Тогда
		Возврат ОбрабатываемаяСтрока;
	КонецЕсли;
	
	пТелеграммИспользоватьЗаменуСимволовВДругуюКодировку = Справочники.узКонстанты.ПолучитьЗначениеКонстанты(
		"ТелеграммИспользоватьЗаменуСимволовВДругуюКодировку",Тип("Булево"),,Истина,Истина);
	
	Если пТелеграммИспользоватьЗаменуСимволовВДругуюКодировку Тогда
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(37),"%25"); // "%"
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(33),"%21"); // "!"
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(34),"%22"); // """  (кавычка)
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(35),"%23"); // "#" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(36),"%24"); // "$"	
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(38),"%26"); // "&" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(39),"%27"); // "'" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(42),"%2A"); // "*" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(44),"%2C"); // "," 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(58),"%3A"); // ":" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(59),"%3B"); // ";" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(60),"%3C"); // "<" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(61),"%3D"); // "=" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(62),"%3E"); // ">" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(63),"%3F"); // "?" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(91),"%5B"); // "[" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(93),"%5D"); // "]" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(94),"%5E"); // "^" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(96),"%60"); // "`" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(123),"%7B"); // "{" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(124),"%7C"); // "|" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(125),"%7D"); // "}" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,Символ(32),"%20"); // " "  (пробел)
	Иначе
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%25",Символ(37) ); // "%"
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%21",Символ(33) ); // "!"
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%22",Символ(34) ); // """  (кавычка)
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%23",Символ(35) ); // "#" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%24",Символ(36) ); // "$"	
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%26",Символ(38) ); // "&" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%27",Символ(39) ); // "'" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%2A",Символ(42) ); // "*" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%2C",Символ(44) ); // "," 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%3A",Символ(58) ); // ":" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%3B",Символ(59) ); // ";" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%3C",Символ(60) ); // "<" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%3D",Символ(61) ); // "=" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%3E",Символ(62) ); // ">" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%3F",Символ(63) ); // "?" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%5B",Символ(91) ); // "[" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%5D",Символ(93) ); // "]" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%5E",Символ(94) ); // "^" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%60",Символ(96) ); // "`" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%7B",Символ(123)); // "{" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%7C",Символ(124)); // "|" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%7D",Символ(125)); // "}" 
		ОбрабатываемаяСтрока = СтрЗаменить(ОбрабатываемаяСтрока,"%20",Символ(32) ); // " "  (пробел)
	КонецЕсли;
	
	Возврат ОбрабатываемаяСтрока;
	
КонецФункции

// #240 Пиганов Г.В. 2020-09-08
// Выполняет HTTPЗапрос для телеграмм по переданным параметрам и с обходом доступных прокси, если они заданы
//
// Параметры:
//  НастройкиБота - Структура - структура настроек бота
//  * ТокенБота - Строка - токен бота телеграмм. Получается при создании бота
//  * ТекущийПрокси - Строка,Неопределено - если Неопределено, то прокси не используется,
//                    иначе индекс прокси в массиве НастройкиБота.Прокси
//  * Прокси - Массив структур - Необязательный. Массив настроек доступных прокси
//  ** Адрес - Строка - Адрес прокси
//  ** Порт - Число - Порт прокси
//  ** Логин - Строка - Логи прокси
//  ** Пароль - Строка - Пароль прокси
//  Команда - Строка - команда телеграмм API
//  ПараметрыЗапроса - Структура,Соответствие - дополнительные параметры запроса. Передаются в HTTPЗапрос
//  Ответ - HTTPОтвет - переменная для получения результата запроса
//  ЭтоЗапросPOST - Булево - Признак выполнения POST, а не GET запроса. При GET запросе параметры
//                  передаются в строке URL, а при POST передаюттся в теле запроса
//
// Возвращаемое значение:
//  Булево - признак успешного выполнения запроса (код ответа 200 или 300)
//
Функция ВыполнитьЗапросHTTP(НастройкиБота, Команда, ПараметрыЗапроса, Ответ, ЭтоЗапросPOST = Истина) Экспорт
	
	ЕстьПрокси = НастройкиБота.ТекущийПрокси <> Неопределено;
	
	// Цикл обхода прокси, если они есть или запрос без прокси
	Пока Истина Цикл
		
		СоединениеHTTP = НовоеСоединениеHTTP(НастройкиБота);
		
		Ресурс = "bot" + НастройкиБота.ТокенБота + "/" + Команда;
		
		Если ЭтоЗапросPOST Тогда
			
			// Запрос POST. Параметры в теле запроса
			СтрокаJSON = СтрокаJSONИзСоответствия(ПараметрыЗапроса);
			
			ЗапросHTTP = Новый HTTPЗапрос(Ресурс);
			ЗапросHTTP.Заголовки.Вставить("Content-type", "keep-alive");
			ЗапросHTTP.Заголовки.Вставить("Content-type", "application/json");
			ЗапросHTTP.УстановитьТелоИзСтроки(СтрокаJSON);
			
			Попытка
				Ответ = СоединениеHTTP.ОтправитьДляОбработки(ЗапросHTTP);
			Исключение
				ЗаписьЖурналаРегистрации("Телеграмм.Отправка", УровеньЖурналаРегистрации.Ошибка,,, ОписаниеОшибки());
				Ответ = Неопределено;
			КонецПопытки;
		Иначе
			// Запрос GET. Параметры в строке URL запроса
			Если ПараметрыЗапроса.Количество() > 0 Тогда
				Ресурс = Ресурс + "?";
				Для Каждого КлючИЗначение Из ПараметрыЗапроса Цикл
					Ресурс = Ресурс + "&" + КлючИЗначение.Ключ + "=" + КлючИЗначение.Значение;
				КонецЦикла;
			КонецЕсли;
			
			ЗапросHTTP = Новый HTTPЗапрос(Ресурс);
			ЗапросHTTP.Заголовки.Вставить("Content-type", "keep-alive");
			Попытка
				Ответ = СоединениеHTTP.Получить(ЗапросHTTP);
			Исключение
				Ответ = Неопределено;
			КонецПопытки;
		КонецЕсли;
		
		ОтветУспешен = Ответ <> Неопределено И (Ответ.КодСостояния = 200 ИЛИ Ответ.КодСостояния = 300);
		
		Если НЕ ЕстьПрокси Тогда
			Прервать; // Ответ получен успешный или нет
		КонецЕсли;
		
		Если ОтветУспешен Тогда
			ОтветСтрокаJSON = Ответ.ПолучитьТелоКакСтроку();
			// прокси может уже не работать, или внесен в гос реестр
			Если СтрНайти(НРег(ОтветСтрокаJSON), "<html>") = 0 Тогда 
				// Прокси успешно отработал
				НастройкиПрокси = НастройкиБота.Прокси[НастройкиБота.ТекущийПрокси];
				РегистрыСведений.узПроксиСерверы.ИзменитьОценкуРаботоспособностиПроксиСервера(НастройкиПрокси.Адрес, НастройкиПрокси.Порт, 1);
				Прервать;
			КонецЕсли;
		КонецЕсли;
		
		// Прокси не отработал
		НастройкиПрокси = НастройкиБота.Прокси[НастройкиБота.ТекущийПрокси];
		РегистрыСведений.узПроксиСерверы.ИзменитьОценкуРаботоспособностиПроксиСервера(НастройкиПрокси.Адрес, НастройкиПрокси.Порт, -1);
		
		// Переход к следующему прокси
		Если НастройкиБота.ТекущийПрокси + 1 = НастройкиБота.Прокси.Количество() Тогда
			// Закончились рабочие прокси
			НастройкиБота.ТекущийПрокси = 0;
			ОтветУспешен = Ложь;
			Ответ = Неопределено;
			Прервать;
		КонецЕсли;
		НастройкиБота.ТекущийПрокси = НастройкиБота.ТекущийПрокси + 1;
	КонецЦикла;
	
	Возврат ОтветУспешен;
	
КонецФункции

#КонецОбласти

// #240 Пиганов Г.В. 2020-09-08
// Создает новое HTTPСоединение для бота телеграмм с учетом выбранного прокси
//
// Параметры:
//  НастройкиБота - Структура - структура настроек бота
//  * ТекущийПрокси - Строка,Неопределено - если Неопределено, то прокси не используется,
//                    иначе индекс прокси в массиве НастройкиБота.Прокси
//  * Прокси - Массив структур - Необязательный. Массив настроек доступных прокси
//  ** Адрес - Строка - Адрес прокси
//  ** Порт - Число - Порт прокси
//  ** Логин - Строка - Логи прокси
//  ** Пароль - Строка - Пароль прокси
//
// Возвращаемое значение:
//  HTTPСоединение - созданное соединение
//
Функция НовоеСоединениеHTTP(НастройкиБота)
	
	Если НастройкиБота.ТекущийПрокси = Неопределено Тогда
		ИнтернетПрокси = Неопределено;
	Иначе
		НастройкиПрокси = НастройкиБота.Прокси[НастройкиБота.ТекущийПрокси];
		ИнтернетПрокси = Новый ИнтернетПрокси(Ложь);
		ИнтернетПрокси.Установить("https", НастройкиПрокси.Адрес, НастройкиПрокси.Порт, НастройкиПрокси.Логин, НастройкиПрокси.Пароль, Ложь);
	КонецЕсли;
	Соединение = Новый HTTPСоединение("api.telegram.org", 443,,, ИнтернетПрокси, 30, Новый ЗащищенноеСоединениеOpenSSL());
	
	Возврат Соединение;
	
КонецФункции

// #240 Пиганов Г.В. 2020-09-08
// Используется в регламентном задании для получения и обработки сообщений
//
Процедура РегламентноеПолучениеИОбработкаСообщений() Экспорт
	
	НастройкиБота = НастройкиБота();
	
	Сообщения = ПолучитьНовыеСообщения();
	Для Каждого Сообщение Из Сообщения Цикл
		узТелеграмБотКоманды.ОбработатьКомандыСообщения(НастройкиБота, Сообщение);
	КонецЦикла;
	
КонецПроцедуры

// #240 Пиганов Г.В. 2020-09-08
// Возвращает таблицу пользователей, у которых заполнен идентификатор пользователя телеграмм
//
// Возвращаемое значение:
//  ТаблицаЗначений - Таблица пользователей
//  * ПользовательИД - Строка - идентификатор пользователя телеграмм
//  * Ссылка - СправочникСсылка.Пользователи - ссылка на пользователя
//
Функция ВсеПользователиТелеграмм()
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Пользователи.узИДПользователяТелеграмм КАК ПользовательИД,
	|	МАКСИМУМ(Пользователи.Ссылка) КАК Ссылка
	|ИЗ
	|	Справочник.Пользователи КАК Пользователи
	|ГДЕ
	|	Пользователи.узИДПользователяТелеграмм <> 0
	|
	|СГРУППИРОВАТЬ ПО
	|	Пользователи.узИДПользователяТелеграмм";
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// #240 Пиганов Г.В. 2020-09-08
// Возвращает выборку из запроса с пользователями с учетом отбора, для которых разрешена
// отправка сообщений в телеграмм и у которых заполнен идентификатор пользователя телеграмм
//
// Параметры:
//  Пользователи - Массив, СправочникСсылка.Пользователь - массив или один пользователь
//
// Возвращаемое значение:
//  ВыборкаИзРезультатаЗапроса - выборка пользователей
//  * Пользователь - СправочникСсылка.Пользователь - Ссылка на пользователя
//  * ПользовательИД - идентификатор пользователя телеграмм
//
Функция ВыборкаПользователейТелеграмДляОтправки(Пользователи)
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Пользователи.Ссылка КАК Пользователь,
	|	Пользователи.узИДПользователяТелеграмм КАК ПользовательИД
	|ИЗ
	|	Справочник.Пользователи КАК Пользователи
	|ГДЕ
	|	Пользователи.Ссылка В(&Пользователи)
	|	И Пользователи.узИспользоватьРассылкуЧерезТелеграмм
	|	И Пользователи.узИДПользователяТелеграмм <> 0";
	Запрос.УстановитьПараметр("Пользователи", Пользователи);
	
	Возврат Запрос.Выполнить().Выбрать();
	
КонецФункции

// #240 Пиганов Г.В. 2020-09-08
// Преобразует строку JSON в соответствие типовым сериализатором 1С
//
// Параметры:
//  СтрокаJSON - Строка - строка JSON для преобразования
//
// Возвращаемое значение:
//  Соответствие - результат преобразования
//
Функция СоответствиеИзСтрокиJSON(СтрокаJSON) Экспорт
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	ОтветСоответствие = ПрочитатьJSON(ЧтениеJSON, Истина);
	ЧтениеJSON.Закрыть();
	
	Возврат ОтветСоответствие;
	
КонецФункции

// #240 Пиганов Г.В. 2020-09-08
// Преобразует соответствие в строку JSON типовым сериализатором 1С
//
// Параметры:
//  СоответствиеДанных - Соответствие - данные для преобразования
//
// Возвращаемое значение:
//  Строка - результат преобразования
//
Функция СтрокаJSONИзСоответствия(СоответствиеДанных) Экспорт
	
	ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON;
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
	ЗаписатьJSON(ЗаписьJSON, СоответствиеДанных);
	Возврат ЗаписьJSON.Закрыть();
	
КонецФункции
